;;; -*- lisp -*-

(BG_PUSH

(FORALL (m i x)
  (PATS (select (store m i x) i))
  (EQ (select (store m i x) i) x))

(FORALL (m i v j)
  (PATS (select (store m i v) j) PROMOTE)
  (OR 
     (EQ i j)
     (EQ (select (store m i v) j)
	 (select m j))
   )
  )

(FORALL (m i n) 
  (PATS (NUMBER (ADDR (SUBARRAY m i n)) 0))
  (EQ (NUMBER (ADDR (SUBARRAY m i n)) 0) n))

(FORALL (m i n j)
  (PATS (select (SUBARRAY m i n) j))
  (EQ (select (SUBARRAY m i n) j) (select m (+ i j))))

(FORALL (m i x)
  (PATS (ADDR (store m i x)))
  (EQ (ADDR (store m i x)) (ADDR m)))

(FORALL (m i n m2)
  (PATS (ADDR (storeSub m i n m2)))
  (EQ (ADDR (storeSub m i n m2)) (ADDR m)))

(FORALL (m r)
  (PATS (MPAT (ADDR (select m r))
	      (CONCVARSYM m)))
  (IMPLIES
   (AND
    (EQ (CONCVARSYM m) |@true|)
    (EQ (SUBTYPE1 (TYPECODE r) |REFANY.TYPECODE|) |@true|)
    (NEQ (TYPECODE r) |ROOT.TYPECODE|)
    )
   (EQ (ADDR (select m r)) r)))

(FORALL (m i v)
  (PATS (MPAT (CONCVARSYM m) (store m i v)))
  (IMPLIES (EQ (CONCVARSYM m) |@true|)
	   (EQ (CONCVARSYM (store m i v)) |@true|)))

(FORALL (m i j)
  (PATS (NUMBER (ADDR (select m i)) j))
  (IMPLIES
   (EQ (|Is$ORDINAL| i) |@true|)
   (EQ (NUMBER (ADDR (select m i)) j)
       (NUMBER (ADDR m) (+ j 1)))))


(FORALL (r)
  (IMPLIES
   (EQ (|Is$ROOT| r) |@true|)
   (EQ (|Is$REFANY| r) |@true|)))

(FORALL (v i)
  (PATS (select (mapFill v) i))
  (EQ (select (mapFill v) i) v))

(FORALL (m i)
  (PATS (NUMBER m i))
  (>= (NUMBER m i) 0))

(FORALL (i t)
  (PATS (ORD (VAL i t)))
  (EQ (ORD (VAL i t)) i))

;; This seemingly liberal trigger is necessary to establish the function
;; ORD is injective.
(FORALL (i)
  (PATS (ORD i))
  (EQ (VAL (ORD i) (TYPECODE i)) i))

(FORALL (x tc)
  (PATS (NARROW x tc))
  (IMPLIES
   (EQ (SUBTYPE (TYPECODE x) tc) |@true|)
   (EQ (NARROW x tc) x)))

;; Rules about NEW
(FORALL (ao ll virg tc pos)
  (PATS (NEW ao ll virg tc pos))
  (NEQ (select ao (NEW ao ll virg tc pos)) |@true|)
  )
(FORALL (ao ll virg tc pos)
  (PATS (NEW ao ll virg tc pos))
  (NEQ (MEMBER (NEW ao ll virg tc pos) ll) |@true|))

(FORALL (ao ll virg tc pos)
  (PATS (NEW ao ll virg tc pos))
  (EQ (select virg (NEW ao ll virg tc pos)) |@true|)
  )
(FORALL (ao ll virg tc pos)
  (PATS (NEW ao ll virg tc pos))
  (EQ (TYPECODE (NEW ao ll virg tc pos)) tc))
(FORALL (ao ll virg tc pos)
  (PATS (NEW ao ll virg tc pos))
  (NEQ (NEW ao ll virg tc pos) |$NIL|))

;; Subtype...
(ORDER SUBTYPE_STRICT SUBTYPE)

;;-----------------------------------
;; Def of DCL rule.
(FORALL (x al)
  (PATS (MPAT (|Is$REFANY| x) (|Is$DCL| x al)))
  (IMPLIES
   (AND
    (EQ (|Is$REFANY| x) |@true|)
    (EQ (|Is$DCL| x al) |@true|)
    )
   (EQ (select al x) |@true|)))

;; Def of NVIRG rule.
(FORALL (x v)
  (PATS (MPAT (|Is$REFANY| x) (|Is$NVIRG| x v)))
  (IMPLIES
   (AND
    (EQ (|Is$REFANY| x) |@true|)
    (EQ (|Is$NVIRG| x v) |@true|)
    )
   (NEQ (select v x) |@true|)))

;; Preservation through SUCCEEDS...

;; ...of Is$DCL...
(FORALL (x al0 v0 al1 v1)
  (PATS (MPAT (|Is$DCL| x al0) (SUCCEEDS al1 v1 al0 v0)))
  (IMPLIES
   (AND (EQ (|Is$DCL| x al0) |@true|)
	(EQ (SUCCEEDS al1 v1 al0 v0) |@true|))
   (EQ (|Is$DCL| x al1) |@true|)
   ))

;; ...of Is$DCLOSED...
(FORALL (f al0 v0 al1 v1)
  (PATS (MPAT (|Is$DCLOSED| f al0) (SUCCEEDS al1 v1 al0 v0)))
  (IMPLIES
   (AND (EQ (|Is$DCLOSED| f al0) |@true|)
	(EQ (SUCCEEDS al1 v1 al0 v0) |@true|))
   (EQ (|Is$DCLOSED| f al1) |@true|)
   ))


;; ...of Is$NVIRG...
(FORALL (x al0 v0 al1 v1)
  (PATS (MPAT (|Is$NVIRG| x v0) (SUCCEEDS al1 v1 al0 v0)))
  (IMPLIES
   (AND (EQ (|Is$NVIRG| x v0) |@true|)
	(EQ (SUCCEEDS al1 v1 al0 v0) |@true|))
   (EQ (|Is$NVIRG| x v1) |@true|)
   ))

;; ...and of Is$VCONSISTENT.
(FORALL (f al0 v0 al1 v1)
  (PATS (MPAT (|Is$VCONSISTENT| f al0 v0) (SUCCEEDS al1 v1 al0 v0)))
  (IMPLIES
   (AND (EQ (|Is$VCONSISTENT| f al0 v0) |@true|)
	(EQ (SUCCEEDS al1 v1 al0 v0) |@true|))
   (EQ (|Is$VCONSISTENT| f al1 v1) |@true|)
   ))

;;-----------------------------------
;; Is$DCL select-of-store rule.
(FORALL (x al y)
  (PATS (|Is$DCL| x (store al y |@true|)))
  (IMPLIES (AND
	    (EQ (|Is$REFANY| x) |@true|)
	    (EQ (|Is$DCL| x (store al y |@true|)) |@true|)
	    )
	   (OR (EQ x y)
	       (EQ (|Is$DCL| x al) |@true|))))

;;-----------------------------------

;; Subtype1 implies subtype
(FORALL (tc1 tc2) 
  (PATS (SUBTYPE1 tc1 tc2))
  (IMPLIES (EQ (SUBTYPE1 tc1 tc2) |@true|)
	   (EQ (SUBTYPE tc1 tc2) |@true|)))

;; Necessary to make type distinctions work.
(FORALL (x)
  (PATS (TYPECODE x))
  (EQ (SUBTYPE (TYPECODE x) (TYPECODE x)) |@true|))

;; The incomparable type rule (Jim Saxe version...yay!)
(FORALL (tc1 tc2 tc3)
  (PATS (MPAT (SUBTYPE1 tc2 tc1) (SUBTYPE tc3 tc2)))
  (IMPLIES
   (AND
    (EQ (SUBTYPE1 tc2 tc1) |@true|)
    (EQ (SUBTYPE tc3 tc2) |@true|)
    (NEQ tc3 (TYPECODE |$NIL|))
    )
   (EQ (ONESTEP tc1 tc3) tc2)
   ))

;;; Some facts about NULL.
(EQ (TYPECODE |$NIL|) |NULL.TYPECODE|)

(FORALL (x) 
  (PATS (NEQ x |$NIL|))
  (IMPLIES (NEQ x |$NIL|) (NEQ (TYPECODE x) |NULL.TYPECODE|)))

;; Ordinals and refs are distinct
(FORALL (x)
  (PATS (MPAT (SUBTYPE (TYPECODE x) |REFANY.TYPECODE|)
	      (|Is$ORDINAL| x)))
  (OR
   (NEQ (SUBTYPE (TYPECODE x) |REFANY.TYPECODE|) |@true|)
   (NEQ (|Is$ORDINAL| x) |@true|))
  )

;; INTEGER are MATHINTs; MATHINTs are ordinals.
(FORALL (x)
  (PATS (|Is$INTEGER| x))
  (IMPLIES (EQ (|Is$INTEGER| x) |@true|)
	   (EQ (|Is$MATHINT| x) |@true|)))
(FORALL (x)
  (PATS (|Is$MATHINT| x))
  (IMPLIES (EQ (|Is$MATHINT| x) |@true|)
	   (EQ (|Is$ORDINAL| x) |@true|)))


;;; Definitions of MAX and MIN.
(FORALL (a b)
  (PATS (MAX a b))
  (>= (MAX a b) a))
(FORALL (a b)
  (PATS (MAX a b))
  (>= (MAX a b) b))
(FORALL (a b)
  (PATS (MAX a b))
  (OR (EQ (MAX a b) a) (EQ (MAX a b) b)))

(FORALL (a b)
  (PATS (MIN a b))
  (<= (MIN a b) a))
(FORALL (a b)
  (PATS (MIN a b))
  (<= (MIN a b) b))
(FORALL (a b)
  (PATS (MIN a b))
  (OR (EQ (MIN a b) a) (EQ (MIN a b) b)))


;; MUT_LT is a partial order used for mutex lock order.

;; MUT_LT Irreflexive...
(FORALL (x)
  (PATS (MUT_LT x x))
  (NEQ (MUT_LT x x) |@true|))

;; MUT_LT Anti-symmetric...
(FORALL (x y)
  (PATS (MPAT (MUT_LT x y) (MUT_LT y x)))
  (OR (NEQ (MUT_LT x y) |@true|) (NEQ (MUT_LT y x) |@true|)))

;; MUT_LT Transitive.
(FORALL (x y z)
  (PATS (MPAT (MUT_LT x y) (MUT_LT y z)))
  (OR (NEQ (MUT_LT x y) |@true|) 
      (NEQ (MUT_LT y z) |@true|) (EQ (MUT_LT x z) |@true|)))

;; Other of MUT_LT...

;; MUT_LE
(FORALL (a b)
  (PATS (MUT_LE a b))
  (IFF (EQ (MUT_LE a b) |@true|) (OR (EQ a b) (EQ (MUT_LT a b) |@true|))))

;; MUT_GE
(FORALL (a b)
  (PATS (MUT_GE a b))
  (EQ (MUT_GE a b) (MUT_LE b a)))

;; MUT_GT
(FORALL (a b)
  (PATS (MUT_GT a b))
  (EQ (MUT_GT a b) (MUT_LT b a)))

;;; Manipulation of locking level sets.

;; MEMBER 1
(FORALL (x s)
  (PATS (MEMBER x (INSERT s x)))
  (EQ (MEMBER x (INSERT s x)) |@true|))

;; MEMBER 2
(FORALL (x y s) 
  (PATS (MEMBER x (INSERT s y)))
  (IMPLIES (NEQ x y) (EQ (MEMBER x (INSERT s y)) (MEMBER x s))))

;; DELETE 1
(FORALL (x s) 
  (PATS (DELETE s x))
  (IMPLIES (NEQ (MEMBER x s) |@true|) (EQ (DELETE s x) s)))

;; DELETE 2
(FORALL (x s) 
  (PATS (DELETE (INSERT s x) x))
  (EQ (DELETE (INSERT s x) x) (DELETE s x)))

;; DELETE 3
(FORALL (x y s) 
  (PATS (DELETE (INSERT s y) x))
  (IMPLIES (NEQ x y) (EQ (DELETE (INSERT s y) x) (INSERT (DELETE s x) y))))

;; sup 1
(FORALL (s) (PATS (sup s)) (EQ (MEMBER (sup s) s) |@true|))

;; sup 2
(FORALL (s x)
  (PATS (MEMBER x s))
  (IMPLIES (EQ (MEMBER x s) |@true|)  (EQ (MUT_LE x (sup s)) |@true|)))

;; sup 3
(FORALL (s x)
  (PATS (sup (INSERT s x)))
  (IMPLIES (EQ (MUT_LT (sup s) x) |@true|) (EQ (sup (INSERT s x)) x)))

(FORALL (m i n m2 j)
  (PATS (select (storeSub m i n m2) j))
  (AND (OR (>= j i)
	   (EQ (select (storeSub m i n m2) j)
	       (select m j)))
       (OR (< j (+ i n))
	   (EQ (select (storeSub m i n m2) j)
	       (select m j)))
       (OR (< j i)
	   (>= j (+ i n))
	   (EQ (select (storeSub m i n m2) j)
	       (select m2 (- j i))))
       (OR (EQ (select (storeSub m i n m2) j)
	       (select m j))
	   (EQ (select (storeSub m i n m2) j)
	       (select m2 (- j i)))))
	)

;; Axioms about reachability.

;; A1f (one-hop forward)
(FORALL (u v l x)
  (PATS (REACH u v l x))
  (IMPLIES (EQ (REACH u v l x) |@true|)
	   (OR (EQ u v)
	       (AND (NEQ u x)
		    (EQ (REACH (select l u) v l x) |@true|)))))

;; A1r1 (one-hop reverse1)
(FORALL (u u l x)
  (PATS (REACH u u l x))
  (EQ (REACH u u l x) |@true|))
;; A1r2 (one-hop reverse2)
(FORALL (u v l x)
  (PATS (REACH (select l u) v l x))
  (IMPLIES 
   (AND (NEQ u x)
	(EQ (REACH (select l u) v l x) |@true|)
	)
   (EQ (REACH u v l x) |@true|)
   ))

;; A2 (transitivity)
(FORALL (u v w l x)
  (PATS (MPAT (REACH u v l x) (REACH v w l x)))
  (IMPLIES
   (AND 
    (EQ (REACH u v l x) |@true|)
    (EQ (REACH v w l x) |@true|)
    )
   (EQ (REACH u w l x) |@true|)))

;; A3 (select-first)
(FORALL (u v l x)
 (PATS (REACH u v l x))
  (IMPLIES
   (EQ (REACH u v l x) |@true|)
   (EQ (REACH u v l v) |@true|)))

;; A4 (exclude-transitivity)
(FORALL (u x y z l)
  (PATS (MPAT (REACH u x l y) (REACH u y l z)))
  (IMPLIES
   (AND
    (EQ (REACH u x l y) |@true|)
    (EQ (REACH u y l z) |@true|)
    )
   (EQ (REACH u x l z) |@true|)))

;; A5 (almost-total)
(FORALL (u x y l)
  (PATS (REACH u x l y))
  (IMPLIES
   (OR
    (EQ (REACH u x l x) |@true|)
    (EQ (REACH u y l y) |@true|)
    )
   (OR
    (EQ (REACH u x l y) |@true|)
    (EQ (REACH u y l x) |@true|)
    )))

;; A6 ()
(FORALL (u x y z l)
  (PATS (MPAT (REACH u x l y) (REACH u y l z)))
  (IMPLIES
   (AND
    (EQ (REACH u x l y) |@true|)
    (EQ (REACH u y l z) |@true|)
    )
   (EQ (REACH x y l z) |@true|)))

;; A7 ()
(FORALL (u v l)
  (PATS (REACH (select l u) v l v))
  (IMPLIES
   (EQ (REACH (select l u) v l v) |@true|)
   (EQ (REACH (select l u) v l u) |@true|)))

;; A8 ()
(FORALL (u v l x p q)
  (PATS (MPAT (REACH u v l x) (REACH u v l p) (store l p q)))
  (IMPLIES
   (AND (EQ (REACH u v l x) |@true|)
	(EQ (REACH u v l p) |@true|))
   (AND (EQ (REACH u v (store l p q) x) |@true|)
	(EQ (REACH u v (store l p q) p) |@true|))))

;; The following are reachability-related...

;; This enables for preservation of validity in t80.
;; It seems like it ought to be a lemma.  Maybe we can put it in an
;; interface...
(FORALL (s alloc t l x)
  (PATS (MPAT (|Is$DCL| s ALLOCATED)
	      (REACH s t l x)))
  (IMPLIES
   (AND
    (EQ (|Is$DCL| s ALLOCATED) |@true|)
    (EQ (REACH s t l x) |@true|)
    )
   (EQ (|Is$DCL| t ALLOCATED) |@true|)))

;; This is kind of the converse of the above.  It came up in "Filter.Try", in
;; showing that some of the modtargets possibilities didn't have to be
;; considered.  I hope there's some other way of doing it. 
(FORALL (s t alloc l x)
  (PATS (MPAT (REACH s t l x) (NEQ (select alloc s) |@true|)))
  (IMPLIES
   (AND
    (NEQ (select alloc s) |@true|)
    (EQ (select alloc t) |@true|)
    )
   (NEQ (REACH s t l x) |@true|)
   ))

;; A fact about NIL:
(FORALL (s l x)
  (PATS (REACH |$NIL| s l x))
  (IMPLIES
   (EQ (REACH |$NIL| s l x) |@true|)
   (EQ s |$NIL|)))

	 
;; CONCAT, used by built-in spec of Text.Cat.
(FORALL (m1 m2)
  (PATS (NUMBER (ADDR (CONCAT m1 m2)) 0))
  (EQ (NUMBER (ADDR (CONCAT m1 m2)) 0) (+ (NUMBER m1 0) (NUMBER m2 0))))

(FORALL (m1 m2 i)
  (PATS (select (CONCAT m1 m2) i))
  (AND (OR (NOT (< i (NUMBER m1 0)))
	   (EQ (select (CONCAT m1 m2) i) (select m1 i)))
       (OR (NOT (>= i (NUMBER m1 0)))
	   (EQ (select (CONCAT m1 m2) i)
	       (select m2 (- i (NUMBER m1 0)))))))

;;; Integer arithmetic operations.

(FORALL (x y)
  (PATS (DIV x y))
  (EQ (+ (MOD x y) (* y (DIV x y))) x))

(FORALL (x y)
  (PATS (MOD x y))
  (IMPLIES (> y 0) (<= 0 (MOD x y))))
(FORALL (x y)
  (PATS (MOD x y))
  (IMPLIES (> y 0) (< (MOD x y) y)))
(FORALL (x y)
  (PATS (MOD x y))
  (IMPLIES (< y 0) (< y (MOD x y))))
(FORALL (x y)
  (PATS (MOD x y))
  (IMPLIES (< y 0) (<= (MOD x y) 0)))
(FORALL (x y)
  (PATS (MOD (+ x y) y))
  (EQ (MOD (+ x y) y) (MOD x y)))
(FORALL (x y)
  (PATS (MOD (+ y x) y))
  (EQ (MOD (+ y x) y) (MOD x y)))
(FORALL (x y)
  (PATS (MOD (- x y) y))
  (EQ (MOD (+ y x) y) (MOD x y)))

;; Rules about operations on REAL's.

(FORALL (r1 r2)
  (PATS (|R<=| r1 r2))
  (IMPLIES (EQ (|R<=| r1 r2) |@true|)
	   (OR (EQ (|R<| r1 r2) |@true|) (EQ r1 r2))))
(FORALL (r1 r2)
  (PATS (|R<| r1 r2))
  (IMPLIES (EQ (|R<| r1 r2) |@true|) (EQ (|R<=| r1 r2) |@true|)))
(FORALL (r1 r2)
  (PATS (|R>=| r1 r2))
  (IMPLIES (EQ (|R>=| r1 r2) |@true|)
	   (OR (EQ (|R>| r1 r2) |@true|) (EQ r1 r2))))
(FORALL (r1 r2)
  (PATS (|R>| r1 r2))
  (IMPLIES (EQ (|R>| r1 r2) |@true|) (OR (EQ (|R>=| r1 r2) |@true|))))

(FORALL (r)
  (PATS (|R*| r FLOAT_ZERO))
  (EQ (|R*| r FLOAT_ZERO) FLOAT_ZERO))
(FORALL (r)
  (PATS (|R*| FLOAT_ZERO r))
  (EQ (|R*| FLOAT_ZERO r) FLOAT_ZERO))
(FORALL (r1 r2)
  (PATS (|R*| r1 r2))
  (IMPLIES (OR (AND (EQ (|R>=| r1 FLOAT_ZERO) |@true|)
		    (EQ (|R>=| r2 FLOAT_ZERO) |@true|))
	       (AND (EQ (|R<=| r1 FLOAT_ZERO) |@true|)
		    (EQ (|R<=| r2 FLOAT_ZERO) |@true|)))
	   (EQ (|R>=| (|R*| r1 r2) FLOAT_ZERO) |@true|)))
(FORALL (r1 r2)
  (PATS (|R*| r1 r2))
  (IMPLIES (OR (AND (EQ (|R>| r1 FLOAT_ZERO) |@true|)
		    (EQ (|R<| r2 FLOAT_ZERO) |@true|))
	       (AND (EQ (|R<| r1 FLOAT_ZERO) |@true|)
		    (EQ (|R>| r2 FLOAT_ZERO) |@true|)))
	   (EQ (|R<| (|R*| r1 r2) FLOAT_ZERO) |@true|)))

(FORALL (r) (PATS (|R+| r FLOAT_ZERO)) (EQ (|R+| r FLOAT_ZERO) r))
(FORALL (r) (PATS (|R+| FLOAT_ZERO r)) (EQ (|R+| FLOAT_ZERO r) r))
(FORALL (r1 r2)
  (PATS (|R+| r1 r2))
  (IMPLIES (AND (EQ (|R>=| r1 FLOAT_ZERO) |@true|)
		(EQ (|R>=| r2 FLOAT_ZERO) |@true|))
	   (EQ (|R>=| (|R+| r1 r2) FLOAT_ZERO) |@true|)))
(FORALL (r1 r2)
  (PATS (|R+| r1 r2))
  (IMPLIES (AND (EQ (|R<=| r1 FLOAT_ZERO) |@true|)
		(EQ (|R<=| r2 FLOAT_ZERO) |@true|))
	   (EQ (|R<=| (|R+| r1 r2) FLOAT_ZERO) |@true|)))


(FORALL (i type)
  (PATS (FLOAT i type))
  (IMPLIES (>= i 0) (EQ (|R>=| (FLOAT i type) FLOAT_ZERO) |@true|)))

(FORALL (r)
  (PATS (ROUND r))
  (IMPLIES (EQ (|R>=| r FLOAT_ZERO) |@true|) (>= (ROUND r) 0)))

;; Term versions of relational and boolean operators.
(FORALL (x y)
  (PATS (|TERM=| x y))
  (IFF (EQ (|TERM=| x y) |@true|) (EQ x y)))
(FORALL (x y)
  (PATS (|TERM#| x y))
  (IFF (EQ (|TERM#| x y) |@true|) (NEQ x y)))
(FORALL (x y)
  (PATS (|TERM<| x y))
  (IFF (EQ (|TERM<| x y) |@true|) (< x y)))
(FORALL (x y)
  (PATS (|TERM>| x y))
  (IFF (EQ (|TERM>| x y) |@true|) (> x y)))
(FORALL (x y)
  (PATS (|TERM<=| x y))
  (IFF (EQ (|TERM<=| x y) |@true|) (<= x y)))
(FORALL (x y)
  (PATS (|TERM>=| x y))
  (IFF (EQ (|TERM>=| x y) |@true|) (>= x y)))
(FORALL (x y)
  (PATS (|TERM_AND| x y))
  (IFF (EQ (|TERM_AND| x y) |@true|) (AND (EQ x |@true|) (EQ y |@true|))))
(FORALL (x y)
  (PATS (|TERM_OR| x y))
  (IFF (EQ (|TERM_OR| x y) |@true|) (OR (EQ x |@true|) (EQ y |@true|))))
(FORALL (x)
  (PATS (|TERM_NOT| x))
  (IFF (EQ (|TERM_NOT| x) |@true|) (NEQ x |@true|)))

;; For all the function symbols axiomatized in this file that always
;; return a single type, we need to axiomatize that type restriction.
;; It would be good to have a more general mechanism that does this
;; for user declared types, as well; what I think of as the "side
;; condition" mechanism.
(FORALL (s) (PATS (sup s)) (EQ (|Is$MUTEX| (sup s)) |@true|))

;; Performance of this is questionable...
(FORALL (m i)
  (PATS (NUMBER m i))
  (EQ (|Is$INTEGER| (NUMBER m i)) |@true|)
  )

(FORALL (s1 s2) (PATS (SUBSET s1 s2))
      (EQ (|Is$BOOLEAN| (SUBSET s1 s2)) |@true|))
(FORALL (r) (PATS (TYPECODE r))
      (EQ (|Is$ORDINAL| (TYPECODE r)) |@true|))
(FORALL (a b) (PATS (MAX a b)) (EQ (|Is$INTEGER| (MAX a b)) |@true|))
(FORALL (a b) (PATS (MIN a b)) (EQ (|Is$INTEGER| (MIN a b)) |@true|))
(FORALL (r) (PATS (ROUND r)) (EQ (|Is$INTEGER| (ROUND r)) |@true|))
(FORALL (a b) (PATS (+ a b)) (EQ (|Is$MATHINT| (+ a b)) |@true|))
(FORALL (a b) (PATS (- a b)) (EQ (|Is$MATHINT| (- a b)) |@true|))
(FORALL (m1 m2) (PATS (MUT_LT m1 m2))
      (EQ (|Is$BOOLEAN| (MUT_LT m1 m2)) |@true|))
(FORALL (m1 m2) (PATS (MUT_LE m1 m2))
      (EQ (|Is$BOOLEAN| (MUT_LE m1 m2)) |@true|))
(FORALL (m1 m2) (PATS (MUT_GT m1 m2))
      (EQ (|Is$BOOLEAN| (MUT_GT m1 m2)) |@true|))
(FORALL (m1 m2) (PATS (MUT_GE m1 m2))
      (EQ (|Is$BOOLEAN| (MUT_GE m1 m2)) |@true|))
(FORALL (s m)
  (PATS (MEMBER m s))
  (EQ (|Is$BOOLEAN| (MEMBER m s)) |@true|))
(FORALL (a b)
  (PATS (DIV a b))
  (IMPLIES (NEQ b 0)
	   (EQ (|Is$MATHINT| (DIV a b)) |@true|)))
(FORALL (a b)
  (PATS (MOD a b))
  (IMPLIES (NEQ b 0)
	   (EQ (|Is$MATHINT| (MOD a b)) |@true|)))

) ; end BG_PUSH

(DEFPREDMAP (|FUNC.IntSeq.Valid| |IntSeqRep.RefArray| |IntSeqRep.Public.elem| |IntSeqRep.Public.sz| |IntSeqRep.Public.st| |RESIDUE.IntSeq.Valid|) ind)
(DEFPREDMAP (|FUNC.IntSeq.Valid| |IntSeqRep.RefArray| |IntSeqRep.Public.elem| |IntSeqRep.Public.sz| |IntSeqRep.Public.st| |RESIDUE.IntSeq.Valid|) ind (AND (LBL v1 (NEQ ind |$NIL|)) (LBL v2 (NEQ (select |IntSeqRep.Public.elem| ind) |$NIL|)) (LBL v3 (> (NUMBER (select |IntSeqRep.Public.elem| ind) 0) 0)) (LBL v4 (< (select |IntSeqRep.Public.st| ind) (NUMBER (select |IntSeqRep.Public.elem| ind) 0))) (LBL v5 (<= (select |IntSeqRep.Public.sz| ind) (NUMBER (select |IntSeqRep.Public.elem| ind) 0)))))

(BG_PUSH
(AND
(< 1000000 |INTEGER.LAST|)
(< |INTEGER.FIRST| -1000000)
(DISTINCT |IntSeqRep.Public.TYPECODE| |IntSeqRep.RefArray.TYPECODE| |IntSeq.Public.TYPECODE| |IntSeq.T.TYPECODE| |MUTEX.TYPECODE| |TEXT.TYPECODE| |REFANY.TYPECODE| |ROOT.TYPECODE| |NULL.TYPECODE|)
(DISTINCT RETURN EXIT)
(FORALL (|elems$$1| |st$$1| |sz$$1|) (NOPATS (|Is$IntSeqRep.EArr| |elems$$1|) (|Is$MATHINT| |st$$1|) (|Is$MATHINT| |sz$$1|)) (IMPLIES (AND (EQ (|Is$MATHINT| |sz$$1|) |@true|) (EQ (|Is$MATHINT| |st$$1|) |@true|) (EQ (|Is$IntSeqRep.EArr| |elems$$1|) |@true|)) (EQ (NUMBER (ADDR (|IntSeqRep.Abs| |elems$$1| |st$$1| |sz$$1|)) 0) |sz$$1|)))
(FORALL (|elems$| |st$| |sz$| |i$$2|) (NOPATS (|Is$IntSeqRep.EArr| |elems$|) (|Is$MATHINT| |st$|) (|Is$MATHINT| |sz$|) (|Is$MATHINT| |i$$2|)) (IMPLIES (AND (EQ (|Is$MATHINT| |i$$2|) |@true|) (EQ (|Is$MATHINT| |sz$|) |@true|) (EQ (|Is$MATHINT| |st$|) |@true|) (EQ (|Is$IntSeqRep.EArr| |elems$|) |@true|)) (AND (IMPLIES (AND (<= 0 (+ |i$$2| |st$|)) (< (+ |i$$2| |st$|) (NUMBER (ADDR |elems$|) 0))) (EQ (select (|IntSeqRep.Abs| |elems$| |st$| |sz$|) |i$$2|) (select |elems$| (+ |i$$2| |st$|)))) (IMPLIES (AND (<= (NUMBER (ADDR |elems$|) 0) (+ |i$$2| |st$|)) (< (+ |i$$2| |st$|) (* 2 (NUMBER (ADDR |elems$|) 0)))) (EQ (select (|IntSeqRep.Abs| |elems$| |st$| |sz$|) |i$$2|) (select |elems$| (- (+ |i$$2| |st$|) (NUMBER (ADDR |elems$|) 0))))))))
(EQ |BOOLEAN.FALSE| |@false|)
(EQ |BOOLEAN.TRUE| |@true|)
(FORALL (v) (IMPLIES (EQ (|Is$INTEGER| v) |@true|) (AND (>= v |INTEGER.FIRST|) (<= v |INTEGER.LAST|))))
(EQ (SUBTYPE1 |ROOT.TYPECODE| |REFANY.TYPECODE|) |@true|)
(EQ (SUBTYPE1 |MUTEX.TYPECODE| |ROOT.TYPECODE|) |@true|)
(< |INTEGER.FIRST| 0)
(> |INTEGER.LAST| 0)
(NOT (EQ (MEMBER |$NIL| LL) |@true|))
(EQ (|Is$NVIRG| |$NIL| VIRGIN) |@true|)
(EQ (|Is$DCL| |$NIL| ALLOCATED) |@true|)
(NEQ |@true| |@false|)
(EQ (|Is$REFANY$BOOLEAN$MAP| VIRGIN) |@true|)
(FORALL (|q$$32|) (IMPLIES (EQ (|Is$REFANY$BOOLEAN$MAP| |q$$32|) |@true|) (FORALL (|i$$1|) (EQ (|Is$BOOLEAN| (select |q$$32| |i$$1|)) |@true|))))
(FORALL (|map$$3|) (PATS (|Is$REFANY$BOOLEAN$MAP| |map$$3|)) (IMPLIES (EQ (|Is$REFANY$BOOLEAN$MAP| |map$$3|) |@true|) (FORALL (|ind$$1| |val$$1|) (PATS (store |map$$3| |ind$$1| |val$$1|)) (IMPLIES (EQ (|Is$BOOLEAN| |val$$1|) |@true|) (EQ (|Is$REFANY$BOOLEAN$MAP| (store |map$$3| |ind$$1| |val$$1|)) |@true|)))))
(FORALL (|q$$31|) (PATS (|Is$BOOLEAN| |q$$31|)) (IMPLIES (EQ (|Is$BOOLEAN| |q$$31|) |@true|) (AND (<= 0 (ORD |q$$31|)) (< (ORD |q$$31|) 2) (EQ (TYPECODE |q$$31|) |BOOLEAN.TYPECODE|) (OR (EQ |q$$31| |BOOLEAN.FALSE|) (EQ |q$$31| |BOOLEAN.TRUE|)))))
(FORALL (|q$$30|) (PATS (|Is$BOOLEAN| |q$$30|)) (IMPLIES (EQ (|Is$BOOLEAN| |q$$30|) |@true|) (EQ (|Is$ORDINAL| |q$$30|) |@true|)))
(DISTINCT |BOOLEAN.TRUE| |BOOLEAN.FALSE|)
(FORALL (|q$$29|) (PATS (|Is$CHAR| |q$$29|)) (IMPLIES (EQ (|Is$CHAR| |q$$29|) |@true|) (AND (<= 0 (ORD |q$$29|)) (< (ORD |q$$29|) 256) (EQ (TYPECODE |q$$29|) |CHAR.TYPECODE|))))
(FORALL (|q$$28|) (PATS (|Is$CHAR| |q$$28|)) (IMPLIES (EQ (|Is$CHAR| |q$$28|) |@true|) (EQ (|Is$ORDINAL| |q$$28|) |@true|)))
(DISTINCT |CHAR.C377| |CHAR.C376| |CHAR.C375| |CHAR.C374| |CHAR.C373| |CHAR.C372| |CHAR.C371| |CHAR.C370| |CHAR.C367| |CHAR.C366| |CHAR.C365| |CHAR.C364| |CHAR.C363| |CHAR.C362| |CHAR.C361| |CHAR.C360| |CHAR.C357| |CHAR.C356| |CHAR.C355| |CHAR.C354| |CHAR.C353| |CHAR.C352| |CHAR.C351| |CHAR.C350| |CHAR.C347| |CHAR.C346| |CHAR.C345| |CHAR.C344| |CHAR.C343| |CHAR.C342| |CHAR.C341| |CHAR.C340| |CHAR.C337| |CHAR.C336| |CHAR.C335| |CHAR.C334| |CHAR.C333| |CHAR.C332| |CHAR.C331| |CHAR.C330| |CHAR.C327| |CHAR.C326| |CHAR.C325| |CHAR.C324| |CHAR.C323| |CHAR.C322| |CHAR.C321| |CHAR.C320| |CHAR.C317| |CHAR.C316| |CHAR.C315| |CHAR.C314| |CHAR.C313| |CHAR.C312| |CHAR.C311| |CHAR.C310| |CHAR.C307| |CHAR.C306| |CHAR.C305| |CHAR.C304| |CHAR.C303| |CHAR.C302| |CHAR.C301| |CHAR.C300| |CHAR.C277| |CHAR.C276| |CHAR.C275| |CHAR.C274| |CHAR.C273| |CHAR.C272| |CHAR.C271| |CHAR.C270| |CHAR.C267| |CHAR.C266| |CHAR.C265| |CHAR.C264| |CHAR.C263| |CHAR.C262| |CHAR.C261| |CHAR.C260| |CHAR.C257| |CHAR.C256| |CHAR.C255| |CHAR.C254| |CHAR.C253| |CHAR.C252| |CHAR.C251| |CHAR.C250| |CHAR.C247| |CHAR.C246| |CHAR.C245| |CHAR.C244| |CHAR.C243| |CHAR.C242| |CHAR.C241| |CHAR.C240| |CHAR.C237| |CHAR.C236| |CHAR.C235| |CHAR.C234| |CHAR.C233| |CHAR.C232| |CHAR.C231| |CHAR.C230| |CHAR.C227| |CHAR.C226| |CHAR.C225| |CHAR.C224| |CHAR.C223| |CHAR.C222| |CHAR.C221| |CHAR.C220| |CHAR.C217| |CHAR.C216| |CHAR.C215| |CHAR.C214| |CHAR.C213| |CHAR.C212| |CHAR.C211| |CHAR.C210| |CHAR.C207| |CHAR.C206| |CHAR.C205| |CHAR.C204| |CHAR.C203| |CHAR.C202| |CHAR.C201| |CHAR.C200| |CHAR.DEL| |CHAR.TILDE| |CHAR.RBRACE| |CHAR.VBAR| |CHAR.LBRACE| |CHAR.z| |CHAR.y| |CHAR.x| |CHAR.w| |CHAR.v| |CHAR.u| |CHAR.t| |CHAR.s| |CHAR.r| |CHAR.q| |CHAR.p| |CHAR.o| |CHAR.n| |CHAR.m| |CHAR.l| |CHAR.k| |CHAR.j| |CHAR.i| |CHAR.h| |CHAR.g| |CHAR.f| |CHAR.e| |CHAR.d| |CHAR.c| |CHAR.b| |CHAR.a| |CHAR.BACKQUOTE| |CHAR.UNDERLINE| |CHAR.HAT| |CHAR.RBRACKET| |CHAR.BACKSLASH| |CHAR.LBRACKET| |CHAR.Z| |CHAR.Y| |CHAR.X| |CHAR.W| |CHAR.V| |CHAR.U| |CHAR.T| |CHAR.S| |CHAR.R| |CHAR.Q| |CHAR.P| |CHAR.O| |CHAR.N| |CHAR.M| |CHAR.L| |CHAR.K| |CHAR.J| |CHAR.I| |CHAR.H| |CHAR.G| |CHAR.F| |CHAR.E| |CHAR.D| |CHAR.C| |CHAR.B| |CHAR.A| |CHAR.AT| |CHAR.QUERY| |CHAR.GT| |CHAR.EQ| |CHAR.LT| |CHAR.SEMICOLON| |CHAR.COLON| |CHAR.NINE| |CHAR.EIGHT| |CHAR.SEVEN| |CHAR.SIX| |CHAR.FIVE| |CHAR.FOUR| |CHAR.THREE| |CHAR.TWO| |CHAR.ONE| |CHAR.ZERO| |CHAR.SLASH| |CHAR.DOT| |CHAR.MINUS| |CHAR.COMMA| |CHAR.PLUS| |CHAR.STAR| |CHAR.RPAREN| |CHAR.LPAREN| |CHAR.QUOTE| |CHAR.AMPS| |CHAR.PERCENT| |CHAR.DOLLAR| |CHAR.HASH| |CHAR.DQUOTE| |CHAR.EXCLAMATION| |CHAR.SP| |CHAR.US| |CHAR.RS| |CHAR.GS| |CHAR.FS| |CHAR.ESC| |CHAR.SUB| |CHAR.EM| |CHAR.CAN| |CHAR.ETB| |CHAR.SYN| |CHAR.NAK| |CHAR.DC4| |CHAR.DC3| |CHAR.DC2| |CHAR.DC1| |CHAR.DLE| |CHAR.SI| |CHAR.SO| |CHAR.CR| |CHAR.NP| |CHAR.VT| |CHAR.NL| |CHAR.HT| |CHAR.BS| |CHAR.BEL| |CHAR.ACK| |CHAR.ENQ| |CHAR.EOT| |CHAR.ETX| |CHAR.STX| |CHAR.SOH| |CHAR.NUL|)
(EQ (SUBTYPE |NULL.TYPECODE| |TEXT.TYPECODE|) |@true|)
(FORALL (|q$$27|) (PATS (|Is$TEXT| |q$$27|)) (IMPLIES (EQ (|Is$TEXT| |q$$27|) |@true|) (EQ (SUBTYPE (TYPECODE |q$$27|) |TEXT.TYPECODE|) |@true|)))
(FORALL (|q$$26|) (PATS (SUBTYPE (TYPECODE |q$$26|) |TEXT.TYPECODE|)) (IMPLIES (EQ (SUBTYPE (TYPECODE |q$$26|) |TEXT.TYPECODE|) |@true|) (EQ (|Is$TEXT| |q$$26|) |@true|)))
(FORALL (|q$4|) (PATS (|Is$TEXT| |q$4|)) (IMPLIES (EQ (|Is$TEXT| |q$4|) |@true|) (EQ (|Is$REFANY| |q$4|) |@true|)))
(FORALL (|q$$25|) (PATS (|Is$CARDINAL| |q$$25|)) (IMPLIES (EQ (|Is$CARDINAL| |q$$25|) |@true|) (AND (<= 0 |q$$25|) (<= |q$$25| |INTEGER.LAST|) (EQ (|Is$INTEGER| |q$$25|) |@true|))))
(FORALL (|q$$24|) (PATS (|Is$MATHINT| |q$$24|)) (IMPLIES (AND (<= 0 |q$$24|) (<= |q$$24| |INTEGER.LAST|) (EQ (|Is$MATHINT| |q$$24|) |@true|)) (EQ (|Is$CARDINAL| |q$$24|) |@true|)))
(FORALL (|q$$23|) (PATS (|Is$CARDINAL| |q$$23|)) (IMPLIES (EQ (|Is$CARDINAL| |q$$23|) |@true|) (EQ (|Is$ORDINAL| |q$$23|) |@true|)))
(EQ (SUBTYPE |NULL.TYPECODE| |MUTEX.TYPECODE|) |@true|)
(FORALL (|q$$22|) (PATS (|Is$MUTEX| |q$$22|)) (IMPLIES (EQ (|Is$MUTEX| |q$$22|) |@true|) (EQ (SUBTYPE (TYPECODE |q$$22|) |MUTEX.TYPECODE|) |@true|)))
(FORALL (|q$$21|) (PATS (SUBTYPE (TYPECODE |q$$21|) |MUTEX.TYPECODE|)) (IMPLIES (EQ (SUBTYPE (TYPECODE |q$$21|) |MUTEX.TYPECODE|) |@true|) (EQ (|Is$MUTEX| |q$$21|) |@true|)))
(FORALL (|q$3|) (PATS (|Is$MUTEX| |q$3|)) (IMPLIES (EQ (|Is$MUTEX| |q$3|) |@true|) (EQ (|Is$ROOT| |q$3|) |@true|)))
(EQ (SUBTYPE |NULL.TYPECODE| |REFANY.TYPECODE|) |@true|)
(FORALL (|q$$20|) (PATS (|Is$REFANY| |q$$20|)) (IMPLIES (EQ (|Is$REFANY| |q$$20|) |@true|) (EQ (SUBTYPE (TYPECODE |q$$20|) |REFANY.TYPECODE|) |@true|)))
(FORALL (|q$$19|) (PATS (SUBTYPE (TYPECODE |q$$19|) |REFANY.TYPECODE|)) (IMPLIES (EQ (SUBTYPE (TYPECODE |q$$19|) |REFANY.TYPECODE|) |@true|) (EQ (|Is$REFANY| |q$$19|) |@true|)))
(FORALL (|RESIDUE.IntSeq.Data'$| |RESIDUE.IntSeq.Data$| |IntSeqRep.Public.st'$$1| |IntSeqRep.Public.st$$1| |IntSeqRep.Public.sz'$$1| |IntSeqRep.Public.sz$$1| |IntSeqRep.Public.elem'$$1| |IntSeqRep.Public.elem$$1| |IntSeqRep.RefArray'$$1| |IntSeqRep.RefArray$$1| |i$2|) (PATS (MPAT (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray$$1| |IntSeqRep.Public.elem$$1| |IntSeqRep.Public.sz$$1| |IntSeqRep.Public.st$$1| |RESIDUE.IntSeq.Data$|) |i$2|) (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray'$$1| |IntSeqRep.Public.elem'$$1| |IntSeqRep.Public.sz'$$1| |IntSeqRep.Public.st'$$1| |RESIDUE.IntSeq.Data'$|) |i$2|))) (IMPLIES (AND (EQ (|Is$IntSeq.T| |i$2|) |@true|) (EQ (select |RESIDUE.IntSeq.Data$| |i$2|) (select |RESIDUE.IntSeq.Data'$| |i$2|)) (EQ (select |IntSeqRep.Public.st$$1| |i$2|) (select |IntSeqRep.Public.st'$$1| |i$2|)) (EQ (select |IntSeqRep.Public.sz$$1| |i$2|) (select |IntSeqRep.Public.sz'$$1| |i$2|)) (EQ (select |IntSeqRep.Public.elem$$1| |i$2|) (select |IntSeqRep.Public.elem'$$1| |i$2|)) (EQ (NUMBER (select |IntSeqRep.Public.elem$$1| |i$2|) 0) (NUMBER (select |IntSeqRep.Public.elem'$$1| |i$2|) 0)) (FORALL (|s0$$1|) (IMPLIES (AND (EQ (|Is$MATHINT| |s0$$1|) |@true|) (<= 0 |s0$$1|) (< |s0$$1| (NUMBER (select |IntSeqRep.Public.elem$$1| |i$2|) 0))) (EQ (select (select |IntSeqRep.RefArray$$1| (select |IntSeqRep.Public.elem$$1| |i$2|)) |s0$$1|) (select (select |IntSeqRep.RefArray'$$1| (select |IntSeqRep.Public.elem'$$1| |i$2|)) |s0$$1|))))) (EQ (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray$$1| |IntSeqRep.Public.elem$$1| |IntSeqRep.Public.sz$$1| |IntSeqRep.Public.st$$1| |RESIDUE.IntSeq.Data$|) |i$2|) (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray'$$1| |IntSeqRep.Public.elem'$$1| |IntSeqRep.Public.sz'$$1| |IntSeqRep.Public.st'$$1| |RESIDUE.IntSeq.Data'$|) |i$2|))))
(FORALL (|RESIDUE.Text.value'$| |RESIDUE.Text.value$| |i$1|) (PATS (MPAT (select (|FUNC.Text.value| |RESIDUE.Text.value$|) |i$1|) (select (|FUNC.Text.value| |RESIDUE.Text.value'$|) |i$1|))) (IMPLIES (AND (EQ (|Is$TEXT| |i$1|) |@true|) (EQ (select |RESIDUE.Text.value$| |i$1|) (select |RESIDUE.Text.value'$| |i$1|))) (EQ (select (|FUNC.Text.value| |RESIDUE.Text.value$|) |i$1|) (select (|FUNC.Text.value| |RESIDUE.Text.value'$|) |i$1|))))
(FORALL (|RESIDUE.IntSeq.Valid'$| |RESIDUE.IntSeq.Valid$| |IntSeqRep.Public.st'$| |IntSeqRep.Public.st$| |IntSeqRep.Public.sz'$| |IntSeqRep.Public.sz$| |IntSeqRep.Public.elem'$| |IntSeqRep.Public.elem$| |IntSeqRep.RefArray'$| |IntSeqRep.RefArray$| i) (PATS (MPAT (select (|FUNC.IntSeq.Valid| |IntSeqRep.RefArray$| |IntSeqRep.Public.elem$| |IntSeqRep.Public.sz$| |IntSeqRep.Public.st$| |RESIDUE.IntSeq.Valid$|) i) (select (|FUNC.IntSeq.Valid| |IntSeqRep.RefArray'$| |IntSeqRep.Public.elem'$| |IntSeqRep.Public.sz'$| |IntSeqRep.Public.st'$| |RESIDUE.IntSeq.Valid'$|) i))) (IMPLIES (AND (EQ (|Is$IntSeq.T| i) |@true|) (EQ (select |RESIDUE.IntSeq.Valid$| i) (select |RESIDUE.IntSeq.Valid'$| i)) (EQ (select |IntSeqRep.Public.st$| i) (select |IntSeqRep.Public.st'$| i)) (EQ (select |IntSeqRep.Public.sz$| i) (select |IntSeqRep.Public.sz'$| i)) (EQ (select |IntSeqRep.Public.elem$| i) (select |IntSeqRep.Public.elem'$| i)) (EQ (NUMBER (select |IntSeqRep.Public.elem$| i) 0) (NUMBER (select |IntSeqRep.Public.elem'$| i) 0)) (FORALL (|s0$|) (IMPLIES (AND (EQ (|Is$MATHINT| |s0$|) |@true|) (<= 0 |s0$|) (< |s0$| (NUMBER (select |IntSeqRep.Public.elem$| i) 0))) (EQ (select (select |IntSeqRep.RefArray$| (select |IntSeqRep.Public.elem$| i)) |s0$|) (select (select |IntSeqRep.RefArray'$| (select |IntSeqRep.Public.elem'$| i)) |s0$|))))) (EQ (select (|FUNC.IntSeq.Valid| |IntSeqRep.RefArray$| |IntSeqRep.Public.elem$| |IntSeqRep.Public.sz$| |IntSeqRep.Public.st$| |RESIDUE.IntSeq.Valid$|) i) (select (|FUNC.IntSeq.Valid| |IntSeqRep.RefArray'$| |IntSeqRep.Public.elem'$| |IntSeqRep.Public.sz'$| |IntSeqRep.Public.st'$| |RESIDUE.IntSeq.Valid'$|) i))))
(FORALL (|IntSeqRep.RefArray$1| |IntSeqRep.Public.elem$1| |IntSeqRep.Public.sz$1| |IntSeqRep.Public.st$1| |RESIDUE.IntSeq.Data| t) (PATS (MPAT (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray$1| |IntSeqRep.Public.elem$1| |IntSeqRep.Public.sz$1| |IntSeqRep.Public.st$1| |RESIDUE.IntSeq.Data|) t))) (IMPLIES (EQ (|Is$IntSeq.T| t) |@true|) (EQ (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray$1| |IntSeqRep.Public.elem$1| |IntSeqRep.Public.sz$1| |IntSeqRep.Public.st$1| |RESIDUE.IntSeq.Data|) t) (|IntSeqRep.Abs| (select |IntSeqRep.RefArray$1| (select |IntSeqRep.Public.elem$1| t)) (select |IntSeqRep.Public.st$1| t) (select |IntSeqRep.Public.sz$1| t)))))
(EQ |Word.Size| 32)
(NOT (EQ |Word.Plus| |$NIL|))
(NOT (EQ |Word.Times| |$NIL|))
(NOT (EQ |Word.Minus| |$NIL|))
(NOT (EQ |Word.Divide| |$NIL|))
(NOT (EQ |Word.Mod| |$NIL|))
(NOT (EQ |Word.LT| |$NIL|))
(NOT (EQ |Word.LE| |$NIL|))
(NOT (EQ |Word.GT| |$NIL|))
(NOT (EQ |Word.GE| |$NIL|))
(NOT (EQ |Word.And| |$NIL|))
(NOT (EQ |Word.Or| |$NIL|))
(NOT (EQ |Word.Xor| |$NIL|))
(NOT (EQ |Word.Not| |$NIL|))
(NOT (EQ |Word.Shift| |$NIL|))
(NOT (EQ |Word.LeftShift| |$NIL|))
(FORALL (|q$$18|) (PATS (|Is$TYPE@41| |q$$18|)) (IMPLIES (EQ (|Is$TYPE@41| |q$$18|) |@true|) (AND (<= 0 |q$$18|) (<= |q$$18| 31) (EQ (|Is$INTEGER| |q$$18|) |@true|))))
(FORALL (|q$$17|) (PATS (|Is$MATHINT| |q$$17|)) (IMPLIES (AND (<= 0 |q$$17|) (<= |q$$17| 31) (EQ (|Is$MATHINT| |q$$17|) |@true|)) (EQ (|Is$TYPE@41| |q$$17|) |@true|)))
(FORALL (|q$$16|) (PATS (|Is$TYPE@41| |q$$16|)) (IMPLIES (EQ (|Is$TYPE@41| |q$$16|) |@true|) (EQ (|Is$ORDINAL| |q$$16|) |@true|)))
(EQ (|Is$INTEGER| 0) |@true|)
(EQ (|Is$INTEGER| 1) |@true|)
(NOT (EQ |Word.RightShift| |$NIL|))
(NOT (EQ |Word.Rotate| |$NIL|))
(NOT (EQ |Word.LeftRotate| |$NIL|))
(NOT (EQ |Word.RightRotate| |$NIL|))
(NOT (EQ |Word.Extract| |$NIL|))
(NOT (EQ |Word.Insert| |$NIL|))
(NEQ |Integer.Brand| |$NIL|)
(EQ (|Is$TEXT| |Integer.Brand|) |@true|)
(EQ (|Is$DCL| |Integer.Brand| ALLOCATED) |@true|)
(EQ (NUMBER (ADDR (select (|FUNC.Text.value| |RESIDUE.Text.value|) |Integer.Brand|)) 0) 7)
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |Integer.Brand|) 0) (VAL 73 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |Integer.Brand|) 1) (VAL 110 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |Integer.Brand|) 2) (VAL 116 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |Integer.Brand|) 3) (VAL 101 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |Integer.Brand|) 4) (VAL 103 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |Integer.Brand|) 5) (VAL 101 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |Integer.Brand|) 6) (VAL 114 |CHAR.TYPECODE|))
(NOT (EQ |Integer.Equal| |$NIL|))
(NOT (EQ |Integer.Hash| |$NIL|))
(NOT (EQ |Integer.Compare| |$NIL|))
(FORALL (|q$$15|) (PATS (|Is$TYPE@42| |q$$15|)) (IMPLIES (EQ (|Is$TYPE@42| |q$$15|) |@true|) (AND (<= -1 |q$$15|) (<= |q$$15| 1) (EQ (|Is$INTEGER| |q$$15|) |@true|))))
(FORALL (|q$$14|) (PATS (|Is$MATHINT| |q$$14|)) (IMPLIES (AND (<= -1 |q$$14|) (<= |q$$14| 1) (EQ (|Is$MATHINT| |q$$14|) |@true|)) (EQ (|Is$TYPE@42| |q$$14|) |@true|)))
(FORALL (|q$$13|) (PATS (|Is$TYPE@42| |q$$13|)) (IMPLIES (EQ (|Is$TYPE@42| |q$$13|) |@true|) (EQ (|Is$ORDINAL| |q$$13|) |@true|)))
(NEQ |IntSeq.Brand| |$NIL|)
(EQ (|Is$TEXT| |IntSeq.Brand|) |@true|)
(EQ (|Is$DCL| |IntSeq.Brand| ALLOCATED) |@true|)
(EQ (NUMBER (ADDR (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|)) 0) 18)
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 0) (VAL 40 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 1) (VAL 83 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 2) (VAL 101 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 3) (VAL 113 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 4) (VAL 117 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 5) (VAL 101 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 6) (VAL 110 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 7) (VAL 99 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 8) (VAL 101 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 9) (VAL 32 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 10) (VAL 73 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 11) (VAL 110 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 12) (VAL 116 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 13) (VAL 101 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 14) (VAL 103 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 15) (VAL 101 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 16) (VAL 114 |CHAR.TYPECODE|))
(EQ (select (select (|FUNC.Text.value| |RESIDUE.Text.value|) |IntSeq.Brand|) 17) (VAL 41 |CHAR.TYPECODE|))
(EQ (SUBTYPE |IntSeq.T.TYPECODE| |IntSeq.Public.TYPECODE|) |@true|)
(EQ (SUBTYPE |NULL.TYPECODE| |IntSeq.T.TYPECODE|) |@true|)
(FORALL (|q$$12|) (PATS (|Is$IntSeq.T| |q$$12|)) (IMPLIES (EQ (|Is$IntSeq.T| |q$$12|) |@true|) (EQ (SUBTYPE (TYPECODE |q$$12|) |IntSeq.T.TYPECODE|) |@true|)))
(FORALL (|q$$11|) (PATS (SUBTYPE (TYPECODE |q$$11|) |IntSeq.T.TYPECODE|)) (IMPLIES (EQ (SUBTYPE (TYPECODE |q$$11|) |IntSeq.T.TYPECODE|) |@true|) (EQ (|Is$IntSeq.T| |q$$11|) |@true|)))
(EQ (SUBTYPE1 |IntSeq.T.TYPECODE| |IntSeqRep.Public.TYPECODE|) |@true|)
(FORALL (|q$2|) (PATS (|Is$IntSeq.T| |q$2|)) (IMPLIES (EQ (|Is$IntSeq.T| |q$2|) |@true|) (EQ (|Is$IntSeqRep.Public| |q$2|) |@true|)))
(EQ (SUBTYPE |NULL.TYPECODE| |IntSeq.Public.TYPECODE|) |@true|)
(FORALL (|q$$10|) (PATS (|Is$IntSeq.Public| |q$$10|)) (IMPLIES (EQ (|Is$IntSeq.Public| |q$$10|) |@true|) (EQ (SUBTYPE (TYPECODE |q$$10|) |IntSeq.Public.TYPECODE|) |@true|)))
(FORALL (|q$$9|) (PATS (SUBTYPE (TYPECODE |q$$9|) |IntSeq.Public.TYPECODE|)) (IMPLIES (EQ (SUBTYPE (TYPECODE |q$$9|) |IntSeq.Public.TYPECODE|) |@true|) (EQ (|Is$IntSeq.Public| |q$$9|) |@true|)))
(EQ (SUBTYPE1 |IntSeq.Public.TYPECODE| |ROOT.TYPECODE|) |@true|)
(FORALL (|q$1|) (PATS (|Is$IntSeq.Public| |q$1|)) (IMPLIES (EQ (|Is$IntSeq.Public| |q$1|) |@true|) (EQ (|Is$ROOT| |q$1|) |@true|)))
(EQ (|Is$INTEGER| 5) |@true|)
(FORALL (|q$$8|) (IMPLIES (EQ (|Is$IntSeqRep.EArr| |q$$8|) |@true|) (FORALL (|i$|) (EQ (|Is$INTEGER| (select |q$$8| |i$|)) |@true|))))
(FORALL (|map$$2| |start$$1| |num$$1|) (PATS (|Is$IntSeqRep.EArr| (SUBARRAY |map$$2| |start$$1| |num$$1|))) (IMPLIES (EQ (|Is$IntSeqRep.EArr| |map$$2|) |@true|) (EQ (|Is$IntSeqRep.EArr| (SUBARRAY |map$$2| |start$$1| |num$$1|)) |@true|)))
(FORALL (|map$$1|) (PATS (|Is$IntSeqRep.EArr| |map$$1|)) (IMPLIES (EQ (|Is$IntSeqRep.EArr| |map$$1|) |@true|) (FORALL (|start$| |num$| |map2$|) (PATS (storeSub |map$$1| |start$| |num$| |map2$|)) (IMPLIES (EQ (|Is$IntSeqRep.EArr| |map2$|) |@true|) (EQ (|Is$IntSeqRep.EArr| (storeSub |map$$1| |start$| |num$| |map2$|)) |@true|)))))
(FORALL (|map$|) (PATS (|Is$IntSeqRep.EArr| |map$|)) (IMPLIES (EQ (|Is$IntSeqRep.EArr| |map$|) |@true|) (FORALL (|ind$| |val$|) (PATS (store |map$| |ind$| |val$|)) (IMPLIES (EQ (|Is$INTEGER| |val$|) |@true|) (EQ (|Is$IntSeqRep.EArr| (store |map$| |ind$| |val$|)) |@true|)))))
(NOT (EQ |IntSeq.Cat$1| |$NIL|))
(NOT (EQ |IntSeq.Sub$1| |$NIL|))
(EQ (SUBTYPE |IntSeq.T.TYPECODE| |IntSeqRep.Public.TYPECODE|) |@true|)
(EQ (SUBTYPE |NULL.TYPECODE| |IntSeqRep.RefArray.TYPECODE|) |@true|)
(FORALL (|q$$7|) (PATS (|Is$IntSeqRep.RefArray| |q$$7|)) (IMPLIES (EQ (|Is$IntSeqRep.RefArray| |q$$7|) |@true|) (EQ (SUBTYPE (TYPECODE |q$$7|) |IntSeqRep.RefArray.TYPECODE|) |@true|)))
(FORALL (|q$$6|) (PATS (SUBTYPE (TYPECODE |q$$6|) |IntSeqRep.RefArray.TYPECODE|)) (IMPLIES (EQ (SUBTYPE (TYPECODE |q$$6|) |IntSeqRep.RefArray.TYPECODE|) |@true|) (EQ (|Is$IntSeqRep.RefArray| |q$$6|) |@true|)))
(FORALL (|q$$5|) (PATS (|Is$IntSeqRep.RefArray| |q$$5|)) (IMPLIES (EQ (|Is$IntSeqRep.RefArray| |q$$5|) |@true|) (OR (EQ |q$$5| |$NIL|) (EQ (TYPECODE |q$$5|) |IntSeqRep.RefArray.TYPECODE|))))
(EQ (SUBTYPE1 |IntSeqRep.RefArray.TYPECODE| |REFANY.TYPECODE|) |@true|)
(FORALL (|rm$|) (PATS (|Is$IntSeqRep.RefArray$IntSeqRep.EArr$MAP| |rm$|)) (IMPLIES (EQ (|Is$IntSeqRep.RefArray$IntSeqRep.EArr$MAP| |rm$|) |@true|) (FORALL (|q$$4|) (PATS (select |rm$| |q$$4|)) (EQ (|Is$IntSeqRep.EArr| (select |rm$| |q$$4|)) |@true|))))
(EQ (|Is$IntSeqRep.RefArray$IntSeqRep.EArr$MAP| |IntSeqRep.RefArray|) |@true|)
(EQ (|Is$DCLOSED| |IntSeqRep.RefArray| ALLOCATED) |@true|)
(EQ (|Is$VCONSISTENT| |IntSeqRep.RefArray| ALLOCATED VIRGIN) |@true|)
(EQ (CONCVARSYM |IntSeqRep.RefArray|) |@true|)
(EQ (SUBTYPE |NULL.TYPECODE| |IntSeqRep.Public.TYPECODE|) |@true|)
(FORALL (|q$$3|) (PATS (|Is$IntSeqRep.Public| |q$$3|)) (IMPLIES (EQ (|Is$IntSeqRep.Public| |q$$3|) |@true|) (EQ (SUBTYPE (TYPECODE |q$$3|) |IntSeqRep.Public.TYPECODE|) |@true|)))
(FORALL (|q$$2|) (PATS (SUBTYPE (TYPECODE |q$$2|) |IntSeqRep.Public.TYPECODE|)) (IMPLIES (EQ (SUBTYPE (TYPECODE |q$$2|) |IntSeqRep.Public.TYPECODE|) |@true|) (EQ (|Is$IntSeqRep.Public| |q$$2|) |@true|)))
(FORALL (|ofm$$1|) (PATS (|Is$IntSeqRep.Public$IntSeqRep.RefArray$MAP| |ofm$$1|)) (IMPLIES (EQ (|Is$IntSeqRep.Public$IntSeqRep.RefArray$MAP| |ofm$$1|) |@true|) (FORALL (|q$|) (PATS (select |ofm$$1| |q$|)) (EQ (|Is$IntSeqRep.RefArray| (select |ofm$$1| |q$|)) |@true|))))
(FORALL (|m$| |q$$1|) (PATS (MPAT (|Is$IntSeqRep.Public| |q$$1|) (|Is$IntSeqRep.Public$IntSeqRep.RefArray$MAP| |m$|))) (IMPLIES (AND (EQ (|Is$IntSeqRep.Public$IntSeqRep.RefArray$MAP| |m$|) |@true|) (EQ (|Is$IntSeqRep.Public| |q$$1|) |@true|)) (AND (FORALL (|al$|) (PATS (MPAT (|Is$DCL| |q$$1| |al$|) (|Is$DCLOSED| |m$| |al$|) (select |m$| |q$$1|))) (IMPLIES (AND (EQ (|Is$DCL| |q$$1| |al$|) |@true|) (EQ (|Is$DCLOSED| |m$| |al$|) |@true|) (NEQ |q$$1| |$NIL|)) (EQ (|Is$DCL| (select |m$| |q$$1|) |al$|) |@true|))) (FORALL (|v$| |al$|) (PATS (MPAT (|Is$DCL| |q$$1| |al$|) (|Is$VCONSISTENT| |m$| |al$| |v$|) (select |m$| |q$$1|))) (IMPLIES (AND (EQ (|Is$DCL| |q$$1| |al$|) |@true|) (EQ (|Is$VCONSISTENT| |m$| |al$| |v$|) |@true|) (NEQ |q$$1| |$NIL|)) (EQ (|Is$NVIRG| (select |m$| |q$$1|) |v$|) |@true|))))))
(EQ (|Is$IntSeqRep.Public$IntSeqRep.RefArray$MAP| |IntSeqRep.Public.elem|) |@true|)
(EQ (|Is$DCLOSED| |IntSeqRep.Public.elem| ALLOCATED) |@true|)
(EQ (|Is$VCONSISTENT| |IntSeqRep.Public.elem| ALLOCATED VIRGIN) |@true|)
(EQ (CONCVARSYM |IntSeqRep.Public.elem|) |@true|)
(FORALL (|ofm$|) (PATS (|Is$IntSeqRep.Public$CARDINAL$MAP| |ofm$|)) (IMPLIES (EQ (|Is$IntSeqRep.Public$CARDINAL$MAP| |ofm$|) |@true|) (FORALL (|q$|) (PATS (select |ofm$| |q$|)) (EQ (|Is$CARDINAL| (select |ofm$| |q$|)) |@true|))))
(EQ (|Is$IntSeqRep.Public$CARDINAL$MAP| |IntSeqRep.Public.st|) |@true|)
(EQ (|Is$DCLOSED| |IntSeqRep.Public.st| ALLOCATED) |@true|)
(EQ (|Is$VCONSISTENT| |IntSeqRep.Public.st| ALLOCATED VIRGIN) |@true|)
(EQ (CONCVARSYM |IntSeqRep.Public.st|) |@true|)
(EQ (|Is$IntSeqRep.Public$CARDINAL$MAP| |IntSeqRep.Public.sz|) |@true|)
(EQ (|Is$DCLOSED| |IntSeqRep.Public.sz| ALLOCATED) |@true|)
(EQ (|Is$VCONSISTENT| |IntSeqRep.Public.sz| ALLOCATED VIRGIN) |@true|)
(EQ (CONCVARSYM |IntSeqRep.Public.sz|) |@true|)
(EQ (SUBTYPE1 |IntSeqRep.Public.TYPECODE| |IntSeq.Public.TYPECODE|) |@true|)
(FORALL (q) (PATS (|Is$IntSeqRep.Public| q)) (IMPLIES (EQ (|Is$IntSeqRep.Public| q) |@true|) (EQ (|Is$IntSeq.Public| q) |@true|)))
(FORALL (|s$$2|) (PATS (select |IntSeqRep.Public.elem| |s$$2|)) (IMPLIES (NOT (EQ (select ALLOCATED |s$$2|) |@true|)) (EQ (select |IntSeqRep.Public.elem| |s$$2|) |$NIL|)))
(FORALL (|s$$1|) (PATS (select |IntSeqRep.Public.st| |s$$1|)) (IMPLIES (NOT (EQ (select ALLOCATED |s$$1|) |@true|)) (EQ (select |IntSeqRep.Public.st| |s$$1|) 0)))
(FORALL (|s$|) (PATS (select |IntSeqRep.Public.sz| |s$|)) (IMPLIES (NOT (EQ (select ALLOCATED |s$|) |@true|)) (EQ (select |IntSeqRep.Public.sz| |s$|) 0)))
(EQ (|Is$INTEGER| |IntSeq.zero|) |@true|)
(NOT (EQ |IntSeq.Init| |$NIL|))
(NOT (EQ |IntSeq.FromArray| |$NIL|))
(NOT (EQ |IntSeq.Addhi| |$NIL|))
(NOT (EQ |IntSeq.Addlo| |$NIL|))
(NOT (EQ |IntSeq.Expand| |$NIL|))
(EQ (|Is$INTEGER| 2) |@true|)
(NOT (EQ |IntSeq.Remhi| |$NIL|))
(NOT (EQ |IntSeq.Remlo| |$NIL|))
(NOT (EQ |IntSeq.Put| |$NIL|))
(NOT (EQ |IntSeq.Get| |$NIL|))
(NOT (EQ |IntSeq.Size| |$NIL|))
(NOT (EQ |IntSeq.Gethi| |$NIL|))
(NOT (EQ |IntSeq.Getlo| |$NIL|))
(NOT (EQ |IntSeq.Cat| |$NIL|))
(NOT (EQ |IntSeq.Sub| |$NIL|))
)
)


(BG_PUSH
TRUE
)

(IMPLIES (AND (EQ (select (|FUNC.IntSeq.Valid| |IntSeqRep.RefArray| |IntSeqRep.Public.elem| |IntSeqRep.Public.sz| |IntSeqRep.Public.st| |RESIDUE.IntSeq.Valid|) s) |@true|) (FORALL (|t1$| |t2$|) (NOPATS (|Is$IntSeq.T| |t1$|) (|Is$DCL| |t1$| ALLOCATED) (|Is$IntSeq.T| |t2$|) (|Is$DCL| |t2$| ALLOCATED)) (IMPLIES (AND (EQ (|Is$IntSeq.T| |t2$|) |@true|) (EQ (|Is$DCL| |t2$| ALLOCATED) |@true|) (EQ (|Is$IntSeq.T| |t1$|) |@true|) (EQ (|Is$DCL| |t1$| ALLOCATED) |@true|)) (IMPLIES (AND (NEQ |t1$| |$NIL|) (NEQ |t2$| |$NIL|) (NEQ |t1$| |t2$|) (NEQ (select |IntSeqRep.Public.elem| |t1$|) |$NIL|) (NEQ (select |IntSeqRep.Public.elem| |t2$|) |$NIL|)) (NEQ (select |IntSeqRep.Public.elem| |t1$|) (select |IntSeqRep.Public.elem| |t2$|)))))) (FORALL (|RESIDUE.IntSeq.Valid`| |IntSeqRep.Public.st`| |IntSeqRep.RefArray`| |IntSeqRep.Public.elem`| |IntSeqRep.Public.sz`| |RESIDUE.IntSeq.Data`| |x`| |s`| |ALLOCATED`| |LL`| |VIRGIN`|) (IMPLIES (AND (EQ (|Is$IntSeq.T| s) |@true|) (EQ (|Is$DCL| s ALLOCATED) |@true|) (EQ (|Is$INTEGER| x) |@true|)) (FORALL (res) (FORALL (|res$2| |res$1|) (AND (LBL |ERROR.deref.81.8| (NEQ s |$NIL|)) (FORALL (|res$3|) (FORALL (|res$4|) (AND (LBL |ERROR.deref.81.22| (NEQ s |$NIL|)) (LBL |ERROR.deref.81.27| (NEQ (select |IntSeqRep.Public.elem| s) |$NIL|)) (IMPLIES (EQ (select |IntSeqRep.Public.sz| s) (NUMBER (ADDR (select |IntSeqRep.RefArray| (select |IntSeqRep.Public.elem| s))) 0)) (AND (LBL |ERROR.deref.81.35| (NOT (EQ |IntSeq.Expand| |$NIL|))) (FORALL (|EXCEPTION.code$1| |s$5| |ALLOCATED$5| |ALLOCATED'$1| |IntSeqRep.Public.st$6| |IntSeqRep.Public.st'$1| |IntSeqRep.RefArray$6| |IntSeqRep.RefArray'$1| |IntSeqRep.Public.elem$6| |IntSeqRep.Public.elem'$1|) (AND (LBL |ERROR.pre.81.35| (EQ (select (|FUNC.IntSeq.Valid| |IntSeqRep.RefArray| |IntSeqRep.Public.elem| |IntSeqRep.Public.sz| |IntSeqRep.Public.st| |RESIDUE.IntSeq.Valid|) s) |@true|)) (LBL |ERROR.inv.81.35| (FORALL (|t1$| |t2$|) (NOPATS (|Is$IntSeq.T| |t1$|) (|Is$DCL| |t1$| ALLOCATED) (|Is$IntSeq.T| |t2$|) (|Is$DCL| |t2$| ALLOCATED)) (IMPLIES (AND (EQ (|Is$IntSeq.T| |t2$|) |@true|) (EQ (|Is$DCL| |t2$| ALLOCATED) |@true|) (EQ (|Is$IntSeq.T| |t1$|) |@true|) (EQ (|Is$DCL| |t1$| ALLOCATED) |@true|)) (IMPLIES (AND (NEQ |t1$| |$NIL|) (NEQ |t2$| |$NIL|) (NEQ |t1$| |t2$|) (NEQ (select |IntSeqRep.Public.elem| |t1$|) |$NIL|) (NEQ (select |IntSeqRep.Public.elem| |t2$|) |$NIL|)) (NEQ (select |IntSeqRep.Public.elem| |t1$|) (select |IntSeqRep.Public.elem| |t2$|)))))))))) (FORALL (|ALLOCATED$1| |IntSeqRep.Public.st$2| |IntSeqRep.RefArray$2| |IntSeqRep.Public.elem$2|) (IMPLIES (OR (EXISTS (|IntSeqRep.Public.elem'| |IntSeqRep.Public.elem$3| |IntSeqRep.RefArray'| |IntSeqRep.RefArray$3| |IntSeqRep.Public.st'| |IntSeqRep.Public.st$3| |ALLOCATED'| |ALLOCATED$2| |s$1| |EXCEPTION.code|) (EXISTS (|IntSeqRep.Public.elem$4|) (AND (EXISTS (|IntSeqRep.RefArray$4|) (AND (EXISTS (|IntSeqRep.Public.st$4|) (AND (EXISTS (|ALLOCATED$3|) (AND (EXISTS (|IntSeqRep.Public.elem$5|) (AND (EXISTS (|IntSeqRep.RefArray$5|) (AND (EXISTS (|IntSeqRep.Public.st$5|) (AND (EXISTS (|ALLOCATED$4|) (AND (EXISTS (|s$3|) (AND (EQ ALLOCATED |ALLOCATED$3|) (EQ |IntSeqRep.Public.st| |IntSeqRep.Public.st$4|) (EQ |IntSeqRep.RefArray| |IntSeqRep.RefArray$4|) (EQ |IntSeqRep.Public.elem| |IntSeqRep.Public.elem$4|) (EQ (select |IntSeqRep.Public.sz| s) (NUMBER (ADDR (select |IntSeqRep.RefArray| (select |IntSeqRep.Public.elem| s))) 0)) (NOT (EQ |IntSeq.Expand| |$NIL|)) (EQ |s$1| s))) (EQ |ALLOCATED$2| |ALLOCATED$3|))) (EQ |IntSeqRep.Public.st$3| |IntSeqRep.Public.st$4|))) (EQ |IntSeqRep.RefArray$3| |IntSeqRep.RefArray$4|))) (EQ |IntSeqRep.Public.elem$3| |IntSeqRep.Public.elem$4|))) (EQ (select (|FUNC.IntSeq.Valid| |IntSeqRep.RefArray$3| |IntSeqRep.Public.elem$3| |IntSeqRep.Public.sz| |IntSeqRep.Public.st$3| |RESIDUE.IntSeq.Valid|) |s$1|) |@true|) (FORALL (|t1$| |t2$|) (NOPATS (|Is$IntSeq.T| |t1$|) (|Is$DCL| |t1$| |ALLOCATED$2|) (|Is$IntSeq.T| |t2$|) (|Is$DCL| |t2$| |ALLOCATED$2|)) (IMPLIES (AND (EQ (|Is$IntSeq.T| |t2$|) |@true|) (EQ (|Is$DCL| |t2$| |ALLOCATED$2|) |@true|) (EQ (|Is$IntSeq.T| |t1$|) |@true|) (EQ (|Is$DCL| |t1$| |ALLOCATED$2|) |@true|)) (IMPLIES (AND (NEQ |t1$| |$NIL|) (NEQ |t2$| |$NIL|) (NEQ |t1$| |t2$|) (NEQ (select |IntSeqRep.Public.elem$3| |t1$|) |$NIL|) (NEQ (select |IntSeqRep.Public.elem$3| |t2$|) |$NIL|)) (NEQ (select |IntSeqRep.Public.elem$3| |t1$|) (select |IntSeqRep.Public.elem$3| |t2$|))))) (IMPLIES (EQ |EXCEPTION.code| RETURN) (AND (EQ (select |IntSeqRep.Public.st'| |s$1|) 0) (> (NUMBER (select |IntSeqRep.Public.elem'| |s$1|) 0) (NUMBER (select |IntSeqRep.Public.elem$3| |s$1|) 0)) (NOT (EQ (select |ALLOCATED$2| (select |IntSeqRep.Public.elem'| |s$1|)) |@true|)) (EQ (select |ALLOCATED'| (select |IntSeqRep.Public.elem'| |s$1|)) |@true|))) (EQ |EXCEPTION.code| RETURN) (FORALL (|s0$$4|) (PATS (select (|FUNC.IntSeq.Valid| |IntSeqRep.RefArray$3| |IntSeqRep.Public.elem$3| |IntSeqRep.Public.sz| |IntSeqRep.Public.st$3| |RESIDUE.IntSeq.Valid|) |s0$$4|) (select (|FUNC.IntSeq.Valid| |IntSeqRep.RefArray'| |IntSeqRep.Public.elem'| |IntSeqRep.Public.sz| |IntSeqRep.Public.st'| |RESIDUE.IntSeq.Valid|) |s0$$4|)) (IMPLIES (AND (EQ (|Is$IntSeq.T| |s0$$4|) |@true|) (EQ (|Is$DCL| |s0$$4| |ALLOCATED$2|) |@true|) (NEQ |s0$$4| |$NIL|)) (OR (EQ (select (|FUNC.IntSeq.Valid| |IntSeqRep.RefArray$3| |IntSeqRep.Public.elem$3| |IntSeqRep.Public.sz| |IntSeqRep.Public.st$3| |RESIDUE.IntSeq.Valid|) |s0$$4|) (select (|FUNC.IntSeq.Valid| |IntSeqRep.RefArray'| |IntSeqRep.Public.elem'| |IntSeqRep.Public.sz| |IntSeqRep.Public.st'| |RESIDUE.IntSeq.Valid|) |s0$$4|)) (EQ (select |IntSeqRep.Public.elem$3| |s0$$4|) (select |IntSeqRep.Public.elem'| |s$1|))))) (FORALL (|s0$$3| |s1$|) (PATS (select (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray$3| |IntSeqRep.Public.elem$3| |IntSeqRep.Public.sz| |IntSeqRep.Public.st$3| |RESIDUE.IntSeq.Data$1|) |s0$$3|) |s1$|) (select (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray'| |IntSeqRep.Public.elem'| |IntSeqRep.Public.sz| |IntSeqRep.Public.st'| |RESIDUE.IntSeq.Data$1|) |s0$$3|) |s1$|)) (IMPLIES (AND (EQ (|Is$IntSeq.T| |s0$$3|) |@true|) (EQ (|Is$DCL| |s0$$3| |ALLOCATED$2|) |@true|) (NEQ |s0$$3| |$NIL|) (EQ (|Is$MATHINT| |s1$|) |@true|) (<= 0 |s1$|) (< |s1$| (NUMBER (ADDR (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray$3| |IntSeqRep.Public.elem$3| |IntSeqRep.Public.sz| |IntSeqRep.Public.st$3| |RESIDUE.IntSeq.Data$1|) |s0$$3|)) 0))) (OR (EQ (select (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray$3| |IntSeqRep.Public.elem$3| |IntSeqRep.Public.sz| |IntSeqRep.Public.st$3| |RESIDUE.IntSeq.Data$1|) |s0$$3|) |s1$|) (select (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray'| |IntSeqRep.Public.elem'| |IntSeqRep.Public.sz| |IntSeqRep.Public.st'| |RESIDUE.IntSeq.Data$1|) |s0$$3|) |s1$|)) (EQ (select |IntSeqRep.Public.elem$3| |s0$$3|) (select |IntSeqRep.Public.elem'| |s$1|))))) (FORALL (|s0$$2|) (PATS (select |IntSeqRep.Public.elem$3| |s0$$2|) (select |IntSeqRep.Public.elem'| |s0$$2|)) (IMPLIES (AND (EQ (|Is$IntSeqRep.Public| |s0$$2|) |@true|) (EQ (|Is$DCL| |s0$$2| |ALLOCATED$2|) |@true|) (NEQ |s0$$2| |$NIL|)) (OR (EQ (select |IntSeqRep.Public.elem$3| |s0$$2|) (select |IntSeqRep.Public.elem'| |s0$$2|)) (EQ |s0$$2| |s$1|)))) (EQ (select |IntSeqRep.Public.elem'| |$NIL|) (select |IntSeqRep.Public.elem$3| |$NIL|)) (FORALL (|s$2|) (PATS (select |IntSeqRep.Public.elem'| |s$2|) (select |IntSeqRep.Public.elem$3| |s$2|)) (IMPLIES (AND (EQ (|Is$IntSeqRep.Public| |s$2|) |@true|) (EQ (|Is$DCL| |s$2| |ALLOCATED$2|) |@true|)) (OR (EQ (select |IntSeqRep.Public.elem'| |s$2|) (select |IntSeqRep.Public.elem$3| |s$2|)) (EQ (select |IntSeqRep.Public.elem'| |s$2|) |$NIL|) (AND (NOT (EQ (|Is$DCL| (select |IntSeqRep.Public.elem'| |s$2|) |ALLOCATED$2|) |@true|)) (EQ (|Is$DCL| (select |IntSeqRep.Public.elem'| |s$2|) |ALLOCATED'|) |@true|))))) (EQ |IntSeqRep.RefArray'| (store |IntSeqRep.RefArray$3| (select |IntSeqRep.Public.elem'| |s$1|) (select |IntSeqRep.RefArray'| (select |IntSeqRep.Public.elem'| |s$1|)))) (EQ (select |IntSeqRep.RefArray'| |$NIL|) (select |IntSeqRep.RefArray$3| |$NIL|)) (EQ |IntSeqRep.Public.st'| (store |IntSeqRep.Public.st$3| |s$1| (select |IntSeqRep.Public.st'| |s$1|))) (EQ (select |IntSeqRep.Public.st'| |$NIL|) (select |IntSeqRep.Public.st$3| |$NIL|)) (FORALL (|t1$| |t2$|) (NOPATS (|Is$IntSeq.T| |t1$|) (|Is$DCL| |t1$| |ALLOCATED'|) (|Is$IntSeq.T| |t2$|) (|Is$DCL| |t2$| |ALLOCATED'|)) (IMPLIES (AND (EQ (|Is$IntSeq.T| |t2$|) |@true|) (EQ (|Is$DCL| |t2$| |ALLOCATED'|) |@true|) (EQ (|Is$IntSeq.T| |t1$|) |@true|) (EQ (|Is$DCL| |t1$| |ALLOCATED'|) |@true|)) (IMPLIES (AND (NEQ |t1$| |$NIL|) (NEQ |t2$| |$NIL|) (NEQ |t1$| |t2$|) (NEQ (select |IntSeqRep.Public.elem'| |t1$|) |$NIL|) (NEQ (select |IntSeqRep.Public.elem'| |t2$|) |$NIL|)) (NEQ (select |IntSeqRep.Public.elem'| |t1$|) (select |IntSeqRep.Public.elem'| |t2$|))))) (EQ (SUCCEEDS |ALLOCATED'| VIRGIN |ALLOCATED$2| VIRGIN) |@true|) (EQ (|Is$IntSeqRep.Public$CARDINAL$MAP| |IntSeqRep.Public.st'|) |@true|) (EQ (CONCVARSYM |IntSeqRep.Public.st$3|) |@true|) (EQ (|Is$IntSeqRep.RefArray$IntSeqRep.EArr$MAP| |IntSeqRep.RefArray'|) |@true|) (EQ (CONCVARSYM |IntSeqRep.RefArray$3|) |@true|) (EQ (|Is$IntSeqRep.Public$IntSeqRep.RefArray$MAP| |IntSeqRep.Public.elem'|) |@true|) (EQ (|Is$DCLOSED| |IntSeqRep.Public.elem'| |ALLOCATED'|) |@true|) (EQ (|Is$VCONSISTENT| |IntSeqRep.Public.elem'| |ALLOCATED'| VIRGIN) |@true|) (EQ (CONCVARSYM |IntSeqRep.Public.elem$3|) |@true|) (EQ |ALLOCATED$1| |ALLOCATED'|))) (EQ |IntSeqRep.Public.st$2| |IntSeqRep.Public.st'|))) (EQ |IntSeqRep.RefArray$2| |IntSeqRep.RefArray'|))) (EQ |IntSeqRep.Public.elem$2| |IntSeqRep.Public.elem'|)))) (AND (NOT (EQ (select |IntSeqRep.Public.sz| s) (NUMBER (ADDR (select |IntSeqRep.RefArray| (select |IntSeqRep.Public.elem| s))) 0))) (EQ ALLOCATED |ALLOCATED$1|) (EQ |IntSeqRep.Public.st| |IntSeqRep.Public.st$2|) (EQ |IntSeqRep.RefArray| |IntSeqRep.RefArray$2|) (EQ |IntSeqRep.Public.elem| |IntSeqRep.Public.elem$2|))) (FORALL (|i$3|) (IMPLIES (EQ (|Is$INTEGER| |i$3|) |@true|) (FORALL (|res$6| |res$5|) (AND (LBL |ERROR.deref.82.14| (NEQ s |$NIL|)) (LBL |ERROR.deref.82.21| (NEQ s |$NIL|)) (FORALL (|res$7|) (FORALL (|res$8|) (FORALL (|res$9|) (FORALL (|res$10|) (AND (LBL |ERROR.deref.83.22| (NEQ s |$NIL|)) (LBL |ERROR.deref.83.27| (NEQ (select |IntSeqRep.Public.elem$2| s) |$NIL|)) (IMPLIES (>= (+ (select |IntSeqRep.Public.st$2| s) (select |IntSeqRep.Public.sz| s)) (NUMBER (ADDR (select |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s))) 0)) (FORALL (|res$19|) (FORALL (|res$20|) (FORALL (|res$21|) (FORALL (|res$22|) (AND (LBL |ERROR.deref.83.52| (NEQ s |$NIL|)) (LBL |ERROR.deref.83.57| (NEQ (select |IntSeqRep.Public.elem$2| s) |$NIL|)) TRUE)))))) (FORALL (|i$4|) (IMPLIES (OR (EXISTS (|res$11|) (EXISTS (|i$5|) (AND (EXISTS (|res$12|) (EXISTS (|res$13|) (AND (EXISTS (|res$14|) (EXISTS (|res$15|) (AND (EXISTS (|res$16|) (EXISTS (|res$17|) (AND (EXISTS (|res$18|) (AND (EQ (+ (select |IntSeqRep.Public.st$2| s) (select |IntSeqRep.Public.sz| s)) |i$5|) (>= (+ (select |IntSeqRep.Public.st$2| s) (select |IntSeqRep.Public.sz| s)) (NUMBER (ADDR (select |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s))) 0)) (NEQ s |$NIL|) (EQ |res$16| (select |IntSeqRep.Public.elem$2| s)))) (NEQ |res$16| |$NIL|) (EQ |res$14| (select |IntSeqRep.RefArray$2| |res$16|))))) (EQ |res$12| (NUMBER (ADDR |res$14|) 0))))) (EQ |res$11| (- |i$5| |res$12|))))) (EQ |i$4| |res$11|)))) (AND (NOT (>= (+ (select |IntSeqRep.Public.st$2| s) (select |IntSeqRep.Public.sz| s)) (NUMBER (ADDR (select |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s))) 0))) (EQ (+ (select |IntSeqRep.Public.st$2| s) (select |IntSeqRep.Public.sz| s)) |i$4|))) (AND (LBL |ERROR.deref.84.7| (NEQ s |$NIL|)) (LBL |ERROR.deref.84.7| (NEQ (select |IntSeqRep.Public.elem$2| s) |$NIL|)) (LBL |ERROR.index.84.13| (AND (<= 0 |i$4|) (< |i$4| (NUMBER (select |IntSeqRep.Public.elem$2| s) 0)))) (LBL |ERROR.deref.86.9| (NEQ s |$NIL|)) (LBL |ERROR.subrange.86.4| (<= 0 (+ (select |IntSeqRep.Public.sz| s) 1))) (IMPLIES (LBL |ERROR.post.79.0.Normal return| (EQ RETURN RETURN)) (AND (LBL |ERROR.post.79.0.Normal return.p1| (EQ (NUMBER (ADDR (select (|FUNC.IntSeq.Data| (store |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s) (store (select |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s)) |i$4| x)) |IntSeqRep.Public.elem$2| (store |IntSeqRep.Public.sz| s (+ (select |IntSeqRep.Public.sz| s) 1)) |IntSeqRep.Public.st$2| |RESIDUE.IntSeq.Data$1|) s)) 0) (+ (NUMBER (ADDR (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray| |IntSeqRep.Public.elem| |IntSeqRep.Public.sz| |IntSeqRep.Public.st| |RESIDUE.IntSeq.Data$1|) s)) 0) 1))) (LBL |ERROR.post.79.0.Normal return.p2| (FORALL (|i$$3|) (NOPATS (|Is$MATHINT| |i$$3|)) (IMPLIES (EQ (|Is$MATHINT| |i$$3|) |@true|) (IMPLIES (AND (<= 0 |i$$3|) (< |i$$3| (NUMBER (ADDR (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray| |IntSeqRep.Public.elem| |IntSeqRep.Public.sz| |IntSeqRep.Public.st| |RESIDUE.IntSeq.Data$1|) s)) 0))) (EQ (select (select (|FUNC.IntSeq.Data| (store |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s) (store (select |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s)) |i$4| x)) |IntSeqRep.Public.elem$2| (store |IntSeqRep.Public.sz| s (+ (select |IntSeqRep.Public.sz| s) 1)) |IntSeqRep.Public.st$2| |RESIDUE.IntSeq.Data$1|) s) |i$$3|) (select (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray| |IntSeqRep.Public.elem| |IntSeqRep.Public.sz| |IntSeqRep.Public.st| |RESIDUE.IntSeq.Data$1|) s) |i$$3|)))))) (LBL |ERROR.post.79.0.Normal return.p3| (EQ (select (select (|FUNC.IntSeq.Data| (store |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s) (store (select |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s)) |i$4| x)) |IntSeqRep.Public.elem$2| (store |IntSeqRep.Public.sz| s (+ (select |IntSeqRep.Public.sz| s) 1)) |IntSeqRep.Public.st$2| |RESIDUE.IntSeq.Data$1|) s) (NUMBER (ADDR (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray| |IntSeqRep.Public.elem| |IntSeqRep.Public.sz| |IntSeqRep.Public.st| |RESIDUE.IntSeq.Data$1|) s)) 0)) x)))) (LBL |ERROR.post.79.0.RAISES| (EQ RETURN RETURN)) (LBL |ERROR.mod.79.0.IntSeqRep.Public.st| (FORALL (|s0$$10|) (PATS (select |IntSeqRep.Public.st| |s0$$10|) (select |IntSeqRep.Public.st$2| |s0$$10|)) (IMPLIES (AND (EQ (|Is$IntSeqRep.Public| |s0$$10|) |@true|) (EQ (|Is$DCL| |s0$$10| ALLOCATED) |@true|) (NEQ |s0$$10| |$NIL|) (EQ |s0$$10| s)) (OR (EQ (select |IntSeqRep.Public.st| |s0$$10|) (select |IntSeqRep.Public.st$2| |s0$$10|)) (EQ |s0$$10| s))))) (LBL |ERROR.mod.79.0.IntSeqRep.RefArray| (FORALL (|s0$$9| |s1$$2|) (PATS (select (select |IntSeqRep.RefArray| |s0$$9|) |s1$$2|) (select (select (store |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s) (store (select |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s)) |i$4| x)) |s0$$9|) |s1$$2|)) (IMPLIES (AND (EQ (|Is$IntSeqRep.RefArray| |s0$$9|) |@true|) (EQ (|Is$DCL| |s0$$9| ALLOCATED) |@true|) (NEQ |s0$$9| |$NIL|) (EQ (|Is$MATHINT| |s1$$2|) |@true|) (<= 0 |s1$$2|) (< |s1$$2| (NUMBER |s0$$9| 0))) (OR (EQ (select (select |IntSeqRep.RefArray| |s0$$9|) |s1$$2|) (select (select (store |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s) (store (select |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s)) |i$4| x)) |s0$$9|) |s1$$2|)) (EQ |s0$$9| (select |IntSeqRep.Public.elem| s)))))) (LBL |ERROR.mod.79.0.IntSeqRep.Public.elem| (AND (FORALL (|s0$$8|) (PATS (select |IntSeqRep.Public.elem| |s0$$8|) (select |IntSeqRep.Public.elem$2| |s0$$8|)) (IMPLIES (AND (EQ (|Is$IntSeqRep.Public| |s0$$8|) |@true|) (EQ (|Is$DCL| |s0$$8| ALLOCATED) |@true|) (NEQ |s0$$8| |$NIL|) (EQ |s0$$8| s)) (OR (EQ (select |IntSeqRep.Public.elem| |s0$$8|) (select |IntSeqRep.Public.elem$2| |s0$$8|)) (EQ |s0$$8| s)))) (FORALL (|s$4|) (PATS (select |IntSeqRep.Public.elem$2| |s$4|) (select |IntSeqRep.Public.elem| |s$4|)) (IMPLIES (AND (EQ (|Is$IntSeqRep.Public| |s$4|) |@true|) (EQ (|Is$DCL| |s$4| ALLOCATED) |@true|)) (OR (EQ (select |IntSeqRep.Public.elem$2| |s$4|) (select |IntSeqRep.Public.elem| |s$4|)) (EQ (select |IntSeqRep.Public.elem$2| |s$4|) |$NIL|) (AND (NOT (EQ (|Is$DCL| (select |IntSeqRep.Public.elem$2| |s$4|) ALLOCATED) |@true|)) (EQ (|Is$DCL| (select |IntSeqRep.Public.elem$2| |s$4|) |ALLOCATED$1|) |@true|))))))) (LBL |ERROR.mod.79.0.IntSeq.Data| (FORALL (|s0$$7| |s1$$1|) (PATS (select (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray| |IntSeqRep.Public.elem| |IntSeqRep.Public.sz| |IntSeqRep.Public.st| |RESIDUE.IntSeq.Data$1|) |s0$$7|) |s1$$1|) (select (select (|FUNC.IntSeq.Data| (store |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s) (store (select |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s)) |i$4| x)) |IntSeqRep.Public.elem$2| (store |IntSeqRep.Public.sz| s (+ (select |IntSeqRep.Public.sz| s) 1)) |IntSeqRep.Public.st$2| |RESIDUE.IntSeq.Data$1|) |s0$$7|) |s1$$1|)) (IMPLIES (AND (EQ (|Is$IntSeq.T| |s0$$7|) |@true|) (EQ (|Is$DCL| |s0$$7| ALLOCATED) |@true|) (NEQ |s0$$7| |$NIL|) (EQ (|Is$IntSeq.T| |s0$$7|) |@true|) (EQ (|Is$MATHINT| |s1$$1|) |@true|) (<= 0 |s1$$1|) (< |s1$$1| (NUMBER (ADDR (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray| |IntSeqRep.Public.elem| |IntSeqRep.Public.sz| |IntSeqRep.Public.st| |RESIDUE.IntSeq.Data$1|) |s0$$7|)) 0))) (OR (EQ (select (select (|FUNC.IntSeq.Data| |IntSeqRep.RefArray| |IntSeqRep.Public.elem| |IntSeqRep.Public.sz| |IntSeqRep.Public.st| |RESIDUE.IntSeq.Data$1|) |s0$$7|) |s1$$1|) (select (select (|FUNC.IntSeq.Data| (store |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s) (store (select |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s)) |i$4| x)) |IntSeqRep.Public.elem$2| (store |IntSeqRep.Public.sz| s (+ (select |IntSeqRep.Public.sz| s) 1)) |IntSeqRep.Public.st$2| |RESIDUE.IntSeq.Data$1|) |s0$$7|) |s1$$1|)) (EQ |s0$$7| s))))) (LBL |ERROR.mod.79.0.IntSeqRep.Public.sz| (FORALL (|s0$$6|) (PATS (select |IntSeqRep.Public.sz| |s0$$6|) (select (store |IntSeqRep.Public.sz| s (+ (select |IntSeqRep.Public.sz| s) 1)) |s0$$6|)) (IMPLIES (AND (EQ (|Is$IntSeqRep.Public| |s0$$6|) |@true|) (EQ (|Is$DCL| |s0$$6| ALLOCATED) |@true|) (NEQ |s0$$6| |$NIL|) (EQ |s0$$6| s)) (OR (EQ (select |IntSeqRep.Public.sz| |s0$$6|) (select (store |IntSeqRep.Public.sz| s (+ (select |IntSeqRep.Public.sz| s) 1)) |s0$$6|)) (EQ |s0$$6| s))))) (LBL |ERROR.mod.79.0.RESIDUE.IntSeq.Data| (FORALL (|t$1|) (PATS (select |RESIDUE.IntSeq.Data$1| |t$1|)) (IMPLIES (AND (EQ (|Is$IntSeq.T| |t$1|) |@true|) (EQ (|Is$DCL| |t$1| ALLOCATED) |@true|)) (EQ (select |RESIDUE.IntSeq.Data$1| |t$1|) (select |RESIDUE.IntSeq.Data$1| |t$1|))))) (LBL |ERROR.mod.79.0.IntSeq.Valid| (FORALL (|s0$$5|) (PATS (select (|FUNC.IntSeq.Valid| |IntSeqRep.RefArray| |IntSeqRep.Public.elem| |IntSeqRep.Public.sz| |IntSeqRep.Public.st| |RESIDUE.IntSeq.Valid|) |s0$$5|) (select (|FUNC.IntSeq.Valid| (store |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s) (store (select |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s)) |i$4| x)) |IntSeqRep.Public.elem$2| (store |IntSeqRep.Public.sz| s (+ (select |IntSeqRep.Public.sz| s) 1)) |IntSeqRep.Public.st$2| |RESIDUE.IntSeq.Valid|) |s0$$5|)) (IMPLIES (AND (EQ (|Is$IntSeq.T| |s0$$5|) |@true|) (EQ (|Is$DCL| |s0$$5| ALLOCATED) |@true|) (NEQ |s0$$5| |$NIL|) (EQ (|Is$IntSeq.T| |s0$$5|) |@true|)) (EQ (select (|FUNC.IntSeq.Valid| |IntSeqRep.RefArray| |IntSeqRep.Public.elem| |IntSeqRep.Public.sz| |IntSeqRep.Public.st| |RESIDUE.IntSeq.Valid|) |s0$$5|) (select (|FUNC.IntSeq.Valid| (store |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s) (store (select |IntSeqRep.RefArray$2| (select |IntSeqRep.Public.elem$2| s)) |i$4| x)) |IntSeqRep.Public.elem$2| (store |IntSeqRep.Public.sz| s (+ (select |IntSeqRep.Public.sz| s) 1)) |IntSeqRep.Public.st$2| |RESIDUE.IntSeq.Valid|) |s0$$5|))))) (LBL |ERROR.inv.79.0| (FORALL (|t1$| |t2$|) (NOPATS (|Is$IntSeq.T| |t1$|) (|Is$DCL| |t1$| |ALLOCATED$1|) (|Is$IntSeq.T| |t2$|) (|Is$DCL| |t2$| |ALLOCATED$1|)) (IMPLIES (AND (EQ (|Is$IntSeq.T| |t2$|) |@true|) (EQ (|Is$DCL| |t2$| |ALLOCATED$1|) |@true|) (EQ (|Is$IntSeq.T| |t1$|) |@true|) (EQ (|Is$DCL| |t1$| |ALLOCATED$1|) |@true|)) (IMPLIES (AND (NEQ |t1$| |$NIL|) (NEQ |t2$| |$NIL|) (NEQ |t1$| |t2$|) (NEQ (select |IntSeqRep.Public.elem$2| |t1$|) |$NIL|) (NEQ (select |IntSeqRep.Public.elem$2| |t2$|) |$NIL|)) (NEQ (select |IntSeqRep.Public.elem$2| |t1$|) (select |IntSeqRep.Public.elem$2| |t2$|)))))) (LBL |ERROR.mod.79.10| TRUE))))))))))))))))))))))))


(BG_POP)
