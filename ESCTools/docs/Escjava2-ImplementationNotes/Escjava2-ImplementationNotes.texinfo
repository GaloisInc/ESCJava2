\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename Escjava2-ImplementationNotes.info
@settitle ESC/Java2 Implementation Notes
@c @setchapternewpage odd
@c %**end of header

@c FIXME - all the node lines need fixing
@c FIXME - indexing needs major work

@comment ----- title and copyright pages
@titlepage
@title ESC/Java2 Implementation Notes
@subtitle VERY MUCH A PRELIMINARY, INCOMPLETE DRAFT

@author David R. Cok
@email{cok@@frontiernet.net}

@sp 1


@center July 2003

@c [[[ Abstract ???]]]

@sp 2

@b{Keywords:}  Behavioral interface specification, Java,
JML, Escjava, ESC/Java, ESC/Java2, model-based specification, assertion,
precondition, postcondition, frame.

@b{2003 CR Categories:}
D.2.1 [@i{Software Engineering}]
        Requirements/Specifications --- languages, tools, theory,
        JML, ESC/Java, ESC/Java2;
D.2.4 [@i{Software Engineering}]
        Software/Program Verification --- assertion checkers, class invariants,
        formal methods, programming by contract;
F.3.1 [@i{Logics and Meanings of Programs}]
        Specifying and Verifying and Reasoning about Programs ---
                assertions, invariants, logics of programs,
                pre- and post-conditions, specification techniques.

@sp 1

Copyright @copyright{} 2003 David R. Cok


@sp 2


@sp 4
@*CVS Version: $Revision$
@*CVS Date: $Date$
@end titlepage

@contents

@synindex vr cp
@synindex fn cp
@synindex ky cp
@synindex tp cp

@c node  Top, Introduction, (dir), (dir)

@comment FIXME - the menu goes here


@c ------ NAME --------
@node NAME, ???, ???, ???
@c  node-name,  next,  previous,  up


@c ------ chapter Introduction --------
@c node Introduction, Acknowledgements, Top, Top
@c  node-name,  next,  previous,  up
@chapter Introduction

@c ------ section Motivation and Background --------
@c node Motivation and Background, Acknowledgements, Top, Top
@c  node-name,  next,  previous,  up
@section Motivation and Background


ESC/Java2 extends the pioneering work on ESC/Java by a group [[[ Ref needed ]]]
at the Systems
 Research Center at DEC, later Compaq, now HP [@url{www.research.compaq.com}]. 
ESC/Java parses 
JML-like annotations in a Java program and warns, in a modular way, about
annotations that may not be justified by the Java source of the given
classes and the specifications of other classes.  The program works accurately 
enough and
fast enough that it has been found to be a useful tool.
Its usefulness is diminished by limitations in the kind of annotations that it can 
parse and check and also in that its annotation language is similar to but 
is neither a subset nor a superset of JML.

The goal of the ESC/Java2 work is to extend the use of ESC/Java by
@enumerate a
@item updating the parser of ESC/Java so that it is consistent with the current definition of JML,
@item packaging the updated tool so that it is more easily available to a 
larger set of users,
 consistent with the source code license provisions of the ESC/Java source code,
@item and extending the range of JML annotations that can be checked by the tool,
where possible and where consistent with the engineering goals of
ESC/Java.
@end enumerate

This document records the status of this implementation.  It is not intended to be a
tutorial or a reference guide for either JML or ESC/Java or ESC/Java2.  Rather it records the status of the features of JML:
the status of their implementation in ESC/Java2,
the degree to which the annotation is
logically checked, and any differences between ESC/Java2 and JML.
@itemize @bullet
@item More detailed information on JML is available at the web site 
@uref{www.jmlspecs.org}; the details of the JML definition are published in 
"Preliminary Design of JML" (Leavens, Baker, Ruby) and in 
"The JML Reference Manual" (Leavens, Poll, Clifton, Cheon, Ruby),
both available from the JML website.
@item Information on the original ESC/Java tool, 
nearly all of which still applies, is provided in "ESC/Java User's Manual", 
SRC Technical note 2000-002 (Leino, Nelson, Saxe), 
available at 
@*@center{@uref{gatekeeper.dec.com/pub/DEC/SRC/technical-notes/SRC-2000-002.html}}.
@end itemize

@c ------ section Acknowledgements --------
@c node  Acknowledgements, ???, Top, Top
@c  node-name,  next,  previous,  up
@section Acknowledgements


To date, the work on ESC/Java2 has been carried out primarily by Joe Kiniry
(@uref{www.kindsoftware.com}) and David Cok. 
Gary Leavens has provided guidance on the semantics
 and the current and future state of JML.  
K. Rustan M. Leino has provided advice with respect to the original ESC/Java.

The work of producing ESC/Java2 stands on the very much more considerable 
effort of 
the ESC/Java team (led by Leino at DEC SRC) in conceiving of and 
producing ESC/Java, Simplify and related tools in the first place. 

It also is built upon the work in designing JML and providing tools for JML led
by Gary Leavens at Iowa State University, with contributions from several other
individuals and groups, as described on the JML web page.

@c ------ section Dependencies and license restrictions --------
@c node  Dependencies and license restrictions, ???, Top, Top
@c  node-name,  next,  previous,  up
@section Dependencies and license restrictions


The ESC/Java2 tool relies on the following software packages that are separately 
available and may have their own license restrictions.
@itemize @bullet
@cindex ESC/Java
@cindex Simplify
@item The original source for ESC/Java, Simplify and related tools, available at 
@*@center{@uref{www.research.compaq.com/downloads.html}}.

@cindex Mocha
@item Part of the Mocha tool from UCBerkeley (optional), available at
@*@center{@uref{www-cad.eecs.berkeley.edu/~mocha/download/j-mocha}}.

@cindex Simplify
@cindex CM3
@item The CM3 compiler for Modula-3, which is needed to build the Simplify tool,
available from @uref{www.elegosoft.com} or @uref{fink.sourceforge.net}.
@cindex JUnit
@item The testing framework JUnit version 3.8.1, available at 
@uref{www.junit.org}.

@cindex JML
@item ESC/Java2 does not depend on the JML tool set, but it is useful to use the
two in combination.  ESC/Java2 is obviously dependent on the grammar and semantics
of JML.  JML is available at @uref{www.jmlspecs.org}.
@end itemize

@c ---------Contacts ------------------
@section Contacts and information

Further information about JML and ESC/Java2 can be obtained from these sources.

@itemize @bullet
@item The JML web site:  @uref{www.jmlspecs.org}
@item The JML project on sourceforge: @uref{sourceforge.net/projects/jmlspecs}
@item The JML interest mailing list on sourceforge: 
        @*@center{@email{jmlspecs-interest@@lists.sourceforge.net}}
@item The JML development mailing list on sourceforge: 
        @*@center{@email{jmlspecs-developers@@lists.sourceforge.net}}
@item The ESC/Java2 mailing list on sourceforge: 
        @*@center{@email{jmlspecs-escjava@@lists.sourceforge.net}}
@end itemize

JML utilizes (the Java subset of) the multijava compiler.
Information about multijava can be obtained from these sources.
@itemize @bullet
@item The multijava website: @uref{www.multijava.org}
@item The multijava project on sourceforge: @uref{sourceforge.net/projects/multijava}
@end itemize

@c ------ chapter Status of JML features --------
@c node  Status of JML features, ???, Top, Top
@c  node-name,  next,  previous,  up
@chapter Status of JML features


ESC/Java2 parses correctly formatted JML files, with the exceptions 
described in this document.  
JML files must be correct Java source with correctly formatted annotations, which
appear to Java as comments.  Although ESC/Java2 does some error reporting 
during parsing,
it does not report all parsing errors in either Java or JML, 
nor does it necessarily 
terminate normally if the input is not legal Java/JML.  There are a number of tools 
supporting JML that can be used to check the well-formedness of the JML annotations
in a file; a Java compiler can be used to check the format of the Java source code.

The authors encourage any report of a legal Java/JML file that ESC/Java2 will not 
parse.  Furthermore, despite the caveat above, the authors do want ESC/Java2 to be a
useful tool; hence they are interested in examples of legal or illegal
 Java/JML source code 
that cause abnormal termination and in examples in which the absence of error 
messages or the occurrence of an inappropriate error message is 
misleading to the user.  Examples that generate unsound or incomplete behavior
beyond that already documented are also of interest.

The organization of ESC/Java2's error and warning messages is described in
@ref{Error and warning messages}.


@cindex file names
@cindex suffixes
@cindex refinement sequence
@c ------ File naming, file finding, and refinement sequences --------
@node File naming, file finding, and refinement sequences, ???, ???, ???
@c  node-name,  next,  previous,  up
@section File naming, file finding, and refinement sequences

@cindex filenames
@cindex suffixes
JML follows Java conventions in file naming.  ESC/Java2 recognizes Java source
and class files organized into directory hierarchies matching the package 
definitions.  The file names themselves typically consist of a type name as a 
prefix and either @code{.java} or @code{.class} as a suffix.  Specification files
typically have the type name as a prefix and one of the specification suffixes
( .refines-java, .refines-spec, .refines-jml, .java, .spec, .jml, .java-refined,
.spec-refined, .jml-refined) as a suffix, though arbitrary suffixes are permitted.

@cindex classpath
@cindex sourcepath
The ESC/Java2 program
utilizes a classpath and a sourcepath, which are standard sequences of 
directories separated by a platform-dependent path separator character (a colon
on Linux and MacOSX, a semicolon on Windows).  The classpath is specified by the
-classpath command-line option, or by the CLASSPATH environment variable if no
command-line option is given, and is the just current working directory if neither
is specified.  The sourcepath is specified by the -sourcepath command-line option;
if that is not provided, the sourcepath is identical to the classpath.

@cindex -package
Files specified on the command-line are the files on which ESC/Java2 acts.  They
are found with respect to the current working directory (if the paths to the files
are relative paths).  If an entire package is
specified using the -package option, that package is found by looking in each of
the directories of the sourcepath in turn. [[[ which suffixes are used? ]]]

A file on the command-line is parsed to determine the package to which it 
belongs and the name of the type that it declares.  ESC/Java2 and JML tools then
use the following procedure to find the refinement sequence for the given fully
qualified type.  When the specifications of types referenced in files being
processed by ESC/Java2 are needed, they are found using the same procedure.

@itemize @bullet

@cindex MRCU
@cindex most-refined compilation unit
@item Search each directory of the sourcepath in turn, looking for the first
sourcepath directory containing a directory
hierarchy for the given package containing a file whose name
 has the type name as its prefix and one of the following suffixes:
 @code{.refines-java}, @code{.refines-spec}, @code{.refines-jml}, 
@code{.java}, @code{.spec}, @code{.jml}.  If the directory contains more than one
such file, the one with a suffix closest to the beginning of the list of suffixes
is used.  This file is called the @emph{Most-refined compilation unit} (MRCU).

@cindex refinement sequence
@item If the MRCU contains a @code{refine} statement, then the file named in it
is sought in the sourcepath in the same package as the MRCU.  It is an error if
a file named in a @code{refine} statement cannot be found in the sourcepath.  Files
found in this way are parsed in turn and the files named in each @code{refine} 
statement are sought.  This procedure is repeated recursively until a file is found
that has no @code{refine} statement.  The sequence of files so found is called the
@emph{refinement sequence}.  The refinement sequence may contain the .java or the
.class file.  Any .class file must be last in the sequence.

@item The rules above do not restrict the filenames of the files of the 
refinement sequence, other than that they must be in the same package (but not
necessarily in the same directory).  In particular, aside from the suffix for the
MRCU (and java and class files), 
there is no restriction on the suffixes that the files may have, nor on the
order of suffixes in the refinement sequence.  There is also no restriction on
the prefixes of the file names, other than that the MRCU, the .java file and the
.class file must have the typename as the prefix.  However, it is good style if
all of the files in the refinement sequence have the same prefix.  If a file has
a filename prefix that does not match the type declared within it, it is in danger
of being misinterpreted as belonging to a different type.  Consequently a 
caution is issued to the user if this situation is discovered.

@item Once an MRCU is found, the remainder of the refinement sequence is determined
by the @code{refine} statements.  But which file is found as the MRCU may depend 
on the contents @emph{and order} of the directories in the sourcepath.  This 
order dependence is by design as it is thought that the user may use this feature
to choose different starting points along the refinement sequence for processing.
It may also lead to inadvertent errors.

@item It is an error if the sequence of refine statements defines a circular
sequence of refinement files.

@item The .java source file and the .class file for the given fully-qualified type
are found as defined by Java, independently of determining the refinement
sequence, using the sourcepath and the classpath, respectively.

@item Note that if the .java file declares more than one type, then the
corresponding refinement sequence must contain the specifications for all of the
declared types.

@item The specifications for the classes declared in the files 
of a refinement sequence are the combination
of the specifications in all the files of the refinement sequence.  The Java
signature of the classes is obtained from the relevant .java or .class files.
The source code implementation of the classes is determined from the .java file.
If no .java file exists (or it does not contain an implementation of a method), then
the check of that method will be a trivial pass; the usage of the method in other
implementations will still be performed.

@item It may be that a refinement sequence exists and does not contain the file
specified on the command-line.  ESC/Java2 issues a caution to the user in this case.  However, if 
no refinement sequence is found, no caution is issued even if the command-line
file is not on the sourcepath; it is simply used as the specification of the 
declared classes.

@item It may be that the refinement sequence exists, and a corresponding .java file
exists in the sourcepath, but the refinement sequence does not contain the 
 .java file.  In this case the .java file is used as the source code
of the implementation and to define the signature of the class, 
but no specifications are obtained from it.  A caution is
issued to the user in this case.

@item It is not required that a .java or a .class file exist, since it is 
desired to be able to write specifications in advance of an implementation.  
However, if either one does exist then the following rules are used:
@enumerate a
@item if only a signature is needed, the most recently modified of the two is used to 
define the Java signature of the class (whether or not it is in the refinement
sequence).  Specifications are not permitted to add
new (non-model, non-ghost) declarations of fields, routines, or enclosed classes or
interfaces to those defined in the Java implementation.
@item if the implementation is needed (because this is a type whose implementation
is being checked by ESC/Java2) as well as the signature, 
then the .java file is used regardless of time stamp, if it exists.
@end enumerate

@item Currently, .class files do not contain specifications.  However, we would
like to leave open the possibility that in the future a binary version of parsed
and checked specifications could be created that would improve processing time.

@end itemize 

@noindent
@strong{Status: }  The above rules are implemented in ESC/Java2 with the following
exceptions.
@itemize @bullet
@item ESC/Java2 does not yet use the search order for the MRCU as described.
Rather it finds the file with the most active suffix anywhere in the sourcepath,
regardless of its position in the sourcepath.
@item ESC/Java2 chooses the .java file over the .class file regardless of time stamp, if both exist.
@item When finding the package named in the -package option, ESC/Java2 combines
all of the packages by that name in any directory of the sourcepath, rather than
just using the first one.
@item If a refinement sequence declares more than one type, and no .java file
exists, the .class file is used.  But the binary versions of the various types
are in different .class files.  At present only the .class file with matching 
prefix is used.
@item [[[ Check the caution for CL file not in the RS - OK]]]
@item [[[ Check the caution for the Java file not in the RS -OK ]]]
@item [[[ Check the caution if a misnamed file is found in the RS. - OK]]]
@item [[[ Check that there is an error if a 'refine' file cannot be found. - OK ]]]
@item [[[ Check that the sourcepath is actually defined and used. - OK]]]
@item [[[ Can ESC/Java2 handle refining a class? multiple classes from one file? nested classes? ]]]

@item [[[ Should we have an option to find MRCUs with any suffix? ]]]
@item [[[ Should we have an option to find the whole chain whatever the order of the sourcepath and suffixes?]]]
@item [[[ Should we have an option to change/expand the list of MRCU suffixes? ]]]
@item [[[ Should we have an option to define 'implicit' refine statements, in order
for example, to connect specification files to implementation files, when the 
implementation files suddenly become available and we don't want to edit all of the
files? ]]]
@end itemize

@c ------ Format of annotations --------
@node Format of annotations, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Format of annotations

@cindex format of annotations
@cindex annotation markers
@cindex comments, annotation
@cindex @code{//@@}
@cindex @code{//+@@}
@cindex @code{/*@@}
@cindex @code{/*+@@}
@cindex @code{*/}
@cindex @code{@@*/}
@cindex @code{@@+*/}
@itemize @bullet
@item @strong{Comment format:} JML annotations are included in a Java program as 
specially formatted comments.  
In particular, JML annotations recognized by ESC/Java2 are either
@itemize @bullet

@item single-line comments beginning with @code{//@@}, or

@item multi-line comments enclosed between @code{/*@@} and either 
@code{*/} or @code{@@*/} , or

@cindex @code{<esc>}
@cindex @code{<ESC>}
@cindex @code{<jml>}
@cindex @code{<JML>}

@item annotations embedded in a javadoc comment between any of the 
four pairs of markers
@code{<esc>} and @code{</esc>}, 
@code{<ESC>} and @code{</ESC>}, 
@code{<jml>} and @code{</jml>}, or
@code{<JML>} and @code{</JML>}.
The original ESC/Java only recognized the first pair.  These annotation pairs
may not be nested, but there may be multiple annotations in sequence.  ESC/Java2
and JML do not restrict where in the javadoc comment an annotation may occur.
However, javadoc requires the annotation to be
a part of the textual description and to precede any tag descriptions that are
part of the comment.  The jmldoc tool allows multiple annotations to be intermixed
with the tag descriptions.  Neither ESC/Java2 nor the JML tools require the annotation
to be enclosed between @code{<pre>} and @code{</pre>} tags;
however, if you expect reasonable formatting in a javadoc produced HTML
page, you will likely wish to do so.  The jmldoc tool does not require 
@code{<pre>} and @code{</pre>} tags to produce good
formatting.
@end itemize
Both the JML tools and ESC/Java2 allow multiple @@ symbols in the opening 
comment markers (e.g. @code{//@@@@@@@@} is equivalent to @code{//@@}).

Note that JML recognizes additional annotations in these forms:
@itemize @bullet

@item single-line comments beginning with @code{//+@@} ;

@item multi-line comments enclosed between @code{/*+@@} and either 
@code{*/} or @code{@@*/} or @code{@@+*/} ;

@end itemize
These latter forms are part of JML but not ESC/Java2 to allow for syntax defined by
JML but ignored by ESC/Java2.  It is hoped that the result of the current work on
ESC/Java2 will diminish the need for the JML-only comments.  They may remain useful
as a way to retain JML annotations that are not processed (though they could be)
by ESC/Java2.
@*@strong{Status: } All of these annotation markers are implemented.  At present 
the embedded annotations using @code{<jml>} and @code{<JML>} are not parsed by
ESC/Java2 (unless @code{-parsePlus} is specified as described below), but that 
behavior is expected eventually to change.
@*@strong{Differences:} Both ESC/Java2 and JML tools allow
 multiple @@ symbols in any of the opening
 annotation markers (@code{//@@}, @code{//+@@},
@code{/*@@}, @code{/*+@@}),
but only ESC/Java2 allows multiple @@ symbols in the closing annotation markers
(@code{@@*/} and @code{@@+*/}).



@item @strong{-parsePlus option:} The @code{-parsePlus} command-line option
instructs ESC/Java2 to parse all annotations recognized by JML.  This is used mainly
in testing to find and attempt to process the JML-only annotations, but may be
 useful in other circumstances. @xref{-parsePlus}.

@item @strong{Initial `@@' symbols in annotations:} Within a multi-line annotation,
 a sequence of `@@' symbols
that follow whitespace at the beginning of a line are treated as white space.
Within an annotation embedded in a Javadoc comment, a sequence of `*' symbols
(but not `@@' symbols)
that follow whitespace at the beginning of a line are treated as white space.

@item @strong{Splitting annotations across comments:} 
 JML will correctly parse and process
 annotations that are split across multiple comments (e.g. a multi-line annotation
 in which each line begins with @code{//@@}).  ESC/Java2 expects an annotation
 to be entirely contained within one single- or multi-line comment.  The latter
 behavior is `correct' JML; however, the JML tools will correctly process and not
 warn about annotations split across multiple comments. 
 To be specific: 
@itemize @bullet
@item ESC/Java2 requires that any
 clause beginning with a keyword (e.g. invariant, requires)
and ending with a semicolon must be contained 
 within one annotation comment.  For example, write
@example
//@@ requires i != 0 && j != 0;
@end example
@noindent
or
@example
/*@@ requires i != 0 &&
  @@          j != 0;
  @@*/
@end example
@noindent not
@example
//@@ requires i != 0 && 
//@@          j != 0;   
@end example
@item ESC/Java2 requires that model methods, model
 constructors and model programs be defined within one annotation comment.
 For example, write
 @example
 /*@@ public model int m(int i, int j) @{
          return i+j;
      @}
  @@*/
@end example
@noindent not
@example
//@@ public
//@@ model int m(int i, int j) @{
//@@          return i+j;
//@@ @}
@end example
@item The tool also requires that a Java modifier 
 (e.g. @code{public}) be in the
 same comment as a JML annotation (e.g. @code{behavior} or model method) that it modifies.  For example, write
@example
//@@ public behavior
@end example
@noindent not
@example
//@@ public
//@@ behavior
@end example
@end itemize

Thus, @code{requires} and @code{ensures} clauses must each be wholly within
 a single annotation comment; individual keywords such as @code{pure}, @code{normal_behavior},
 @code{also}, @code{@{|}
 or @code{implies_that} may be in annotation comments by themselves (with any relevant
access modifiers).
 [[[ FIXME - JML rules need to be clarified.]]]
 
@item @strong{Multiple annotations per comment:} It is legal JML to include multiple
annotations per comment; in fact it is common practice and good style to include
many related annotations within one multi-line comment.  ESC/Java2 supports this
practice (though ESC/Java had some difficulties).  

@item @strong{Terminating semicolons:} JML requires annotations to be terminated by
semicolons.  The original ESC/Java did not.  The absence of semicolons is illegal
JML, but is sometimes tolerated by ESC/Java2. ESC/Java2 will warn if a semicolon
is missing. [[[ But does not yet do so to avoid problems with old tests. ]]]

@end itemize



@section Compilation unit annotations
Compilation unit annotations are placed prior to the declaration of any type within 
a file.

@subsection refine statements
@itemize @bullet
@item @strong{Description:} A JML refine statement indicates that the containing 
compilation unit adds additional
specifications to those contained in the referenced file.  If present, it must
be located after any Java package statement and before any Java or model import 
statements.
It has the form
@*@center{@code{//@@ refine "}@emph{filename}@code{";}}
@*The refine statements define a @emph{refinement sequence} as described in
@ref{File naming, file finding, and refinement sequences}.  
Here we focus on the combining of the compilation units in
a refinement sequence to produce a single set of specifications for a type.  Each
compilation unit has its own set of declarations and specifications, all of which
must be consistent.  They are subject to the following rules, violations of which
provoke error messages.
@itemize @bullet

@item All files of the refinement sequence must belong to the same package (though
not necessarily the same directory); the type names of the declared types must be
identical (including case).

@item If a .java or a .class file exists for a type, the specifications may not add any Java (that is, non-model, non-ghost) declarations to the signature.  They may 
only repeat declarations.

@item If a field is redeclared, it must be redeclared with the same type and the
same Java modifiers.  An initializer may be present only in the .java file.

@item These JML modifiers must be consistent across all redeclarations
of a field:
@code{model}, @code{ghost}, @code{instance}.  The modifiers 
@code{spec_public}, @code{spec_protected}, @code{non_null} and
@code{monitored} may be added by a refinement file, but may not be removed.

@item If a method or constructor is redeclared, it must be redeclared with the
same return type, the same Java modifiers, and the same names for its formal
parameters.  An implementation may be present only in the .java file. (The
restriction on the formal parameter names is to simplify reading and to avoid
having the implementation have to rename variables in specifications.)

@item These JML modifiers must be consistent across all method and constructor
redeclarations: @code{model}.  These JML modifiers may be added by a refinement
but may not be removed: @code{spec_public}, @code{spec_protected}, @code{helper},
@code{non_null}, @code{pure}.

@item The Java modifier @code{final}, as applied to a formal parameter, must be
consistent across all redeclarations of a method or constructor.  The JML 
modifier @code{non_null} may be added, but not removed.

@item If a refinement file redeclares a method or constructor from a previous
refinement, or if the method is overriding a method in a super class or interface,
the specification for that redeclared or overriding method must begin with 
`@code{also}' (and may begin with `@code{also}' only when those conditions are
satisfied).

@item A type redeclaration must have the same set of Java modifiers.  In addition
the JML modifier @code{model} must be consistent; the JML modifiers @code{pure},
@code{spec_public}, and @code{spec_protected} 
may be added by a refinement but not removed.

@end itemize


@item @strong{Status:} The refine statement is implemented in ESC/Java2.
[[[ Check that all the rules above are enforced. They are not all yet.]]]

@item @strong{Comment on combining refinements:} There are (at least) 3 ways to
carry out the combining of refinements 
@enumerate a
@item by syntactically combining the 
relevant text
@item by typechecking each compilation unit independently and then combining the signatures
@item by typechecking each compilation unit in turn, in the context of the 
compilation units it is refining
@end enumerate

[[[ Discuss implications and differences.  ESC/Java2 uses (a). ]]]

@end itemize

@subsection model import statements
@itemize @bullet
@item @strong{Description:}
A model import statement has the form
@*@center{@code{//@@ model }@emph{java-import-statement}@code{;}}
@*Note that simply writing
@*@center{@code{//@@ }@emph{java-import-statement}@code{;}}
@*is not legal JML.
A model import statement may occur wherever a Java import statement may be placed.
A model import statement introduces types that are used only by annotations.
Annotations may also use types introduced by Java import statements.

@item @strong{Status:}  Model import statements are fully implemented.

@item @strong{Differences from JML or Java:}  This feature is implemented in 
ESC/Java2 as it is in JML.  However, both have the following problem.  The
model import statements are
 parsed by JML tools and by
ESC/Java2 as if they were Java import statements.  Thus they may introduce or resolve
an ambiguity in class name resolution of names used in the Java source code in a
compilation unit, or cause misinterpretation of a type name.  For example, in
@example
import java.io.*;
//@@ model import myclasses.File;
public class C extends File @{@}
@end example
@noindent
the use of @code{File} as the superclass is interpreted as @code{java.io.File}
by the Java compiler but as @code{myclasses.File} by JML tools and ESC/Java2.
Similarly, in
@example
import java.io.*;
//@@ model import myclasses.*; // class myclasses.File exists
public class C extends File @{@}
@end example
@noindent
the use of @code{File} is interpreted as @code{java.io.File} by a Java compiler
but will be deemed ambiguous between @code{java.io.File} and @code{myclasses.File} 
by the JML and ESC/Java tools.
These are as yet unresolved bugs.


@item @strong{Comment:} Though legal, there is no point to a statement of the form
@*@center{@code{/*@@ model @@*/ import }@emph{typename}@code{;}}
@* This is equivalent to simply using a Java import statement.
@end itemize

@cindex public
@cindex protected
@cindex private
@cindex spec_public
@cindex spec_protected
@c ------ section Access modifiers --------
@node Access modifiers, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Access (privacy) modifiers
Java allows the programmer to modify fields, methods,
constructors, class and interface declarations with one of the privacy or
 access modifiers @code{public}, @code{protected}, @code{private} or to omit these
 implying default (or package) access.  These modifiers affect the visibility of
 the associated declaration to other classes.  ESC/Java issues compile-time errors
 for (some) misuses of access, but the access of any given syntactic entity does not
 affect the static checking that is performed.
 
 JML also imposes some rules about access modifiers.  Some JML constructs also
 are allowed to be modified by an access modifier: the class-level
 clauses described in @ref{Annotation clauses for a class or interface}, such as @code{invariant}),
 and the behavior and example keywords 
 (@code{behavior}, @code{normal_behavior}, @code{exceptional_behavior}, 
 @code{example},
 @code{normal_example}, and @code{exceptional_example}).  In addition the method-level
 clauses (e.g. @code{requires}, @pxref{Annotation clauses for a method or constructor}) are assigned the privacy level of the behavior case
 of which they are a part (if in a heavyweight specification case) or the privacy
 level of the method they modify (if in a lightweight specification case).
 A specification clause may not use program entities with
 tighter access restrictions than it itself has.  For example, a requires clause in
 a protected @code{normal_behavior} specification case may not use @code{private}
 fields.
 
 Java program constructs that may be modified with an access modifier may also be
 modified with one or the other of @code{spec_public} and @code{spec_protected}.
 A program construct modified with @code{spec_public} is considered to have
 public access for any specification and may be used in any 
 specification clause; a program construct modified with @code{spec_protected}
 may be used in any non-public specification clause.  JML constructs may not be
 modified with @code{spec_public} or @code{spec_protected}.
 
 Note that @code{spec_public}, but not
@code{spec_protected}, was present in ESC/Java

 
@noindent
@strong{Status:} Parsing and type checking of access modifiers
are fully implemented.  The access
modifiers do not affect static checking.  [[[ Need to verify checks for spec_public and spec_protected, and access checks
 in general. ]]]
 


@section Type modifiers

A class may be modified with the Java modifiers @code{public}, @code{protected},
@code{private}, @code{static}, @code{final}, @code{abstract} and @code{strictfp} and the JML 
modifier @code{pure}.  An interface may be modified with the
Java modifiers @code{public}, @code{protected},
@code{private}, @code{static}, @code{strictfp} and the JML 
modifiers @code{pure}, @code{spec_public}, @code{spec_protected}.  The access modifiers are described in 
@ref{Access modifiers}.
  In addition the superclass and
super interfaces may be modified with the keyword @code{weakly}.


@subsection pure (JML)
@itemize @bullet
@item @strong{Description:} The @code{pure} modifier, when applied to a class or
interface, indicates that every method of the class or interface is @code{pure}.
Thus, no method may assign to variables other than those declared within the body
of the routine.  Constructors may only assign to the fields of the object
being constructed.

@item @strong{Status:} Parsed and fully implemented.

@item @strong{Differences from JML or Java:} None.

@item @strong{Comment:} A method inherits purity from the methods it overrides;
that is, if an overridden method is pure, the overriding method will be pure
whether or not it is declared pure.  This is not the case for classes or 
for interfaces.  A subclass may add non-pure methods, even if it has a pure
superclass.  Declaring a class pure is precisely equivalent to declaring all of its
methods and constructors pure. [[[ Verify with JML]]]

@end itemize


@subsection weakly (JML)

@itemize @bullet
@item @strong{Description:} This annotation is used to modify super classes and 
super interfaces in a class
or interface declaration.  An example of its syntax is this:
@example
   public class A extends B /*@@ weakly */ 
      implements C /*@@ weakly */, D /*@@ weakly */ @{ ... @}
@end example
@* [[[ Need a description of the semantics ]]]

@item @strong{Status:} Parsed and ignored by ESC/Java2.

@item @strong{Differences from JML or Java:} Parsed but ignored by ESC/Java2.
  This 
feature is not present in ESC/Java.

@end itemize

@subsection final (Java)

@itemize @bullet
@item @strong{Description:} A final class may not have subclasses.
@item @strong{Status:} This modifier is parsed and checked.  It does not need
any static checking.
@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection abstract (Java)

@itemize @bullet
@item @strong{Description:} A class must be declared abstract if it has abstract
methods.  An abstract class may not be instantiated; only non-abstract subclasses
of an abstract class may be instantiated.  All interfaces are by definition
abstract; using the @code{abstract} modifier on an interface has been deprecated.

@item @strong{Status:} This modifier is parsed and checked.  It does not need
any static checking.
@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection strictfp (Java)

@itemize @bullet
@item @strong{Description:} The @code{strictfp} modifier determines the semantics
of floating point operations within
the class so modified.

@item @strong{Status:} This modifier is parsed and typechecked.  The static checker
does not make use of this information.

@item @strong{Differences from JML or Java:} None.

@end itemize


@subsection static (Java)
@itemize @bullet
@item @strong{Description:} @code{static} is a Java modifier that may be applied
to classes and interfaces that are members
of enclosing classes.  

@item @strong{Status:} ESC/Java2 parses nested classes, including any modifiers,
but it does not properly typecheck them and does not do any static checking 
involving them.  When it does, the @code{static} modifier will have its usual Java
meaning.

@item @strong{Differences from JML or Java:} None.
@end itemize

[[[ Check whether JML allows instance on nested classes or interfaces]]]

@section Annotations pertinent to a class or interface
These annotations may appear anywhere a declaration 
within a class or interface may appear.  They define specification-only
ghost or model fields of the type and state specifications that apply to
the whole object (not just to individual methods).

@subsection Ghost fields
@itemize @bullet
@item @strong{Description:} A ghost field is a field of the object that can hold a
value or reference to an object, but is used only in specifications.  Its
value is changed using the @code{set} annotation within the body of
a method or constructor (@pxref{set}).  
A ghost field may have an initializer, just as a 
Java program field may, but the ghost field may be initialized in only one
compilation unit of a refinement sequence.  A ghost field may have modifiers that
a Java field declaration would have (access modifiers (@pxref{Access modifiers}), @code{static}, @code{final},
@code{volatile}, @code{transient}) as well as the JML
modifiers @code{non_null}, @code{monitored} and @code{instance} 
(@pxref{Annotation modifiers for a field declaration}).

An interface may also declare ghost fields; these fields may be 
referenced by annotations in the interface or its subtypes.
  Such ghost fields are by default static,
but may be modified by the JML modifier @code{instance}, in which case they are
a field of every object that implements the interface.


@item @strong{Status:} Ghost fields are completely supported, but the 
@code{instance} modifier is not.

@item @strong{Differences from JML or Java:} 
[[[ Check that that rule about at most one
initialization is actually checked/enforced/correct.  Check on the allegation that
ghsot fields have a different scope than regular fields (in the JML/ESC differences
document).  Check that ghost fields are inherited properly.  How about inherited 
from interfaces.  Verify the behavior of instance fields. CHeck on initializations
Check that modifiers work.]]]

@end itemize

@subsection Model fields
@itemize @bullet
@item @strong{Description:} Model fields are declarations within an annotation
prefixed by the modifier @code{model}.  They do not represent actual 
specification fields as do @code{ghost} values.  Rather, their values are 
implied by the concrete representation of the class, either
by an explicit expression in a @code{represents} clause or implicitly by
a boolean condition in a @code{\such_that} form of the 
@code{represents} clause.  They are used to supply values
that @emph{model} the behavior of the class.

A model field may have these modifiers: access modifiers (@pxref{Access modifiers}), @code{static},
 [[[ these ???: @code{final},
@code{volatile}, @code{transient}) and the JML
modifiers @code{non_null}, @code{monitored} and @code{instance} (@pxref{Annotation modifiers for a field declaration}). ]]]

@item @strong{Status:} Model fields are parsed and used in typechecking.  However,
@code{represents} clauses are not implemented in the static checking within
ESC/Java2; consequently annotations containing model fields are not yet checked.

@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection Model methods
@itemize @bullet
@item @strong{Description:} Model methods are method declarations within an
annotation and prefixed with the modifier @code{model}.  They declare methods that
may be used in model programs and (if pure) in specifications.  Model methods
may have these Java modifiers: @code{public}, @code{protected}, @code{private},
@code{static}, @code{final}, @code{synchronized}, @code{strictfp};
they may have these JML modifiers: @code{pure}, @code{non_null}, @code{monitored},
@code{helper}.


@item @strong{Status:} Model methods are parsed and converted to regular Java 
methods within ESC/Java2.  However, the static checking mechanism of ESC/Java is
not able to handle method calls in specification expressions.

@item @strong{Differences from JML or Java:} Model methods are parsed and 
converted to regular Java 
methods within ESC/Java2.  Consequently, ESC/Java2 will not detect their (illegal) 
use within the implementation of a Java routine.


@end itemize

@subsection Model constructors
@itemize @bullet
@item @strong{Description:} Model constructors are constructor
 declarations within an
annotation and prefixed with the modifier @code{model}.  They declare 
constructors that
may be used in model programs and (if pure) in specifications.
A model constructor
may have these Java modifiers: @code{public}, @code{protected}, @code{private};
it may have these JML modifiers: @code{pure}, @code{helper}.  Constructors may
be @code{strictfp} only by virtue of the entire class being declared
@code{strictfp}.


@item @strong{Status:} Model constructors are parsed and converted to regular Java 
constructors within ESC/Java2.  However, the static checking mechanism of ESC/Java is
not able to handle constructor calls in specification expressions.

@item @strong{Differences from JML or Java:} Model constructors are parsed and 
converted to regular Java 
constructors within ESC/Java2.  Consequently, ESC/Java2 will not detect their (illegal) 
use within the implementation of a Java routine.

@end itemize

@subsection model class and model interface
@itemize @bullet
@item @strong{Description:} [[[ description needed ....]]]

@item @strong{Status:} [[[ status unknown ....]]]

@item @strong{Differences from JML or Java:} [[[bugs...]]]

@end itemize


@subsection initializer
@itemize @bullet
@item @strong{Description:} Java allows initializer blocks within a type 
declaration.  These are blocks of code contained simply within a pair of
curly braces.  The code is executed when a new object is being created, prior
to any constructor being run.  It is executed in turn (per the textual order of
field declarations and initializers
in the source file) as the fields of the objects are being initialized.
It may have specifications (e.g. @code{requires} and @code{ensures} clauses) 
associated with it; those specifications must hold of the object 
after initialization, but prior to any constructors being executed.
The annotations may be associated with the block of Java code directly in source
files that contain such code; in specification files without code, the
@code{initializer} keyword is a stand-in for the block of code itself.

@item @strong{Status:} Not yet parsed or implemented in static checking.

@item @strong{Differences from JML or Java:} None.

@item @strong{Comment:} [[[ FIXME - How is an initializer 
specification associated with a particular
block of Java code?  Or is there just one JML initializer specification 
allowed, and it 
expresses the condition after all the field and initializing code is run?  
 ]]]

@end itemize

@subsection static_initializer
@itemize @bullet
@item @strong{Description:} Java allows static initializer blocks within a type 
declaration.  These are blocks of code contained simply within a pair of
curly braces and having the 
modifier @code{static}.
  The code is executed when the class is loaded, prior
to any object of the class being instantiated.  
It is executed in turn (per the order of static
declarations in the source file) as the static fields of the 
class are being initialized.
It may have specifications (e.g. @code{requires} and @code{ensures} clauses) 
associated with it; those specifications must hold of the class 
after loading, but prior to the instantiation of any objects
(and with the prestate being the state before loading begins).
The annotations may be associated with the block of Java code directly in source
files that contain such code; in specification files without code, the
@code{static_initializer} keyword is a stand-in for the block of code itself.

@item @strong{Status:} Not yet parsed or implemented in the static checker.

@item @strong{Differences from JML or Java:} None.


@item @strong{Comment:} [[[ FIXME - How is a static  initializer 
specification associated with a particular
block of Java code?  Or is there just one JML static initializer specification 
allowed, and it 
expresses the condition after all the field and initializing code is run?  
 ]]]

@end itemize

@subsection Java method, constructor and field declarations
@itemize @bullet
@item @strong{Description:} These declarations are identical to those defined by
Java.  An implementation or initialization for such a declaration may appear only
in the .java file, not in any repeated declaration in a specification file.
@item @strong{Status:} Parsed and typechecked fully.  Java fields may be used in
annotations.  JML also allows pure methods and constructors
to be used in annotations, but the static checker
is not yet able to handle annotations containing method and constructor calls.

@item @strong{Differences from JML or Java:} None
@end itemize

@subsection inner or nested Java class or interface declarations
@itemize @bullet
@item @strong{Description:} Java allows declarations of classes and interfaces
within a class or interface.  These are called nested classes or interfaces if
they are @code{static} and inner classes or interfaces if they are not @code{static}.

@item @strong{Status:} Such classes and interfaces are parsed and used in 
typechecking.  However, ESC/Java2 does not check their specifications or recognize
their use in annotations.

@item @strong{Differences from JML or Java:} None

@end itemize

[[[ Array initialization, ghost array initialization ??? ]]]


@c ------ section Annotation clauses for a class or interface --------
@node Annotation clauses for a class or interface, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Annotation clauses for a class or interface
These clauses provide a specification of the behavior of the class and of objects
of the class.  They may be specified in any order, within annotation comments,
anywhere an element of a type declaration may appear.  They may individually have
access modifiers (@pxref{Access modifiers}) @code{public}, @code{protected}, or
@code{private}.

@subsection invariant, invariant_redundantly
@itemize @bullet
@item @strong{Description:} An @code{invariant} clause specifies a boolean 
condition that must hold before and after any call of a (non-helper) method 
of the containing type.  Invariants must hold after any (non-helper)
constructor call of the containing type.

@item @strong{Status:} Fully implemented.

@item @strong{Differences from JML or Java:} None

@end itemize

@subsection constraint, constraint_redundantly
@itemize @bullet
@item @strong{Description:} A @code{constraint} clause specifies a relation that
must hold between the pre- and post-conditions of any (non-helper) method
 of the containing type.

@item @strong{Status:} Parsed and typechecked, but not implemented in the static checker.

@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection represents, represents_redundantly
@itemize @bullet
@item @strong{Description:} A @code{represents} clause designates how a model field
is related to the concrete fields or other model fields of the implementation.

@item @strong{Status:} Parsed and typechecked, but not utilized by the static checker.

@item @strong{Differences from JML or Java:} None.

@end itemize
@subsection depends, depends_redundantly
@itemize @bullet
@item @strong{Description:} The @strong{depends} clause is obsolete; it is replaced by
@strong{in} and @strong{maps} [[[ Ref ]]],

@item @strong{Status:} Depends clauses are parsed and ignored.


@end itemize

@subsection axiom
@itemize @bullet
@item @strong{Description:} An @code{axiom} is used to specify a mathematical
property, independent of the implementation of classes or objects.

@item @strong{Status:} [[[This feature was part of ESC/Java, but needs verification 
that it is functional in ESC/Java2. ]]] Fully parsed and typechecked.

@item @strong{Differences from JML or Java:} None.


@end itemize

@subsection initially, initially_redundantly
@itemize @bullet
@item @strong{Description:} This clause specifies a condition that must hold in
the post-state of any constructor (including the default constructor). 

@item @strong{Status:} Parsed and typechecked, but not implemented in the static
checker.

@item @strong{Differences from JML or Java:} None.


@end itemize

@subsection readable
@itemize @bullet
@item @strong{Description:} description.... [[[ Description needed ]]]

@item @strong{Status:} Not implemented.

@item @strong{Differences from JML or Java:} [[[bugs...]]]


@end itemize

@subsection monitors_for
@itemize @bullet
@item @strong{Description:} description....  [[[ Description needed ]]]

@item @strong{Status:} Not implemented.

@item @strong{Differences from JML or Java:} [[[bugs...]]]


@end itemize



@section Annotations for a method or constructor
Specifications of the behavior of an individual
 method or constructor typically appear within
an annotation comment, just prior to the declaration of the method or constructor.
The specifications consist of zero or more lightweight or heavyweight behavior 
sections, an optional subclassing contract, an optional @code{implies_that}
section, and an optional @code{for_example} section.  Model methods and constructors
may also be annotated with these specifications.

@node Lightweight and heavyweight specifications, ???, ???, ???
@subsection Lightweight and heavyweight specifications
@itemize @bullet
@item @strong{Description:} Lightweight specification cases are simply a series of specification clauses and
correspond to the specification style of ESC/Java. 
Heavyweight specification cases are introduced with a @code{behavior},
@code{normal_behavior}, or @code{exceptional_behavior} keyword.  Heavyweight
specifications may have optional privacy modifiers (@pxref{Access modifiers})
 and have different defaults than do lightweight
specifications.

Within a heavyweight specification, if a particular clause type is omitted, the 
default for that clause is as follows:
@example
        requires true;
        ensures true;
        signals (java.langException) true;
        diverges false;
        assignable \everything;
        accessible \everything;
        when true;
        duration \not_specified;
        working_space \not_specified;
@end example
@noindent
The defaults defined by JML for lightweight specifications are @code{\not_specified}
in each case.  This is interpreted within ESC/Java2 as follows.  
@example
        ensures true;
        signals (java.langException) true;
        diverges true;
        assignable \everything;
        accessible \everything;
        when true;
        duration \not_specified;
        working_space \not_specified;
@end example
@noindent
The default for the requires clause is determined as follows: @footnote{Michael Moeller contributed to this formulation of the defaults for requires.}
@itemize @bullet
@item If there are some other clauses explicitly given, but no requires clause, the default is @code{requires true;}
@item If there is no specification at all and the method does not override any super class or super interface methods (or is a constructor), the default is
@code{requires true;}
@item If there is no specification at all (including no @code{non_null} modifiers)
and the method does override some super class
or super interface method, the default is @code{requires false; }
@end itemize
The reasons for these defaults are explained in @ref{Specifications and inheritance}.

Note that the defaults for the @code{diverges} clause are different between the
lightweight and heavyweight forms.  The lightweight default, @code{diverges true},
puts the least restrictions on the implementation; it states that the
implementation is allowed to be non-terminating (but not required to be).  The
heavyweight default, @code{diverges false}, requires the implementation to
terminate with either an exception or a normal return.  [[[ However, this is not
checked in the current implementation. ]]]

@item @strong{Status:} The lightweight and heavyweight specification forms,
including nesting using @code{@{|} and @code{|@}} and combination with @code{also},
 are 
fully parsed and implemented (though not all clause types, as described below, 
are fully implemented or handled by the static checker).

@item @strong{Differences from JML or Java:} None, except that ESC/Java2 does not
constrain the order of clauses as rigidly as do JML tools. [[[ Say more]]]

@item @strong{Comment:} The ESC/Java2 (and ESC/Java) translator,
which produces the verification conditions to be checked by the static checker,
 accepts a set
of specification clauses in lightweight form.  In order to handle the nested and
heavyweight forms and the combination of specifications using @code{also}, either
within one source file or across a refinement sequence, ESC/Java2 @emph{desugars}
the more complicated syntax into a simpler form.  For this purpose ESC/Java2 largely
follows the desugaring as outlined in [[[FIXME - provide ref]]], but it does not need
to desugar all clause types down to one instance of that clause type.  That paper
provides more details on the desugaring process; the 
equivalent but slightly simpler version
used in ESC/Java2 is outlined here. Note that the desugaring process must take care
not to lose the location information that is helpful to the user when warning
messages are issued.

The desugaring process first eliminates nesting by replicating and distributing 
the requires clauses across the nested groups of clauses.  [[[ FIXME -- comment on
forall and old]]]  Also, each lightweight specification case,
 @code{normal_behavior} and 
@code{exceptional_behavior} keyword is desugared into a @code{behavior}
specification.  Specifications from corresponding methods in the
refinement sequence are combined, connected by @code{also}.
That produces a series of specification cases, connected by @code{also}, 
each consisting one group of clauses (that is, one specification case).  
ESC/Java2's static checker will accept a single specification case.
 For each specification case,
 a composite precondition predicate is 
formed by taking the conjunction of the predicates in each of the @code{requires}
clauses in that specification case, 
and making that conjunction the argument of an 
@code{\old} function:
@center{@emph{pre-predicate} = @code{\old(} @emph{p1} @code{&&} @emph{p2} ... @code{)} }.  
@*Each clause within the specification case is altered by
constraining its action using that conjunction.  Calling that combined predicate
@emph{pre-predicate}, we transform each clause as follows:
@itemize @bullet
@item @code{ensures} @emph{pred}@code{;}
@*becomes 
@*@code{ensures} @emph{pre-predicate} @code{==>} @emph{pred}@code{;}

@item @code{diverges} @emph{pred}@code{;}
@*becomes 
@*@code{diverges} @emph{pre-predicate} @code{==>} @emph{pred}@code{;}

@item @code{modifies} @emph{list}@code{;} 
@*where @emph{list} consists of a comma-separated
sequence of elements of the form 
@*@center{@emph{item}}
@* or 
@*@center{@emph{item} @code{if} @emph{pred}}
@* becomes a set of separate clauses of the form
@*@center{@code{modifies} @emph{item} @code{if} @emph{pre-predicate} @code{;}}
@*or 
@*@center{@code{modifies} @emph{item} @code{if} @emph{pre-predicate} @code{&&} @emph{pred}@code{;}}

@item @code{signals} (@emph{type} @emph{id} @code{)} @emph{pred}@code{;}
@*becomes
@*@code{signals} (@emph{type} @emph{id} @code{)} @emph{pre-predicate} @code{==>} @emph{pred}@code{;}
@item when -- [[[ complete this ]]]
@item accessible -- [[[ complete this ]]]
@item duration -- [[[ complete this ]]]
@item working_space -- [[[ complete this ]]]
@end itemize
The requires clauses are desugared by replacing all of the requires clauses in all
of the specification cases with a single requires clause whose predicate is the 
disjunction of the conjuctions formed for each specification case, 
without the enclosing
@code{\old}.  When the static checker creates a VC to be used as a precondition
for calling a method, it forms a disjunction of the requires clauses for the
method and all the declarations that it overrides. 

@end itemize

@subsection also

@itemize @bullet
@item @strong{Description:} JML allows multiple specifications for a single method;
these are separated and connected by the @code{also} keyword.  Furthermore, if
the method has additional specifications in an earlier source file in the refinement
sequence or attached to an overridden method in a super class or interface, then
the specification must begin with @code{also} to indicate that there are some
previous specifications of which the reader should be aware.

@item @strong{Status:} The use of @code{also} is completely implemented, with
desugaring occuring as described above.  [[[ Reporting the error for a missing or spurious
also is not implemented. ]]]

@item @strong{Differences from JML or Java:} None.

@item @strong{Comment:} This syntax for combining specifications is different than
and not backwards compatible with the syntax used in ESC/Java.  That tool did not
allow combining multiple specifications using @code{also} and did not support
refinement sequences.  Where there was inheritance of specification clauses from a
super class or interface, the keywords @code{also_requires}, @code{also_ensures}, 
@code{also_modifies}, and @code{also_exsures} were required.  These keywords are
not supported in ESC/Java2 and such specifications will need to be rewritten using
the new @code{also} syntax.
[[[ FIXME - this needs to be verified and some helpful error messages supplied.]]]
@end itemize

@subsection model_program

@itemize @bullet
@item @strong{Description:} Model programs are an alternate way to provide 
specifications for a method.  Rather than stating logical conditions that
the pre- and
post-states must satisfy, the behavior is specified by a @emph{model program},
which specifies the behavior using typical imperative programming constructs.
However, a model program allows some non-deterministic (and non-executable) 
constructs as well.  Note that there are a number of JML constructs which are only
used within model programs. These are described in [[[ Ref ]]].

@item @strong{Status:} Model programs are parsed and ignored.  They are permitted
as a specification case, as defined by JML.  Any constructs unique
to model programs are simply skipped over by the parser.

@item @strong{Differences from JML or Java:} None.

@item @strong{Comment:} [[[ FIXME - when model programs are supported more fully,
we will need to include descriptions of its unique statement types: 
abrupt_behavior, continues, choose, choose_if, breaks, returns, or ]]]
@end itemize


@subsection subclassing_contract
@itemize @bullet
@item @strong{Description:} A subclassing contract is a separate part of a method's
specification.  It may contain only
@code{measured_by}, @code{callable}, and @code{accessible} clauses.

@item @strong{Status:} Fully parsed [[[and typechecked???]]].  
No desugaring is needed as
there are no associated preconditions or nesting.
  The static checker does not do any
reasoning with the clauses of the subclassing contract.

@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection implies_that
@itemize @bullet
@item @strong{Description:} The @code{implies_that} keyword introduces
specification cases that are logical consequences of the usual behavior and lightweight
specifications.  They could be used as specifications to be checked in the same
way that the other specifications are.  Alternatively, it could be verified that
they are logical consequences of
 the other specifications; the results could then be used as 
additional useful statements of behavior; these in turn could
help with proofs involving use of
the method or constructor with which the @code{implies_that} specification
 is associated.

@item @strong{Status:} The specifications in an @code{implies_that} section are
parsed [[[and typechecked?]]], but not used within any static checking.

@item @strong{Differences from JML or Java:} None.

@end itemize


@subsection for_example specification
@itemize @bullet
@item @strong{Description:} The @code{for_example} keyword introduces 
specification cases that are useful and instructional examples for the reader of
the specifications.  Hence they must be logical consequences of the 
other
specifications.  Each case may be lightweight or be introduced by one of the
keywords @code{example}, @code{normal_example},
and @code{exceptional_example}; these keywords may have associated access modifiers
(@pxref{Access modifiers}).
@item @strong{Status:} The specifications in a @code{for_example} section are
parsed [[[and typechecked?]]], including the @code{example}, @code{normal_example},
and @code{exceptional_example} keywords.
However, they are not used within any static checking, nor is it 
verified that they follow from the other specifications.

@item @strong{Differences from JML or Java:} None.


@end itemize


@c ------ Annotation clauses for a method or constructor --------
@node Annotation clauses for a method or constructor, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Annotation clauses for a method or constructor

In this section we describe the clause types that may be part of specifications,
including @code{implies_that} and @code{for_example} sections, but not
@code{subclassing_contract} sections.  Note that some clauses have alternate 
keywords reflecting different personal preferences or different usages between
ESC/Java and other JML tools.  These alternates are complete synonyms.



@subsection forall
@itemize @bullet
@item @strong{Description:} description.... [[[ Needs description ]]]

@item @strong{Status:} Not implemented.

@item @strong{Differences from JML or Java:} bugs...


@end itemize

@subsection old
@itemize @bullet
@item @strong{Description:} description.... [[[ Needs description ]]]

@item @strong{Status:} Not implemented.

@item @strong{Differences from JML or Java:} bugs...


@end itemize


@subsection requires, requires_redundantly, pre, pre_redundantly
@itemize @bullet

@item @strong{Description:} A requires clause specifies a condition that must hold in the pre-state of the method.  The remaining 
clauses of the specification case
must hold whenever the requires clause (or the conjunction of multiple
requires clauses) holds.

@item @strong{Status:} The requires clause is implemented and is utilized by ESC/Java2
in generating verification conditions.
@item @strong{Differences from JML or Java:} ESC/Java2 will warn about the use of
instance variables in the precondition of a constructor (since those variables do
not yet exist prior to allocation); JML does not.
@end itemize

@subsection ensures, ensures_redundantly, post, post_redundantly
@itemize @bullet
@item @strong{Description:} An ensures clause states a condition that must hold in
the post-state of a method or constructor whenever the associated preconditions
hold in the pre-state and the method or constructor exits normally.

@item @strong{Status:} Implemented and used by the static checker.
@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection signals, signals_redundantly, @*exsures, exsures_redundantly
@itemize @bullet
@item @strong{Description:} A signals clause states a condition that must hold in
the post-state of a method or constructor whenever the associated preconditions
hold in the pre-state and the method or constructor exits with an exception of
(or a subclass of) the designated type.

@item @strong{Status:} Implemented and used by the static checker.

@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection modifies, modifiable, assignable, modifies_redundantly, modifiable_redundantly, assignable_redundantly
@itemize @bullet
@item @strong{Description:} The modifies clause indicates which memory locations
may be assigned within
 the associated routine when the routine is called in a pre-state
that satisfies the associated preconditions.  In JML a modifies clause may also
have its own conditional predicate that further constrains when the associated 
memory locations may be assigned.

@item @strong{Status:} Implemented and used by the static checker.  However, 
ESC/Java2 ignores the conditional predicate of a modifies clause.  Furthermore
ESC/Java2 (like ESC/Java) does not check at all that the modifies clause is valid
for the routine for which it is a specification.  It does use the modifies clause
when reasoning about other routines that use the routine in question.  
For example, given 

@example
int i;
int k;

//@@ modifies i;
void m() @{ i = 9; @}

//@@ modifies k;
void n() @{ i = 10; @}

void p() @{
        m();
        n();
@}
@end example
@noindent
ESC/Java2 does not complain that routine @code{n} actually does modify the field
@code{i}, even though it claims to modify only @code{k}.  Also, in reasoning about
method @code{p}, it will know that after the call to @code{m}, the field @code{i}
may have a value different from the value before the call of @code{m}; but because
@code{n} claims not to modify @code{i}, ESC/Java2 will presume that the value of
@code{i} after the call of @code{n} is the same as the value before the call.

Note also that the behavior in the absence of a @code{modifies} clause in ESC/Java2
(as in ESC/Java) is @code{modifies \nothing;}.  The default defined by JML is
@code{modifies \everythying}.

@item @strong{Differences from JML or Java:} JML has recently implemented data 
groups using the @code{in} and @code{maps} annotations.  JML allows these data
groups to be used in modifies clauses, but these are not yet 
handled by ESC/Java2.


@end itemize

@subsection diverges, diverges_redundantly
@itemize @bullet
@item @strong{Description:} This clause states a predicate that must hold 
(in the pre-state) if the
method never terminates (given that
the associated precondition holds in the pre-state).

@item @strong{Status:} Parsed and typechecked, but not used in any static checking.

@item @strong{Differences from JML or Java:} None.


@end itemize

@subsection when
@itemize @bullet
@item @strong{Description:} description.... [[[ description needed ]]]

@item @strong{Status:} Parsed and typechecked, but not used in any static checking.
@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection duration
@itemize @bullet
@item @strong{Description:} description....[[[ description needed ]]]

@item @strong{Status:} Parsed and typechecked but not used in any static checking.
@item @strong{Differences from JML or Java:} None.


@end itemize

@subsection working_space
@itemize @bullet
@item @strong{Description:} description....[[[ description needed ]]]

@item @strong{Status:} Parsed and typechecked, but not used in any static checking.

@item @strong{Differences from JML or Java:} None.


@end itemize

@subsection accessible
@itemize @bullet
@item @strong{Description:} description....[[[ description needed ]]]

@item @strong{Status:} status....  - status unknown

@item @strong{Differences from JML or Java:} bugs...


@end itemize

@subsection Redundancy
@itemize @bullet
@item @strong{Description:} Many clauses have a redundant form, indicated by 
using a keyword with a @strong{_redundantly} suffix.
The intention of these clauses is to indicate specifications that are implied by
other, nonredundant, specifications.  The writer may choose to include the
redundant specifications in order to point out some non-obvious implications of other
specifications, either to facilitate understanding by the reader or to assist the
prover in verifying conclusions.

Note that the implies_that and for_example specifications are additional forms of
redundancy.


@item @strong{Status:} Currently in ESC/Java2 a command-line option selects 
between using redundant specifications in the same way as nonredundant 
specifications (the default) or ignoring them (when the option @code{-noredundancy}
is chosen).
@end itemize

@section Subclassing contract clauses for a method or constructor
These clause types (and only these) may be present in a subclassing contract 
section of a method's specification.

@subsection measured_by
@itemize @bullet
@item @strong{Description:} description.... [[[ Description needed ]]]

@item @strong{Status:} Parsed and ignored.

@item @strong{Differences from JML or Java:} bugs...


@end itemize

@subsection callable
@itemize @bullet
@item @strong{Description:} description.... [[[ Description needed ]]]


@item @strong{Status:} Parsed and ignored.

@item @strong{Differences from JML or Java:} bugs...

@end itemize


@subsection accessible
@itemize @bullet
@item @strong{Description:} description....  [[[ Description needed ]]]

@item @strong{Status:} Parsed and ignored.

@item @strong{Differences from JML or Java:} bugs...
@end itemize


@c ------ Annotation modifiers for a method or constructor --------
@node Annotation modifiers for a method or constructor, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Annotation modifiers for a method or constructor

Annotation modifiers can appear between the last specification clause or  
javadoc comment and the type designator or class name that is part of the method
or constructor.  JML modifiers and Java modifiers may appear in any order.  Though
less common and not the usual style, ESC/Java2 (following ESC/Java) allows 
JML modifiers to appear after the
method declaration and before the opening left brace of the body or the terminating
semicolon if there is no body.

Besides the modifiers listed here, methods and constructors may also have the
access modifiers described in @ref{Access modifiers}.

@subsection pure (JML)
@itemize @bullet
@item @strong{Description:} The @code{pure} modifier applied to a
method indicates that the method does not assign to any 
non-local memory location during
its execution; it may not even modify and then restore the original value.  It is
equivalent to having no modifies clauses at all in the specification,
 except perhaps 
@*@center{@code{modifies \nothing;}}
@*In the case of a constructor, the only fields that may be modified are the fields
of the object itself, which are initialized as a result of the action of the 
constructor.  In this case the @code{pure} modifier is equivalent to 
specifications of the form
@*@center{@code{modifies this.*;}}
@*Note that if a method is declared pure, then all overriding methods are also pure,
whether or not they have an explicit declaration to that effect.

@item @strong{Status:} Fully supported.  [[[ Error checks for modifies clauses in
a pure routine are not enabled. ]]]

@item @strong{Differences from JML or Java:} None.

@end itemize


@subsection non_null (JML - methods only)
@itemize @bullet
@item @strong{Description:} Modifying a routine with the @code{non_null} modifier
is valid only for methods that return objects as return values (and not for 
constructors).  The modifier specifies that the return value is never null.  It is
equivalent to a specification of 
@*@center{@code{ensures \result != null; }}
@*added to each specification case of the method's specification in all of the
files of the refinement sequence (but not of a 
superclass's specification of that method).

Note that superclass and subclass declarations of a method each independently
may have or not have @code{non_null} declarations.  A method's implementation 
must satisfy the superclass specification and independently satisfy the subclass
specification.  There is a more thorough discussion in [[[ Ref ]]].

@item @strong{Status:} Parsed, typechecked and supported by the static checker.

@item @strong{Differences from JML or Java:} None.
@end itemize


@subsection helper (JML)
@itemize @bullet
@item @strong{Description:} This modifier indicates that the method or constructor
in question is used as an internal helper routine and that the method or constructor
is therefore not expected to satisfy any of the class-level invariants or
constraints, in either its pre-state or its post-state.  The method or constructor
is still expected to satisfy any specifications (e.g. ensures clauses) that are
explicitly associated with this method or constructor.

@item @strong{Status:} Parsed, typechecked and supported by the static checker.

@item @strong{Differences from JML or Java:} JML only allows private methods and
constructors to be helpers.  ESC/Java2 also allows any constructors, 
final methods or methods of
final classes to be helpers.  (ESC/Java2's rule is that only routines that cannot
be overridden may be helpers.)
@end itemize



@subsection final (Java - methods only)
@itemize @bullet
@item @strong{Description:} This Java modifier indicates that a method may not be
overridden.  It may also be applied to model methods.
@item @strong{Status:} Fully implemented.  This feature does not affect the
static checking; it simply produces a typechecking error if a final method is
overridden.

@item @strong{Differences from JML or Java:} None.
@end itemize

@subsection static (Java - methods only)
@itemize @bullet
@item @strong{Description:} @code{static} is a Java modifier (which may be used on
JML annotations as well) that indicates the declaration in question is a
member only
of the class and not of each instance of the class.  

@item @strong{Status:} Fully implemented.

@item @strong{Differences from JML or Java:} None.


@end itemize



@subsection synchronized (Java - methods only)
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize



@subsection native (Java - methods only)
@itemize @bullet
@item @strong{Description:} A native method is one whose implementation is 
provided outside of the Java language.  Consequently such a method will not have
an implementation.
@item @strong{Status:} Fully implemented.  The static checker will indicate that
the method passes its checks since there is no body to check.
@item @strong{Differences from JML or Java:} None.
@end itemize



@subsection strictfp (Java - methods only)
@itemize @bullet
@item @strong{Description:} This modifier indicates that all of the floating
point operations within the method must hold to strict semantics.
@item @strong{Status:} Parsed and ignored by ESC/Java2.  No static checking of
floating point semantics is performed.  Note that the Java Language
Specification stipulates that constructors may
be @code{strictfp} only by virtue of the entire class being declared
@code{strictfp}.
@item @strong{Differences from JML or Java:} None.
@end itemize

@c ------ Annotation modifiers for a field declaration --------
@node Annotation modifiers for a field declaration, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Annotation modifiers for a field declaration

A field declaration (including ghost and model field declarations)
may have both Java and JML modifiers and it may be followed by the 
field assertions, which are introduced by the @code{in} and @code{maps}
keywords.   In addition to the access modifiers (@pxref{Access modifiers}),
 the following modifiers are relevant to field declarations.

@subsection maps, \into (JML)
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. - Note that these @emph{follow} the declaration. Not really a modifier]]]
@item @strong{Status:} Parsed, not typechecked, and ignored.
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize


@subsection in (JML)
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. - Note that these @emph{follow} the declaration. Not really a modifier ]]]
@item @strong{Status:} Parsed, not typechecked, and ignored.
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize


@subsection non_null (JML)
@itemize @bullet
@item @strong{Description:} This modifier on a field declaration indicates that the
field in question never has a null value, after the object is constructed.  
It is equivalent to a class invariant
of the form
@*@center{@code{invariant @emph{field} != null;}}
@*with the same access modifiers as the field itself.

@item @strong{Status:} Fully implemented and supported by the static checker.
@item @strong{Differences from JML or Java:} None.
@end itemize

@subsection monitored (JML)
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize

@subsection uninitialized (JML)
@itemize @bullet
@item @strong{Description:} [[[ESC/Java does not allow this on a field declaration, but should it? ]]]
@item @strong{Status:} Not implemented.
@item @strong{Differences from JML or Java:} Not part of JML.
@end itemize

@subsection final (Java)
@itemize @bullet
@item @strong{Description:} This Java modifier indicates that the field it
modifies may not be assigned to.
@item @strong{Status:} It is supported by the ESC/Java2 parser and type checker.
It does not have any effect on the static checking.
@item @strong{Differences from JML or Java:} None.
@end itemize

@subsection volatile (Java)
@itemize @bullet
@item @strong{Description:} This Java modifier affects the optimizations that 
might be applied and the semantics of the order of writing the values of object
fields to memory.  It affects multi-threaded programs only.
@item @strong{Status:} Parsed but ignored by the static checker.
@item @strong{Differences from JML or Java:} None.
@end itemize

@subsection transient (Java)
@itemize @bullet
@item @strong{Description:} Fields designated @code{transient} are not saved as
part of an object's persistent state.
@item @strong{Status:} Parsed but ignored by the static checker.  Any implications
of this modifier would be part of the specifications of serialization for the 
object.
@item @strong{Differences from JML or Java:} None.
@end itemize

@subsection static (Java)
@itemize @bullet
@item @strong{Description:} @code{static} is a Java modifier (which may be used on
JML ghost and model field declarations as well)
 that indicates that the declaration in question is a member of the class
and not of each instance of the class.  

@item @strong{Status:} Fully implemented.

@item @strong{Differences from JML or Java:} None.


@end itemize


@subsection instance (JML)
@itemize @bullet
@item @strong{Description:} @code{instance} is a JML modifier that indicates the
opposite of @code{static}, that is, that the field in question is a member of each
instance of the object, not just of the class.  With in a class declaration,
field declarations are non-static by default (and @code{instance} is not needed).
However, within an interface, field declarations (including ghost and model
declarations) are @code{static} and @code{final} by default.  The
@code{instance} modifier may be applied to ghost or model field declarations in
an interface, making those fields non-static and non-final (unless also declared
@code{final}).  [[[ Check definitively where this may be used. ]]]

@item @strong{Status:} Not implemented, and, as of this writing, causes aborts.

@item @strong{Differences from JML or Java:} [[[ Verify that JML only allows
instance in interfaces, and only on ghost or model variables, and has the same
semantics with respect to final. ]]]


@end itemize

@section Annotation modifiers for formal parameters

These modifiers may precede 
the type name of a formal parameter within the 
declaration of the method or constructor.
[[[ Check whether JML modifiers may follow the type name or the identifier. ]]]

@subsection non_null (JML)
@itemize @bullet
@item @strong{Description:} Modifying a formal parameter with a @code{non_null}
modifier is equivalent to adding a precondition stating that the parameter is not
equal to @code{null} and requiring that any assignment to that variable 
assign a non-null value.  It is only legal for reference types, not for 
primitive types.  The non_null condition is in addition to the composite
specification formed from the complete refinement sequence.  Hence it is 
equivalent to adding a precondition requiring the parameter be non_null to the
desugared specification of the routine (as well as the conditions on subsequent
assignments within the body of the routine).

Note that superclass and subclass declarations of a method each independently
may have or not have @code{non_null} declarations.  A method's implementation 
must satisfy the superclass specification and independently satisfy the subclass
specification.  A more thorough discussion is given in [[[ Ref ]]].

@item @strong{Status:} The modifier is parsed, checked and supported by the
static checker.

@item @strong{Differences from JML or Java:} None known. [[[FIXME - does JML detect 
problems with overriding methods?]]].  ESC/Java forbad a redeclaration of @code{non_null} (on formal parameters)
in subclasses;  ESC/Java2 permits such redeclarations

@item @strong{Comment:} The original ESC/Java did not permit a subclass to modify a
formal parameter as @code{non_null} in an overriding declaration.  The 
declarations of the top-most declaration were used for all overriding declarations.
@end itemize

@subsection final (Java)
@itemize @bullet
@item @strong{Description:} This Java modifier indicates that a formal parameter
may not be the target of an assignment in the body of the routine.
@item @strong{Status:} Fully implemented.  This feature does not affect the
static checking; it simply produces a typechecking error if a final parameter is
the target of an assignment.  [[[ this error is not yet generated by ESC/Java2. ]]]

@item @strong{Differences from JML or Java:} None.
@end itemize


@section Annotation statements within the body of a method or constructor
These annotation statements may be intermixed with the statements within the
body of a method or constructor.  They may also be used within model programs.
@subsection assume, assume_redundantly
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize


@subsection assert, assert_redundantly
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize

@c ------ set --------
@node set, ???, ???, ???
@c  node-name,  next,  previous,  up
@subsection set
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize

@subsection unreachable
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize


@subsection hence_by
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize


@subsection loop_invariant, loop_invariant_redundantly, @*maintaining, maintaining_redundantly
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize

@subsection decreases, decreasing, decreases_redundantly, @*decreasing_redundantly
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize

@subsection ghost declarations
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize

@section Modifiers that may be applied to local declarations

Declarations within the body of a method, constructor or initialization code 
introduce local variables used only during the execution of that body of code.
Privacy modifiers, @code{static}, and @code{instance} are not applicable to these
declarations.  The following modifiers are allowed.

@subsection non_null (JML)

@itemize @bullet
@item @strong{Description:} A local declaration (including ghost and model declarations) 
of a variable of reference type
within the body of a method or 
constructor may be modified with the JML annotation @strong{non_null}.  This
requires that the initial value and any subsequently assigned value for that
variable must not be null.  [[[ must have an initializer ???]]]

@item @strong{Status:} Fully implemented (in ESC/Java and ESC/Java2).

@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection uninitialized (JML)
@itemize @bullet
@item @strong{Description:} This JML modifier may be applied to a local variable
declaration within the body of a block of code.  It indicates that although the
variable has been initialized with an initial value, it should be considered as
uninitialized.  That is, a warning will be issued if its value is used before having
been assigned a new value.

@item @strong{Status:} Implemented (as in ESC/Java).

@item @strong{Differences from JML or Java:} This modifier is not part of JML.
@end itemize


@section JML functions (extensions to expressions)

JML defines a number of new operators, functions, and other constructions for use within expressions
that are part of annotations.

@subsection New operators in JML
[[[FIXME - describe precendence]]]

@itemize @bullet

@cindex @code{<==>}
@item @code{<==>} : 
This operator (equivalence) takes two boolean arguments; it returns a boolean value of 
@code{true} if the two arguments are both @code{true} or both @code{false}, and 
@code{false} otherwise.  
It is fully implemented.

@cindex @code{<=!=>}
@item @code{<=!=>} : 
This operator (inequivalence) takes two boolean arguments; it returns a boolean value of 
@code{false} if the two arguments are both @code{true} or both @code{false}, and 
@code{true} otherwise.  @code{(A <==> B)} is equivalent to 
@code{!(A <=!=> B)}.
It is fully implemented.

@cindex @code{==>}
@item @code{==>} : 
This operator (implies) takes two boolean arguments and returns a boolean value of 
@code{true} if the first is @code{false} or the second is @code{true},
and returns @code{false} if the first is @code{true} and the second is @code{false}.  
It is fully implemented.

@cindex @code{<==}
@item @code{<==} : 
This operator (reverse implication, or explies) takes two boolean arguments and returns a boolean value of 
@code{true} if the second is @code{false} or the first is @code{true},
and returns @code{false} if the second is @code{true} and the first is @code{false}.  
@code{(A ==> B)} is equivalent to @code{(B <== A)}.
It is fully implemented.

@cindex @code{<:}
@item @code{<:} : 
This operator takes two arguments of type @code{\TYPE} (or, equivalently, of
type @code{java.lang.Class}); it returns @code{true}
if the left-hand argument is the same type as or a subtype of the right-hand
argument. 
It is fully implemented.

@cindex @code{<}
@cindex @code{<=}
@item @code{<} , @code{<=} : 
In addition to their usual meaning in Java (and corresponding meanings in JML), the
less-than and less-than-or-equal operators are used to compare locks.  Any object that is listed as a 
monitor (in a @code{monitors_for} clause) or is identified implicitly or 
explicitly in a Java synchronization statement is a lock,
in addition to its declared use as an object.  In order to reason about deadlocks,
the user must define a partial order on locks and have the code acquire the locks
only in increasing order.  The partial order may be defined using @code{axiom} clauses;
the operators are used to compare locks by this partial order.  
They take two locks as arguments and return
@code{true} if the left-hand object is less than (or less than or equal to,
respectively) the right-hand object according to the partial order axioms,
and returns @code{false} otherwise.
The comparison is independent of whether the locks have actually been acquired; 
the @code{\lockset} expression supplies that information.  The ESC/Java User's
Manual provides additional information and examples about Deadlock and Race detection.
These operators are fully implemented. [[[ Are they in JML ???]]]
@end itemize


@subsection New JML expressions (functions and values)

@itemize @bullet

@cindex \result
@item \result [[[ description, status, differences needed here ]]]

@cindex \old
@item \old [[[ description, status, differences needed here ]]]

@item \not_modified [[[ description, status, differences needed here ]]]

@item \fresh [[[ description, status, differences needed here ]]]
@item \reach [[[ description, status, differences needed here ]]] - deprecated
@item \duration - [[[ description, status, differences needed here ]]]
@item \space - [[[ description, status, differences needed here ]]]
@item \working_space - [[[ description, status, differences needed here ]]]

@item \nonnullelements - [[[ description, status, differences needed here ]]]
@item \typeof - [[[ description, status, differences needed here ]]]
@item \elemtype - [[[ description, status, differences needed here ]]]
@item \type - [[[ description, status, differences needed here ]]]

@item \is_initialized - [[[ description, status, differences needed here ]]]
@item \invariant_for - [[[ description, status, differences needed here ]]]
@item \lblneg - [[[ description, status, differences needed here ]]]
@item \lblpos - [[[ description, status, differences needed here ]]]

@item \lockset : This value has type @code{\LockSet}.  The value is the set of objects whose
locks are held by the current thread. 
@*@strong{Status:} This feature is fully implemented by ESC/Java2 (as inherited from ESC/Java).

@cindex @code{\max}
@item @code{\max} : This function takes an argument of type @code{\LockSet}.  
It returns an object of type @code{java.lang.Object}.  The result is one of the
elements of the argument; the function satisfies the following for any 
@code{\LockSet} @code{s} and Object @code{o} in @code{s}: @code{o <= \max(s)}.
@*@strong{Status:} This feature is fully implemented by ESC/Java2 (as inherited from ESC/Java).


@item Operators for overflow checking : These are under development in JML and are
not yet implemented in ESC/Java2.


@cindex informal predicate
@cindex (*
@cindex *)
@item @emph{informal predicate} : An informal predicate consists of text 
(not including newline or carriage return characters) enclosed
within the delimiters @code{(*} and @code{*)}.  Informal predicates are interpreted
as boolean expressions that are always true (independent of what the text may say!),
and they may only be used in 
contexts where a boolean expression is allowed. This feature is fully implemented
in ESC/Java2 (as well as ESC/Java).


@end itemize

@subsection New JML types

JML adds some new types that may be used as type names in declarations of
variables within annotations.

@itemize @bullet

@cindex @code{\TYPE}
@item @code{\TYPE} : This is a JML type name used to denote the type of type designations.
For example, @code{\typeof} and @code{\type} produce results of type @code{\TYPE}, 
and the @code{<:} operator takes arguments of type @code{\TYPE}.  Values of type
@code{\TYPE} can also be compared using the @code{==} operator.
@*@strong{Status:} This is fully implemented.  It is equivalent to using the
type @code{java.lang.Class}.  [[[  - cross comparisons are not implemented. ]]]

@cindex @code{\bigint}
@item @code{\bigint} : This is a new type name used in JML to denote an integral type 
equivalent to the mathematical integers.  That is, it has infinite range and no
underflow or overflow as a result of a fixed bit depth.
@*@strong{Status:} The type name is parsed but is equivalent to @code{long}.

@cindex @code{\real}
@item @code{\real} : This is a new type name used in JML to denote a type 
equivalent to the mathematical real numbers.  That is, it has infinite range 
and precision and no
underflow, overflow, or rounding error as do @code{float} and @code{double}.
@*@strong{Status:} The type name is parsed but is equivalent to @code{double}.

@cindex @code{\LockSet}
@item @code{\LockSet} : This type may not be named (there is no token @code{\LockSet}).  However the type is implicitly used as the type of the JML token
@code{\lockset} and as the type of the argument of @code{\max}.

@end itemize

@cindex quantified expressions
@cindex @code{\forall}
@cindex @code{\exists}
@cindex @code{\num_of}
@cindex @code{\max}
@cindex @code{\min}
@cindex @code{\sum}
@cindex @code{\product}
@subsection quantified expressions - \forall, \exists, \num_of, \max, \min, \sum, \product
As described in the JML documentation, quantified expressions take the form
@*@center{@code{( @emph{quantifier-keyword} @emph{type} @emph{idlist} ; @emph{range-expr} ; @emph{expr} )}}
@*or
@*@center{@code{( @emph{quantifier-keyword} @emph{type} @emph{idlist} ; ; @emph{expr} )}}
@*or
@*@center{@code{( @emph{quantifier-keyword} @emph{type} @emph{idlist} ; @emph{expr} )}}
@*The @emph{range-expr} is a boolean expression; its default value is @strong{true}.
The @emph{idlist} is a comma-separated list of identifiers; these are the bound
variables of the quantification.
@*@strong{Status:} 
@itemize @bullet
@item @code{\forall}, @code{\exists}: Fully implemented and used in static checking.
@item @code{\num_of}, @code{\max}, @code{\min}, @code{\sum}, @code{\product}:
 Parsed and ignored.  The expressions are translated to values of 0, and so may lead to unexpected results.
@end itemize
@noindent
@strong{Comment:} The keyword @code{\max} is used both as a quantifier and as
a function.  The parser is able to distinguish the two usages.

@subsection set comprehension
[[[ description, status, differences needed here ]]]


@subsection \not_specified
This may be used, within the guidelines of the JML grammar, as the predicate or
store-ref expression in a annotation clause.  It is equivalent to stating that there
is no specification of that clause type.
@*@strong{Status: } Not implemented.

@subsection \private_data
[[[ description, status, differences needed here ]]]


@subsection \other 
[[[ description, status, differences needed here ]]]


@subsection new instance expressions
[[[ description, status, differences needed here ]]]

@subsection new array expressions
[[[ description, status, differences needed here ]]]

@subsection Other Java operators and expression syntax
[[[ description, status, differences needed here ]]]

@section store-ref expressions

[[[ This whole section needs thorough correction and review ]]]

Some annotations require a list of @emph{store-ref expressions}, which are 
expressions whose value is a set of references to fields of classes or objects;
in particular, the value has type @code{org.jmlspecs.models.JMLObjectSet}.
For example, the @code{modifies} clause designates a set 
(that is, a @code{JMLObjectSet} of @emph{store-refs} that
are allowed to be assigned to within a method.  This section describes the 
syntactic features that designate such sets.  [[[ Not sure this is right in the
wake of data groups and in/maps clauses ]]]




@subsection [ @emph{ident} | @code{super} | @code{this} ] @code{.} [ @emph{ident} | @code{this} ]
This designates a field of an object.  [[[ Describe the function of the this suffix]]]
@*@strong{Status: } Implemented within modifies clauses.

@subsection [ @emph{ident} | @code{super} | @code{this} ] @code{.*}  
This designates all static and instance fields, of any privacy level, including
those inherited from superclasses and interfaces, of the given object.
@*@strong{Status: } Not implemented.

@subsection [ @emph{ident} | @code{super} | @code{this} ] @code{[@emph{expr}]}  
This designates an element of the given array object.   [[[ Describe the function of the this and super prefix ]]]
@*@strong{Status: } Implemented within modifies clauses.
Not
@subsection [ @emph{ident} | @code{super} | @code{this} ] @code{[@emph{expr}..@emph{expr2}]}  
This designates a range of elements of the given array object.
@*@strong{Status: } Not implemented.

@subsection [ @emph{ident} | @code{super} | @code{this} ] @code{[*]}  
This designates all the elements of the given array object.
@*@strong{Status: } Not implemented.

@subsection @emph{classname}.* 
This designates all static fields, of any privacy level, including
those in superclasses and interfaces, of the given class.
@*@strong{Status: } Not implemented.

@subsection \nothing 
This designates an empty set of store-refs.
@*@strong{Status: } Not implemented.

@subsection \everything 
This designates a universal set - the set of references to all object and class
fields for every object and class allocated in the current state of the program.
@*@strong{Status: } Not implemented.

@section Statements within model programs
A model program consists of imperative programming statements and control 
structures, much like a typical Java program.  However, a model program allows
some non-deterministic (and non-Java) statements as well.  These are described in 
this section.

[[[ Need enumeration and discussion of these. ]]]


@section Other issues
[[[ descriptions needed here ]]]

[[[ Use of JMLDataGroups in modifies clauses; what syntactic structures use stsore-refs? ]]]

@subsection nowarn annotations
JML allows an annotation to suppress warnings otherwise produced by the static checker.  These are discussed in @ref{Nowarn annotations and warnings}.

@c --------------------- Java and JML assert statements
@node Java and JML assert statements, ???, ???, ???
@subsection Java and JML assert statements

JML has an assert statement of the form
@*@center{@code{//@@ assert }@emph{predicate}@code{;}}
@*The static checker will evaluate the predicate in the appropriate context.  If it
cannot establish that the predicate is always true, an ESC/Java warning will be
issued.

Java 1.4 also has an assert statement with the syntax
@*@center{@code{assert }@emph{value}@code{: }@emph{predicate}@code{;}}
@*If the predicate is not true, then a @code{java.lang.AssertionError} is created,
with the given @emph{value} as its argument, and the exception is thrown.

In versions of Java before 1.4, @code{assert} was a legitimate identifier name; in
Java 1.4 it is a keyword and may not be used as an identifier.  To achieve
backwards compatibility, Java compilers have a @code{-source} command line option;
ESC/Java2 behaves in a way similar to typical Java compilers:
@itemize @bullet
@item specifying 
@code{-source 1.4} causes ESC/Java2 to interpret @code{assert} as a keyword;
@item 
omitting the @code{-source} option or specifying an argument other than @code{1.4}
causes ESC/Java2 to treat @code{assert} as an identifier and to issue errors
 on encountering uses
of the word as a keyword.
@end itemize

There are three options for how ESC/Java2 should treat Java @code{assert}
 statements (when @code{-source 1.4} is specified).  ESC/Java2 provides 
command-line options to achieve each of these behaviors.
@enumerate A
@item Parse but ignore them.
@item Treat them as Java does, namely, as equivalent to 
@*@center{@code{if ( ! }@emph{predicate}@code{) throw new java.lang.AssertionError(}@emph{value}@code{);}}
@item Treat them as a JML assert statement, namely, as equivalent to
@*@center{@code{//@@ assert }@emph{predicate}@code{;}}
@end enumerate
 

[[[ What are the command-line options ??? ]]]

Here are some examples of use:
@itemize @bullet
@item  
@example
        public void m() @{
                assert false : "Message";
        @} 
@end example
@noindent 
Java behavior: ESC/Java2 will issue an Unexpected Exception warning
@*JML behavior: ESC/Java2 will issue an Assert warning

@item  
@example
        public void m() @{
                assert false : "Message"; \\ nowarn;
        @} 
@end example
@noindent 
Java behavior: ESC/Java2 will issue an Unexpected Exception warning
@*JML behavior: ESC/Java2 will not issue any warning (suppressed by the nowarn annotation)

@item  
@example
        public void m() @{
                assert true : "Message";
        @} 
@end example
@noindent
Java behavior: No warnings - no exception ever thrown
@*JML behavior: No warnings - predicate is always true

@item  
@example
        //@ exsures (java.lang.AssertionError e) true;
        public void m() @{
                assert false : "Message";
        @} 
@end example
@noindent
Java behavior: ESC/Java2 will issue an Unexpected Exception warning
@*JML behavior: ESC/Java2 will issue an Assert warning
@* [[[ There may be a bug here - ESC/Java complains about types in an exsures
clause that are not in the throws list of the declaration, but ESC/Java2 does not.]]]

@item  
@example
        //@ exsures (java.lang.AssertionError e) true;
        public void m() throws AssertionError @{
                assert false : "Message"; 
        @} 
@end example
@noindent
Java behavior: No warnings - the exsures clause allows the exception.
@*JML behavior: Assert error.


@item  
@example
        //@ exsures (java.lang.AssertionError e) false;
        public void m() throws AssertionError @{
                assert false : "Message"; 
        @} 
@end example
@noindent
Java behavior: Postcondition warning - the exsures clause disallows the exception.
@*JML behavior: Assert error.


@end itemize

@subsection Methods and constructors without bodies in Java files

[[[ discussion needed ]]]

@subsection Methods and constructors in annotation expressions
[[[ description, status, differences needed here ]]]

@subsection  Original ESC/Java also_ specifications

[[[ discussion needed ]]]

@subsection  anonymous classes

[[[ discussion needed ]]]

@subsection  @code{field}, @code{method} and @code{constructor} keywords

[[[ discussion needed ]]]

@subsection exceptions in annotation expressions
[[[Discuss the behavior of logical and short-circuit operators in the presence of undefined expressions (or expressions that throw exceptions).]]]

@c ----------------------- Specifications and inheritance
@node Specifications and inheritance, ???,???,???
@subsection Specifications and inheritance

@subsubsection Desugaring in the presence of inheritance
ESC/Java has some limitations and some unsoundness in handling the inheritance of
specifications.  If a superclass stated a precondition (with a requires clause), 
then a subclass could not state an additional precondition.  If a superinterface
stated a precondition, an implementing class was permitted to state a precondition
using the @code{also_requires} keyword, but the discussion in the ESC/Java User's
Manual acknowledged this to be an unsound construct.

ESC/Java2 has corrected this problem by using the syntax and desugaring approach
outlined by JML.  JML allows subclasses to have additional @code{requires} clauses,
and does not utilize the @code{also_requires} syntax.
Consider the following example (the handling of super interfaces is the same as the
handling of super classes):
@example
public interface Super @{
        //@@    requires P1;
        //@@    ensures Q1;
        public void m();
@}

public class D extends Super @{
        //@@ also
        //@@    requires P3;
        //@@    requires PP3;
        //@@    ensures Q3;
        public void m();
@}
@end example
@noindent
Now ESC/Java would combine the interface and subclass specifications as follows:
@example
        //@@ requires P1;
        //@@ requires P3;
        //@@ requires PP3;
        //@@ ensures Q1;
        //@@ ensures Q3;
@end example
@noindent
This does not satisfy behavior inheritance.  The desugaring provided by ESC/Java2
is correct:
@example
        //@@ requires P1 || (P3 && PP3);
        //@@ ensures P1 ==> Q1;
        //@@ ensures (P3 && PP3) ==> Q3;
@end example

Here is a larger example:
@example
public class Super @{
        //@@    requires P1;
        //@@    ensures Q1;
        //@@ also
        //@@    requires P2;
        //@@    ensures Q2;
        public void m();
@}

public class D extends Super @{
        //@@ also
        //@@    requires P3;
        //@@    requires PP3;
        //@@    ensures Q3;
        //@@ also
        //@@    requires P4;
        //@@    ensures Q4;
        public void m();
@}
@end example
@noindent
The specifications in @code{Super} desugar (in ESC/Java2) to
@example
        //@@ requires P1 || P2;
        //@@ ensures P1 ==> Q1;
        //@@ ensures P2 ==> Q2;
@end example
@noindent
The specifications in @code{D} desugar to
@example
        //@@ requires (P3 && PP3) || P4;
        //@@ ensures  (P3 && PP3) ==> Q3;
        //@@ ensures  P4 ==> Q4;
@end example
@noindent
but they are then combined with the super class specifications to produce the composite specification:
@example
        //@@ requires P1 || P2 || (P3 && PP3) || P4;
        //@@ ensures  P1 ==> Q1;
        //@@ ensures  P2 ==> Q2;
        //@@ ensures  (P3 && PP3) ==> Q3;
        //@@ ensures  P4 ==> Q4;
@end example

With this approach the unsoundness of @code{requires} noted in section C.0.4 of the
ESC/Java User's Manual is corrected.  However, the behavior of some specifications
will change, since specifications of an overriding method are no longer 
simply textually conjoined with the specifications of an overridden method.  For
example in ESC/Java, the specification of @code{m()} in this code
@example
public class Super @{
        //@@ requires i > 0;
        public int m(int i) @{...@}
@}
public class D @{
        //@@ ensures \result > 0;
        public int m(int i) @{...@}
@}
@end example
@noindent
was interpreted as
@example
        //@@ requires i > 0;
        //@@ ensures \result > 0;
@end example
@noindent
whereas in ESC/Java2 it is
@example
        //@@ requires i > 0 || true;
        //@@ ensures i > 0 ==> true;
        //@@ ensures true ==> \result > 0;
@end example
@noindent
which is equivalent to
@example
        //@@ requires true;
        //@@ ensures \result > 0;
@end example

@cindex clause defaults
@cindex defaults
@cindex inheritance of specifications
@subsubsection Defaults and inheritance

The defaults for missing clauses were described in @ref{Lightweight and heavyweight specifications}. The effect of
the default for @code{requires} is demonstrated in these examples.

Given
@example
class Super @{
        //@@ requires P;
        //@@ ensures Q;
        public void m();
@}

class Derived extends Super @{
        // no spec given - default is 'requires false'
        public void m();
@}
@end example
@noindent the two classes behave as if they had these specifications
@example
class Super @{
        //@@ requires P;
        //@@ ensures P ==> Q;
        public void m();
@}

class Derived extends Super @{
        //@@ also
        //@@ requires P;
        //@@ ensures P ==> Q;
        public void m();
@}
@end example


Given
@example
class Super @{
        // no spec given - default is 'requires true'
        public void m();
@}

class Derived extends Super @{
        //@@ also
        //@@ requires P;
        //@@ ensures Q;
        public void m();
@}
@end example
@noindent the two classes behave as if they had these specifications
@example
class Super @{
        //@@ requires true;
        public void m();
@}

class Derived extends Super @{
        //@@ also
        //@@ requires true;
        //@@ ensures P ==> Q;
        public void m();
@}
@end example

Finally, given
@example
class Super @{
        // no spec given - default is 'requires true'
        public void m();
@}

class Derived extends Super @{
        // no spec given - default is 'requires false'
        public void m();
@}
@end example
@noindent the two classes behave as if they had these specifications
@example
class Super @{
        //@@ requires true;
        public void m();
@}

class Derived extends Super @{
        //@@ also
        //@@ requires true;
        public void m();
@}
@end example

[[[ What does jmlrac do with this issue?]]]

@subsubsection Inheritance and non_null

The syntactic rules and semantic meaning of 
@code{non_null} in the presence of inheritance
differ between ESC/Java and ESC/Java2.
A @code{non_null} annotation on a formal parameter is equivalent to 
(a) a requirement that the parameter not be assigned a null value in the body
of the implementation of the routine, and
(b) an additional
precondition in all of the specification cases of the method's (or constructor's)
specifications.  Item (b) means that
@example
... specifications ...
public void m(/*@@ non_null */ Object o, Object oo)
@end example
@noindent
is equivalent to
@example
//@@ requires o != null;
//@@ @{|
     ... specifications ...
//@@ |@}
@end example

Similarly a non_null annotation on the result is equivalent to an additional
post-condition:
@example
... specifications ...
public /*@@ non_null*/ Object m()
@end example
@noindent
is equivalent to
@example
//@@ ensures o != null;
//@@ @{|
     ... specifications ...
//@@ |@}
@end example
@noindent
[ This syntax is not legal JML since an ensures may not appear outside of the
nested specifications, but the intent is evident: the ensures clause is distributed
to each specification case. ]

Confusing situations can arise if formal parameters in a overridden and overiding
declaration differ in non_null annotations. 

@itemize @bullet
@item Case 1: Super class has non_null, subclass has a spec, but no non_null

@example
class Super @{
    public void nonnull(/*@@ non_null */ Object o);
        
    public void m(/*@@ non_null */ Object o) @{
        nonnull(o);           // Line A - OK
        o = null;             // Line B - FAILS
    @}
@}
class Derived extends S @{
    //@@ also
    //@@ requires true; 
    public void m(Object o) @{
        nonnull(o)            // Line C - FAILS
        o = null;             // Line D - OK
    @}
 
    public void mm() @{
        Object o;
        m(o);                 // Line E - OK
        (new S()).m(o);       // Line F - FAILS
    @}
@}
@end example
In this case, ESC/Java has @code{Derived.m} inherit the non_null specification from the
overridden method.  Hence ESC/Java reports errors for lines B, D, E and F, with A and C being OK.
In ESC/Java2, however, @code{Derived.m} has its own specification
and so does not inherit the non_null specification.
It must still satisfy the parent spec (which in this case simply has a trivial
postcondition).  So Lines B and F are errors and A is not.  However, the combined spec for
@code{Derived.m} is (ignoring other clause types)
@example
        requires o != null;
        ensures true;
        also
        requires true;
        ensures true;
@end example
which is equivalent to @code{requires true;}.  Thus lines D and E are OK, and C
will provoke an error.

If the precondition were @code{requires false;}, then the combined spec would be
@example
        requires o != null;
        ensures true;
        also
        requires false;
@end example
@noindent
which is equivalent to @code{requires o != null;}.  Then D and E would fail, and C
would be OK.  In otherwords, it is the same as Case 2 below.


 
@item Case 2: Super class has non_null, subclass has no spec and no non_null

@example
class Super @{
    public void nonnull(/*@@ non_null */ Object o);
        
    public void m(/*@@ non_null */ Object o) @{
        nonnull(o);           // Line A - OK
        o = null;             // Line B - FAILS
    @}
@}
class Derived extends S @{

    public void m(Object o) @{
        nonnull(o);           // Line C - OK
        o = null;   // Line D - FAILS [[[ Currently does not FAIL]]]
    @}

    public void mm() @{
        Object o;
        m(o);                 // Line E - FAILS
        (new S()).m(o);       // Line F - FAILS
    @}
@}
@end example
In this case Derived.m has no specification.  Consequently it has a default
specification of @code{requires false;} and effectively inherits the overridden
method's specification, including the @code{non_null}.
Lines B and F are still errors, and A is not, because of the specification of Super.m; 
lines D and E are errors, and C is not.
 
[[[ Open question about lines D; and ESC/Java2's implementation currently does not produce an error]]].

@item Case 3: Super class has no non_null, but subclass does

@example
class Super @{
    public void nonnull(/*@@ non_null */ Object o);
        
    public void m(Object o) @{
        nonnull(o);           // Line A - FAILS
        o = null;             // Line B - OK
    @}
@}
class Derived extends S @{

    public void m(/*@@ non_null */ Object o) @{
        nonnull(o);           // Line C - FAILS
        o = null;             // Line D - OK [[[ Currently FAILS ]]]
    @}
 
    public void mm() @{
        Object o;
        m(o);                 // Line E - OK
        (new S()).m(o);       // Line F - OK
    @}
@}
@end example
@noindent In this case, it is the derived class that has the @code{non_null} specification,
but not the super class.  ESC/Java does not allow overriding methods to have
non_null parameters (ESC/Java2 does).  

ESC/Java2 will allow lines B and F since the super class does not limit the values
of the parameter; similarly line A provokes an error.  Although the parameter of
@code{Derived.m} is declared @code{non_null}, the composite specification for
@code{Derived.m} is
@example
        requires true;
        also
        requires o != null;
@end example
@noindent
which is equivalent to @code{requires true;}.  Consequently, line C fails, but lines
D and E are acceptable.  This behavior on lines C, D and E is potentially confusing.
It results from the fact that the combined spec does not require 
@code{o != null;}.  [[[ Perhaps this case should be prohibited??? ]]]

[[[ The behavior of line D is open to question; ESC/Java2 currently produces an error here. ]]]

@end itemize

[[[ What does jmlrac do with the inheritance of non_null? ]]]

@chapter ESC/Java2 features

This chapter describes some of the features and usage of ESC/Java2.

@c ------ section Error and warning messages --------
@node Error and warning messages, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Error and warning messages

@cindex error messages
@cindex fatal errors
@cindex cautions
@cindex warnings
ESC/Java2 continues ESC/Java's use of four levels of error messages:
@itemize @bullet
@item  @strong{fatal} errors are problems (usually invalid syntax) that prevent 
ESC/Java from proceeding further in parsing and checking files;
@item  @strong{errors} indicate illegally formed input files, though processing may
continue to find other errors or even to attempt static checking of the files 
(errors or checks subsequent to the first problem may be erroneous as a result of
earlier problems);
@item  @strong{cautions} indicate situations that are not illegal, but may be
misleading to the user - a common example is features that are parsed 
but not checked (also some illegal JML constructs are reported using cautions if 
ESC/Java2 can unambiguously correct them);
@item  @strong{warnings} indicate situations in which the static checking phase could
not determine that annotation specifications were satisfied, such as an inability
to determine that an object reference is non-Null when it is dereferenced.
@end itemize
The reporting of cautions and warnings can be controlled by command-line options
 (@code{-noCautions}, @code{-nowarn}, @code{-warn}, @code{-nocheck}).

@c ------ Nowarn annotations and warnings --------
@node Nowarn annotations and warnings, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Nowarn annotations and warnings
@subsection nowarn annotations
@itemize @bullet
@item @strong{Description:} 
A nowarn annotation has the form
@*@center{@code{//@@ nowarn @emph{comma-separated-list-of-warning-types};}}
@*or simply
@*@center{@code{//@@ nowarn ;}}
@*The annotation is associated with the line in the source file on which it is located, rather 
than with a grammatical construct.  It is used to suppress warnings from the
static checker associated with a construct on that line.  If there is no list of
warning types, then all warnings associated with this line are suppressed.  
The warnings of a given type can also be suppressed using command-line options.
The nowarn annotations have no effect on errors or cautions, since these are
produced by parsing or semantic errors in the source code itself.

@item @strong{Status:} Implemented.

@item @strong{Differences from JML or Java:} JML supports the parsing of these
annotations, but since JML does no static checking, it ignores them.  ESC/Java
did not require a terminating semicolon, but JML does.  ESC/Java2 accepts 
nowarn annotations with or without a terminating semicolon; it issues a caution if the
semicolon is missing.  [[[ JML should allow a nowarn without a list to be 
terminated by an end of line. ]]]
@end itemize


@subsection nowarn warning types

The static checker used in ESC/Java2 (and in ESC/Java) produces warnings (as
opposed to errors or cautions) when it detects source code that might violate the
specifications.  These warnings are categorized into types and can be suppressed
or enabled by warning type name, using either the 
@code{nowarn} annotation or the command-line options @code{-nowarn}, which 
suppresses individual warning types, or @code{-warn}, which 
enables individual warning types, or @code{-nocheck}, which turns off all 
static checking.  The following list of the warning types is
excerpted (except where additions are explicitly noted) and quoted from the 
"ESC/Java User's Manual".

The additional warning pseudo-type name "All" may be used with the @code{-nowarn}
command-line option to turn off all warnings; @code{-warn} may then be used to
selectively turn on individual warning types.  The "All" type may not be used 
with @code{-warn}.

@itemize @bullet
@item
@strong{ArrayStore} warns that the control may reach an assignment
@code{A[I] = E} when the value of
@code{E} is not assignment compatible with
the actual element type of @code{A}.

@item
@strong{Assert} warns that control may reach a pragma 
@code{assert E} when the value of @code{E} is false.

@item
@strong{Cast} warns that control may reach a cast @code{(T)E}
when the value of @code{E} cannot be cast to the type @code{E}.

@item
@strong{Deadlock} warns that control may reach a @code{synchronized}
statement that would acquire a lock in violation of the locking order,
or that a @code{synchronized} method may start by acquiring a lock
in violation of the locking order.

@item
@strong{Exception} warns that a routine may terminate abruptly by
throwing an exception that is not an instance of any type listed explicitly
in the routine's throws clause.

@item
@strong{IndexNegative} warns that control may reach an array access
@code{A[I]}
when the value of the index
@code{I} is negative.

@item
@strong{IndexTooBig} warns that control may reach an array access
@code{A[I]}
when @code{A.length <= I}.

@item
@strong{Invariant} warns that some object invariant may not hold
when control reaches a routine call, or that some object invariant may
not hold on exit from the current body.

@item
@strong{LoopInv} warns that some loop invariant may not hold when
it is supposed to.

@item
@strong{OwnerNull} warns that a constructor may violate the implicit
postcondition @code{this.owner != null}.

@item
@strong{NegSize} warns of a possible attempt to allocate an array
of negative length.

@item
@strong{NonNull} warns of a possible attempt to assign the value
null to a variable whose declaration is modified by a @code{non_null}
pragma, or to call a routine with an actual parameter value of null when
the declaration of the corresponding formal parameter is modified by (or
inherits) a @code{non_null} pragma.

@item
@strong{NonNullInit} warns that a constructor may fail to establish
a non-null value for an instance field of the constructed object when the
declaration of that instance field is modified by a @code{non_null} pragma.

@item
@strong{Null} warns of a possible attempt to dereference null, for
example, by field access @code{O.f}, an array access @code{O[i]}, a
method call @code{O.m(...)}, a synchronized statement @code{synchronized
(O) ...}, or a throw statement @code{throw O}, where @code{O} evaluates
to @code{null}.

@item
@strong{Post} warns that a routine body may fail to establish some
normal postcondition (on terminating normally) or some exceptional postcondition
(when terminating by throwing an exception of a relevant type).

@item
@strong{Pre} warns that control may reach a routine call when some
precondition of the routine does not hold.

@item
@strong{Race} warns of a possible attempt to access a monitored
field while not holding the requisite lock(s).

@item
@strong{Reachable} warns that control may reach an @code{unreachable}
pragma.

@item
@strong{Uninit} warns that control may reach a read access to a
local variable before execution of any assignment to the variable other
than an initializer in a declaration modified by an @code{uninitialized}
pragma.

@item
@strong{Unreadable} warns that control may reach a read access of
a field or variable @code{x} when the expression in a @code{readable_if}
pragma modifying @code{x}'s declaration is false.

@item
@strong{ZeroDiv} warns of a possible attempt to apply the integer
division (@code{/}) or remainder (@code{%}) operator with zero as the
divisor.

@end itemize

@section Command-line options

ESC/Java2 has implemented a number of command-line options that are not present
in ESC/Java, as well as documenting some of those in ESC/Java.  ESC/Java2 also
kept many experimental (and undocumented) options from ESC/Java.  The following 
is a partial list of command-line options available in ESC/Java2; those not
labelled "ESC/Java2 only" were inherited from ESC/Java and are available in both 
tools, though the behavior may be slightly different.

@itemize
@cindex -bootclasspath
@item @code{-bootclasspath} @emph{directory-path} : specifies the location of 
system binary files; this directory path is appended to any specification for the
classpath in finding class files; the default is the platform-dependent classpath
specified by Java preferences (using the -v option will show the full classpath
being used)
@cindex -classpath
@cindex classpath
@item @code{-classpath} @emph{directory-path} : specifies the directories in which
binary (.class) files for types are sought; the default is to use the value of
the CLASSPATH environment variable, or to use just the current directory if 
neither -classpath nor CLASSPATH is specified [[[ What about java property ]]]
@cindex -help
@item @code{-help} : causes the program to print information about command-line options and then to terminate [ESC/Java2 only]
@cindex -noCautions
@cindex cautions
@item @code{-noCautions} : suppresses the reporting of any cautions
@cindex -nocheck
@item @code{-nocheck} : will not execute the static checking phase, though does all
the parsing, typechecking and verification condition generation
@cindex -nowarn
@item @code{-nowarn} @emph{warning-type} : turns off the reporting of warnings of the given type; use a warning-type of 'All' to turn off all warnings
@cindex -package
@item @code{-package} @emph{package-name} : includes all the source files in the given package in the list of source files being processed [ESC/Java2 only]
[[[ wihch suffixes ?]]]
@node -parsePlus, ???,???,???
@cindex -parsePlus
@item @code{-parsePlus} : causes ESC/Java2 to process annotations following
the markers @code{//+@@} and @code{/*+@@} (@pxref{Format of annotations}).
@cindex -quiet
@item @code{-quiet} : turns off any informational messages, leaving only reports of errors, warnings and cautions.
@cindex -source
@cindex 1.3
@cindex 1.4
@cindex assert
@item @code{-source} @emph{version} : interprets the source code according to the 
definition of Java for the given version.  The only implemented effect of this
option is the interpretation of @code{assert} as a keyword if the version is
@code{1.4} and as a normal identifier if the version is not @code{1.4}.  The default
is version @code{1.3}.  @xref{Java and JML assert statements}.
@cindex -sourcepath
@cindex sourcepath
@item @code{-sourcepath} @emph{directory-path} : specifies the directories in which
source and specification files for types are sought; the default is to use the 
classpath [ESC/Java2 only]

@cindex -v
@cindex verbose
@item @code{-v} : verbose output describing the steps of processing (ESC/Java2 has
added more output to that produced by ESC/Java)
@cindex -warn
@item @code{-warn} @emph{warning-type} : turns on the reporting of warnings of the given type

@item [[[FIXME - check for others to be documented]]]

@end itemize


@c -----------------------------------------------------------------------------
@chapter Changes to static checking in ESC/Java2

Most of the changes from ESC/Java to ESC/Java2 are changes to the parser so that
ESC/Java2 will parse and typecheck all of current JML, as well as being upgraded to
handle Java 1.3 and 1.4.  However, there are a few ways in which the static
checking has been modified.  They are described in this chapter.

@section Handling of specification inheritance

The semantics of the inheritance of specifications has changed from ESC/Java to 
ESC/Java2; ESC/Java2 now matches the semantics of JML.  The implementation 
required changes in the way that translation of specifications into guarded
commands is performed.  The change in semantics is described with 
examples in @ref{Specifications and inheritance}.

@section non_null

[[[ discussion needed ]]]

@section Translation of the Java 1.4 assert statement

The handling of the Java 1.4 assert statement is discussed in 
@ref{Java and JML assert statements}.
The assert statement is translated into equivalent Java or JML constructs and the
static checker is used without modification.

@section The initially clause

[[[ discussion needed - no change yet ]]]


@section The constraint clause

[[[ discussion needed - no change yet ]]]

@section defaults for modifies clauses

[[[ discussion needed ]]]

@section modifies \everything

[[[ discussion needed - no change yet ]]]

@section Checking of modifies

[[[ nothing yet, but I hope for it ]]]

@c [[[ methods in annotations - sure would be nice ]]]




@c -----------------------------------------------------------------------------
@chapter Incompatibilities

@section Major features of Java not implemented in ESC/Java2
[[[ Discussion needed for all of these]]]

@subsection inner and nested classes and interfaces
[[[ discussion needed ]]]

@subsection anonymous classes
[[[ discussion needed ]]]

@subsection serialization
[[[ discussion needed ]]]

@subsection most multi-threading considerations
[[[ discussion needed ]]]



@section Major features of JML not implemented in ESC/Java2
[[[ Discussion needed for all of these]]]


@subsection datagroups
[[[ discussion needed ]]]

@subsection subclassing contracts
These are parsed but not checked
[[[ discussion needed ]]]

@subsection any handling of implies_that and for_example behavior
These are parsed but not checked
[[[ discussion needed ]]]



@section Incompatibilities with ESC/Java
This section describes ESC/Java features that are not present or behave 
differently in ESC/Java2; ESC/Java2 has obviously made additions to ESC/Java
functionality.

@subsection Error messages and warnings
ESC/Java2 has added error messages to conform with current JML semantics.  
Some old ESC/Java errors and warnings are no longer appropriate and
have been removed.

[[[ FIXME - discussion needed ]]]

@subsection also
@subsection inheritance of specifications
@subsection non_null on formal parameters and results of routines
@subsection monitored_by
@subsection readable_if
@subsection initially (old style)

@subsection semicolon termination

@section Non-JML features in ESC/Java2

There are some syntactic constructs accepted by ESC/Java and continue to be 
accepted by ESC/Java2 that are not part of JML.

[[[ discussion needed - have not checked how some of these are used in ESC/Java, so
they may not be relevant to the discussion here.]]]

@subsection  loop_predicate
@subsection  \lblpos, \lblneg
@subsection  skolem_constant
@subsection  still_deferred
@subsection  writable_deferred
@subsection  writable_if
@subsection  readable_if
@subsection  dttfsa
@subsection  uninitialized
@subsection  placement of annotations
@subsection  semicolon termination
@subsection  need for the field, method, constructor keywords
[[[ ESC/Java2 parses non_null in method declarations ]]]




@c node  Concept Index,  , , Top
@c node-name, next, previous, up
@unnumbered Concept Index

@printindex cp

@bye

ISSUES:
- clause defaults
