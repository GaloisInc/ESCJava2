\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename Escjava2-ImplementationNotes.info
@settitle ESC/Java2 Implementation Notes
@c @setchapternewpage odd
@c %**end of header

@c FIXME - all the node lines need fixing
@c FIXME - indexing needs major work

@comment ----- title and copyright pages
@titlepage
@title ESC/Java2 Implementation Notes
@subtitle VERY MUCH A PRELIMINARY, INCOMPLETE DRAFT

@author David R. Cok
@email{cok@@frontiernet.net}

@sp 1


@center July 2003

@c [[[ Abstract ???]]]

@sp 2

@b{Keywords:}  Behavioral interface specification, Java,
JML, Escjava, ESC/Java, ESC/Java2, model-based specification, assertion,
precondition, postcondition, frame.

@b{2003 CR Categories:}
D.2.1 [@i{Software Engineering}]
        Requirements/Specifications --- languages, tools, theory,
        JML, ESC/Java, ESC/Java2;
D.2.4 [@i{Software Engineering}]
        Software/Program Verification --- assertion checkers, class invariants,
        formal methods, programming by contract;
F.3.1 [@i{Logics and Meanings of Programs}]
        Specifying and Verifying and Reasoning about Programs ---
                assertions, invariants, logics of programs,
                pre- and post-conditions, specification techniques.

@sp 1

Copyright @copyright{} 2003 David R. Cok


@sp 2



@sp 4
@*CVS Version: $Revision$
@*CVS Date: $Date$
@end titlepage

@contents

@synindex vr cp
@synindex fn cp
@synindex ky cp
@synindex tp cp

@c node  Top, Introduction, (dir), (dir)

@comment FIXME - the menu goes here


@c ------ NAME --------
@node NAME, ???, ???, ???
@c  node-name,  next,  previous,  up


@c ------ chapter Introduction --------
@c node Introduction, Acknowledgements, Top, Top
@c  node-name,  next,  previous,  up
@chapter Introduction

@c ------ section Motivation and Background --------
@c node Motivation and Background, Acknowledgements, Top, Top
@c  node-name,  next,  previous,  up
@section Motivation and Background


ESC/Java2 extends the pioneering work on ESC/Java by a group [[[ Ref needed ]]]
at the Systems
 Research Center at DEC, later Compaq, now HP [@url{www.research.compaq.com}]. 
ESC/Java parses 
JML-like annotations in a Java program and warns, in a modular way, about
annotations that may not be justified by the Java source of the given
classes and the specifications of other classes.  The program works accurately 
enough and
fast enough that it has been found to be a useful tool.
Its usefulness is diminished by limitations in the kind of annotations that it can 
parse and check and also in that its annotation language is similar to but 
is neither a subset nor a superset of JML.

The goal of the ESC/Java2 work is to extend the use of ESC/Java by
@enumerate a
@item updating the parser of ESC/Java so that it is consistent with the current definition of JML,
@item packaging the updated tool so that it is more easily available to a 
larger set of users,
 consistent with the source code license provisions of the ESC/Java source code,
@item and extending the range of JML annotations that can be checked by the tool,
where possible and where consistent with the engineering goals of
ESC/Java.
@end enumerate

This document records the status of this implementation.  It is not intended to be a
tutorial or a reference guide for either JML or ESC/Java or ESC/Java2.  Rather it records the status of the features of JML:
the status of their implementation in ESC/Java2,
the degree to which the annotation is
logically checked, and any differences between ESC/Java2 and JML.
@itemize @bullet
@item More detailed information on JML is available at the web site 
@uref{www.jmlspecs.org}; the details of the JML definition are published in 
"Preliminary Design of JML" (Leavens, Baker, Ruby) and in 
"The JML Reference Manual" (Leavens, Poll, Clifton, Cheon, Ruby),
both available from the JML website.
@item Information on the original ESC/Java tool, 
nearly all of which still applies, is provided in "ESC/Java User's Manual", 
SRC Technical note 2000-002 (Leino, Nelson, Saxe), 
available at 
@*@center{@uref{gatekeeper.dec.com/pub/DEC/SRC/technical-notes/SRC-2000-002.html}}.
@end itemize

@c ------ section Acknowledgements --------
@c node  Acknowledgements, ???, Top, Top
@c  node-name,  next,  previous,  up
@section Acknowledgements


To date, the work on ESC/Java2 has been carried out primarily by Joe Kiniry
(@uref{www.kindsoftware.com}) and David Cok. 
Gary Leavens has provided guidance on the semantics
 and the current and future state of JML.  
K. Rustan M. Leino has provided advice with respect to the original ESC/Java.

The work of producing ESC/Java2 stands on the very much more considerable 
effort of 
the ESC/Java team (led by Leino at DEC SRC) in conceiving of and 
producing ESC/Java, Simplify and related tools in the first place. 

It also is built upon the work in designing JML and providing tools for JML led
by Gary Leavens at Iowa State University, with contributions from several other
individuals and groups, as described on the JML web page.

@c ------ section Dependencies and license restrictions --------
@c node  Dependencies and license restrictions, ???, Top, Top
@c  node-name,  next,  previous,  up
@section Dependencies and license restrictions


The ESC/Java2 tool relies on the following software packages that are separately 
available and may have their own license restrictions.
@itemize @bullet
@cindex ESC/Java
@cindex Simplify
@item The original source for ESC/Java, Simplify and related tools, available at 
@*@center{@uref{www.research.compaq.com/downloads.html}}.

@cindex Mocha
@item Part of the Mocha tool from UCBerkeley (optional), available at
@*@center{@uref{www-cad.eecs.berkeley.edu/~mocha/download/j-mocha}}.

@cindex Simplify
@cindex CM3
@item The CM3 compiler for Modula-3, which is needed to build the Simplify tool,
available from @uref{www.elegosoft.com} or @uref{fink.sourceforge.net}.
@cindex JUnit
@item The testing framework JUnit version 3.8.1, available at 
@uref{www.junit.org}.

@cindex JML
@item ESC/Java2 does not depend on the JML tool set, but it is useful to use the
two in combination.  ESC/Java2 is obviously dependent on the grammar and semantics
of JML.  JML is available at @uref{www.jmlspecs.org}.
@end itemize

@c ---------Contacts ------------------
@section Contacts and information

Further information about JML and ESC/Java2 can be obtained from these sources.

@itemize @bullet
@item The JML web site:  @uref{www.jmlspecs.org}
@item The JML project on sourceforge: @uref{sourceforge.net/projects/jmlspecs}
@item The JML interest mailing list on sourceforge: 
        @*@center{@email{jmlspecs-interest@@lists.sourceforge.net}}
@item The JML development mailing list on sourceforge: 
        @*@center{@email{jmlspecs-developers@@lists.sourceforge.net}}
@item The ESC/Java2 mailing list on sourceforge: 
        @*@center{@email{jmlspecs-escjava@@lists.sourceforge.net}}
@end itemize

JML utilizes (the Java subset of) the multijava compiler.
Information about multijava can be obtained from these sources.
@itemize @bullet
@item The multijava website: @uref{www.multijava.org}
@item The multijava project on sourceforge: @uref{sourceforge.net/projects/multijava}
@end itemize

@c ------ chapter Status of JML features --------
@c node  Status of JML features, ???, Top, Top
@c  node-name,  next,  previous,  up
@chapter Status of JML features


ESC/Java2 parses correctly formatted JML files, with the exceptions 
described in this document.  
JML files must be correct Java source with correctly formatted annotations, which
appear to Java as comments.  Although ESC/Java2 does some error reporting 
during parsing,
it does not report all parsing errors in either Java or JML, 
nor does it necessarily 
terminate normally if the input is not legal Java/JML.  There are a number of tools 
supporting JML that can be used to check the well-formedness of the JML annotations
in a file; a Java compiler can be used to check the format of the Java source code.

The authors encourage any report of a legal Java/JML file that ESC/Java2 will not 
parse.  Furthermore, despite the caveat above, the authors do want ESC/Java2 to be a
useful tool; hence they are interested in examples of legal or illegal
 Java/JML source code 
that cause abnormal termination and in examples in which the absence of error 
messages or the occurrence of an inappropriate error message is 
misleading to the user.  Examples that generate unsound or incomplete behavior
beyond that already documented are also of interest.

The organization of ESC/Java2's error and warning messages is described in
@ref{Error and warning messages}.


@cindex file names
@cindex suffixes
@cindex refinement sequence
@c ------ File finding and refinement sequences --------
@node File finding and refinement sequences, ???, ???, ???
@c  node-name,  next,  previous,  up
@section File finding and refinement sequences

@cindex filenames
@cindex suffixes
JML follows Java conventions in file naming.  ESC/Java2 recognizes Java source
and class files organized into directory hierarchies matching the package 
definitions.  The file names themselves typically consist of a type name as a 
prefix and either @code{.java} or @code{.class} as a suffix.  Specification files
typically have the type name as a prefix and one of the specification suffixes
( .refines-java, .refines-spec, .refines-jml, .java, .spec, .jml, .java-refined,
.spec-refined, .jml-refined) as a suffix, though arbitrary suffixes are permitted.

@cindex classpath
@cindex sourcepath
The ESC/Java2 program
utilizes a classpath and a sourcepath, which are standard sequences of 
directories separated by a platform-dependent path separator character (a colon
on Linux and MacOSX, a semicolon on Windows).  The classpath is specified by the
-classpath command-line option, or by the CLASSPATH environment variable if no
command-line option is given, and is the just current working directory if neither
is specified.  The sourcepath is specified by the -sourcepath command-line option;
if that is not provided, the sourcepath is identical to the classpath.

@cindex -package
Files specified on the command-line are the files on which ESC/Java2 acts.  They
are found with respect to the current working directory (if the paths to the files
are relative paths).  If an entire package is
specified using the -package option, that package is found by looking in each of
the directories of the sourcepath in turn. [[[ which suffixes are used? ]]]

A file on the command-line is parsed to determine the package to which it 
belongs and the name of the type that it declares.  ESC/Java2 and JML tools then
use the following procedure to find the refinement sequence for the given fully
qualified type.  When the specifications of types referenced in files being
processed by ESC/Java2 are needed, they are found using the same procedure.

@itemize @bullet

@cindex MRCU
@cindex most-refined compilation unit
@item Search each directory of the sourcepath in turn, looking for the first
sourcepath directory containing a directory
hierarchy for the given package containing a file whose name
 has the type name as its prefix and one of the following suffixes:
 @code{.refines-java}, @code{.refines-spec}, @code{.refines-jml}, 
@code{.java}, @code{.spec}, @code{.jml}.  If the directory contains more than one
such file, the one with a suffix closest to the beginning of the list of suffixes
is used.  This file is called the @emph{Most-refined compilation unit} (MRCU).

@cindex refinement sequence
@item If the MRCU contains a @code{refine} statement, then the file named in it
is sought in the sourcepath in the same package as the MRCU.  It is an error if
a file named in a @code{refine} statement cannot be found in the sourcepath.  Files
found in this way are parsed in turn and the files named in each @code{refine} 
statement are sought.  This procedure is repeated recursively until a file is found
that has no @code{refine} statement.  The sequence of files so found is called the
@emph{refinement sequence}.  The refinement sequence may contain the .java or the
.class file.  Any .class file must be last in the sequence.

@item The rules above do not restrict the filenames of the files of the 
refinement sequence, other than that they must be in the same package (but not
necessarily in the same directory).  In particular, aside from the suffix for the
MRCU (and java and class files), 
there is no restriction on the suffixes that the files may have, nor on the
order of suffixes in the refinement sequence.  There is also no restriction on
the prefixes of the file names, other than that the MRCU, the .java file and the
.class file must have the typename as the prefix.  However, it is good style if
all of the files in the refinement sequence have the same prefix.  If a file has
a filename prefix that does not match the type declared within it, it is in danger
of being misinterpreted as belonging to a different type.  Consequently a 
caution is issued to the user if this situation is discovered.

@item Once an MRCU is found, the remainder of the refinement sequence is determined
by the @code{refine} statements.  But which file is found as the MRCU may depend 
on the contents @emph{and order} of the directories in the sourcepath.  This 
order dependence is by design as it is thought that the user may use this feature
to choose different starting points along the refinement sequence for processing.
It may also lead to inadvertent errors.

@item It is an error if the sequence of refine statements defines a circular
sequence of refinement files.

@item The .java source file and the .class file for the given fully-qualified type
are found as defined by Java, independently of determining the refinement
sequence, using the sourcepath and the classpath, respectively.

@item Note that if the .java file declares more than one type, then the
corresponding refinement sequence must contain the specifications for all of the
declared types.

@item The specifications for the classes declared in the files 
of a refinement sequence are the combination
of the specifications in all the files of the refinement sequence.  The Java
signature of the classes is obtained from the relevant .java or .class files.
The source code implementation of the classes is determined from the .java file.
If no .java file exists (or it does not contain an implementation of a method), then
the check of that method will be a trivial pass; the usage of the method in other
implementations will still be performed.

@item It may be that a refinement sequence exists and does not contain the file
specified on the command-line.  ESC/Java2 issues a caution to the user in this case.  However, if 
no refinement sequence is found, no caution is issued even if the command-line
file is not on the sourcepath; it is simply used as the specification of the 
declared classes.

@item It may be that the refinement sequence exists, and a corresponding .java file
exists in the sourcepath, but the refinement sequence does not contain the 
 .java file.  In this case the .java file is used as the source code
of the implementation and to define the signature of the class, 
but no specifications are obtained from it.  A caution is
issued to the user in this case.

@item It is not required that a .java or a .class file exist, since it is 
desired to be able to write specifications in advance of an implementation.  
However, if either one does exist then the following rules are used:
@enumerate a
@item if only a signature is needed, the most recently modified of the two is used to 
define the Java signature of the class (whether or not it is in the refinement
sequence).  Specifications are not permitted to add
new (non-model, non-ghost) declarations of fields, routines, or enclosed classes or
interfaces to those defined in the Java implementation.
@item if the implementation is needed (because this is a type whose implementation
is being checked by ESC/Java2) as well as the signature, 
then the .java file is used regardless of time stamp, if it exists.
@end enumerate

@item Currently, .class files do not contain specifications.  However, we would
like to leave open the possibility that in the future a binary version of parsed
and checked specifications could be created that would improve processing time.

@end itemize 

@noindent
@strong{Status: }  The above rules are implemented in ESC/Java2 with the following
exceptions.
@itemize @bullet
@item ESC/Java2 does not yet use the search order for the MRCU as described.
Rather it finds the file with the most active suffix anywhere in the sourcepath,
regardless of its position in the sourcepath.
@item ESC/Java2 chooses the .java file over the .class file regardless of time stamp, if both exist.
@item When finding the package named in the -package option, ESC/Java2 combines
all of the packages by that name in any directory of the sourcepath, rather than
just using the first one.
@item If a refinement sequence declares more than one type, and no .java file
exists, the .class file is used.  But the binary versions of the various types
are in different .class files.  At present only the .class file with matching 
prefix is used.
@item [[[ Check the caution for CL file not in the RS - OK]]]
@item [[[ Check the caution for the Java file not in the RS -OK ]]]
@item [[[ Check the caution if a misnamed file is found in the RS. - OK]]]
@item [[[ Check that there is an error if a 'refine' file cannot be found. - OK ]]]
@item [[[ Check that the sourcepath is actually defined and used. - OK]]]
@item [[[ Can ESC/Java2 handle refining a class? multiple classes from one file?  ]]]

@item [[[ Should we have an option to find MRCUs with any suffix? ]]]
@item [[[ Should we have an option to find the whole chain whatever the order of the sourcepath and suffixes?]]]
@item [[[ Should we have an option to change/expand the list of MRCU suffixes? ]]]
@item [[[ Should we have an option to define 'implicit' refine statements, in order
for example, to connect specification files to implementation files, when the 
implementation files suddenly become available and we don't want to edit all of the
files? ]]]
@end itemize

@c ------ Format of annotations --------
@node Format of annotations, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Format of annotations

@cindex format of annotations
@cindex annotation markers
@cindex comments, annotation
@cindex @code{//@@}
@cindex @code{//+@@}
@cindex @code{/*@@}
@cindex @code{/*+@@}
@cindex @code{*/}
@cindex @code{@@*/}
@cindex @code{@@+*/}
@itemize @bullet
@item @strong{Comment format:} JML annotations are included in a Java program as 
specially formatted comments.  
In particular, JML annotations recognized by ESC/Java2 are either
@itemize @bullet

@item single-line comments beginning with @code{//@@}, or

@item multi-line comments enclosed between @code{/*@@} and either 
@code{*/} or @code{@@*/} , or

@cindex @code{<esc>}
@cindex @code{<ESC>}
@cindex @code{<jml>}
@cindex @code{<JML>}

@item annotations embedded in a javadoc comment between any of the 
four pairs of markers
@code{<esc>} and @code{</esc>}, 
@code{<ESC>} and @code{</ESC>}, 
@code{<jml>} and @code{</jml>}, or
@code{<JML>} and @code{</JML>}.
The original ESC/Java only recognized the first pair.  These annotation pairs
may not be nested, but there may be multiple annotations in sequence.  ESC/Java2
and JML do not restrict where in the javadoc comment an annotation may occur.
However, javadoc requires the annotation to be
a part of the textual description and to precede any tag descriptions that are
part of the comment.  The jmldoc tool allows multiple annotations to be intermixed
with the tag descriptions.  Neither ESC/Java2 nor the JML tools require the annotation
to be enclosed between @code{<pre>} and @code{</pre>} tags;
however, if you expect reasonable formatting in a javadoc produced HTML
page, you will likely wish to do so.  The jmldoc tool does not require 
@code{<pre>} and @code{</pre>} tags to produce good
formatting.
@end itemize
Both the JML tools and ESC/Java2 allow multiple @@ symbols in the opening 
comment markers (e.g. @code{//@@@@@@@@} is equivalent to @code{//@@}).

Note that JML recognizes additional annotations in these forms:
@itemize @bullet

@item single-line comments beginning with @code{//+@@} ;

@item multi-line comments enclosed between @code{/*+@@} and either 
@code{*/} or @code{@@*/} or @code{@@+*/} ;

@end itemize
These latter forms are part of JML but not ESC/Java2 to allow for syntax defined by
JML but ignored by ESC/Java2.  It is hoped that the result of the current work on
ESC/Java2 will diminish the need for the JML-only comments.  They may remain useful
as a way to retain JML annotations that are not processed (though they could be)
by ESC/Java2.
@*@strong{Status: } All of these annotation markers are implemented.  At present 
the embedded annotations using @code{<jml>} and @code{<JML>} are not parsed by
ESC/Java2 (unless @code{-parsePlus} is specified as described below), but that 
behavior is expected eventually to change.
@*@strong{Differences:} Both ESC/Java2 and JML tools allow
 multiple @@ symbols in any of the opening
 annotation markers (@code{//@@}, @code{//+@@},
@code{/*@@}, @code{/*+@@}),
but only ESC/Java2 allows multiple @@ symbols in the closing annotation markers
(@code{@@*/} and @code{@@+*/}).



@item @strong{-parsePlus option:} The @code{-parsePlus} command-line option
instructs ESC/Java2 to parse all annotations recognized by JML.  This is used mainly
in testing to find and attempt to process the JML-only annotations, but may be
 useful in other circumstances. @xref{-parsePlus}.

@item @strong{Initial `@@' symbols in annotations:} Within a multi-line annotation,
 a sequence of `@@' symbols
that follow whitespace at the beginning of a line are treated as white space.
Within an annotation embedded in a Javadoc comment, a sequence of `*' symbols
(but not `@@' symbols)
that follow whitespace at the beginning of a line are treated as white space.

@item @strong{Splitting annotations across comments:} 
 JML will correctly parse and process
 annotations that are split across multiple comments (e.g. a multi-line annotation
 in which each line begins with @code{//@@}).  ESC/Java2 expects an annotation
 to be entirely contained within one single- or multi-line comment.  The latter
 behavior is `correct' JML; however, the JML tools will correctly process and not
 warn about annotations split across multiple comments. 
 To be specific: 
@itemize @bullet
@item ESC/Java2 requires that any
 clause beginning with a keyword (e.g. invariant, requires)
and ending with a semicolon must be contained 
 within one annotation comment.  For example, write
@example
//@@ requires i != 0 && j != 0;
@end example
@noindent
or
@example
/*@@ requires i != 0 &&
  @@          j != 0;
  @@*/
@end example
@noindent not
@example
//@@ requires i != 0 && 
//@@          j != 0;   
@end example
@item ESC/Java2 requires that model methods, model
 constructors and model programs be defined within one annotation comment.
 For example, write
 @example
 /*@@ public model int m(int i, int j) @{
          return i+j;
      @}
  @@*/
@end example
@noindent not
@example
//@@ public
//@@ model int m(int i, int j) @{
//@@          return i+j;
//@@ @}
@end example
@item The tool also requires that a Java modifier 
 (e.g. @code{public}) be in the
 same comment as a JML annotation (e.g. @code{behavior} or model method) that it modifies.  For example, write
@example
//@@ public behavior
@end example
@noindent not
@example
//@@ public
//@@ behavior
@end example
@item Finally, any @code{in} or @code{maps} clauses following a ghost or 
model field declaration must be within the same annotation comment as the
declaration.  Thus, write
@example
//@@ ghost T t; in a;
@end example
@noindent not
@example
//@@ ghost T t;
//@@ in a;
@end example
@end itemize

Thus, @code{requires} and @code{ensures} clauses must each be wholly within
 a single annotation comment; individual keywords such as @code{pure}, @code{normal_behavior},
 @code{also}, @code{@{|}
 or @code{implies_that} may be in annotation comments by themselves (with any relevant
access modifiers).
 [[[ FIXME - JML rules need to be clarified.]]]
 
@item @strong{Multiple annotations per comment:} It is legal JML to include multiple
annotations per comment; in fact it is common practice and good style to include
many related annotations within one multi-line comment.  ESC/Java2 supports this
practice (though ESC/Java had some difficulties).  

@item @strong{Terminating semicolons:} JML requires annotations to be terminated by
semicolons.  The original ESC/Java did not.  The absence of semicolons is illegal
JML, but is sometimes tolerated by ESC/Java2. ESC/Java2 will warn if a semicolon
is missing. [[[ But does not yet do so to avoid problems with old tests. ]]]

@end itemize



@section Compilation unit annotations
Compilation unit annotations are placed prior to the declaration of any type within 
a file.

@subsection refine statements
@itemize @bullet
@item @strong{Description:} A JML refine statement indicates that the containing 
compilation unit adds additional
specifications to those contained in the referenced file.  If present, it must
be located after any Java package statement and before any Java or model import 
statements.
It has the form
@*@center{@code{//@@ refine "}@emph{filename}@code{";}}
@*The refine statements define a @emph{refinement sequence} as described in
@ref{File finding and refinement sequences}.  
Here we focus on the combining of the compilation units in
a refinement sequence to produce a single set of specifications for a type.  Each
compilation unit has its own set of declarations and specifications, all of which
must be consistent.  They are subject to the following rules, violations of which
provoke error messages.
@itemize @bullet

@item All files of the refinement sequence must belong to the same package (though
not necessarily the same directory); the type names of the declared types must be
identical (including case).

@item If a .java or a .class file exists for a type, the specifications may not add any Java (that is, non-model, non-ghost) declarations to the signature.  They may 
only repeat declarations.

@item If a field is redeclared, it must be redeclared with the same type and the
same Java modifiers.  An initializer may be present only in the .java file.

@item These JML modifiers must be consistent across all redeclarations
of a field:
@code{model}, @code{ghost}, @code{instance}.  The modifiers 
@code{spec_public}, @code{spec_protected}, @code{non_null} and
@code{monitored} may be added by a refinement file, but may not be removed.

@item If a method or constructor is redeclared, it must be redeclared with the
same return type, the same Java modifiers, and the same names for its formal
parameters.  An implementation may be present only in the .java file. (The
restriction on the formal parameter names is to simplify reading and to avoid
having the implementation have to rename variables in specifications.)

@item These JML modifiers must be consistent across all method and constructor
redeclarations: @code{model}.  These JML modifiers may be added by a refinement
but may not be removed: @code{spec_public}, @code{spec_protected}, @code{helper},
@code{non_null}, @code{pure}.

@item The Java modifier @code{final}, as applied to a formal parameter, must be
consistent across all redeclarations of a method or constructor.  The JML 
modifier @code{non_null} may be added, but not removed.

@item If a refinement file redeclares a method or constructor from a previous
refinement, or if the method is overriding a method in a super class or interface,
the specification for that redeclared or overriding method must begin with 
`@code{also}' (and may begin with `@code{also}' only when those conditions are
satisfied).

@item A type redeclaration must have the same set of Java modifiers.  In addition
the JML modifier @code{model} must be consistent; the JML modifiers @code{pure},
@code{spec_public}, and @code{spec_protected} 
may be added by a refinement but not removed.

@end itemize


@item @strong{Status:} The refine statement is implemented in ESC/Java2.
[[[ Check that all the rules above are enforced. They are not all yet.]]]

@item @strong{Comment on combining refinements:} There are (at least) 3 ways to
carry out the combining of refinements 
@enumerate a
@item by syntactically combining the 
relevant text
@item by typechecking each compilation unit independently and then combining the signatures
@item by typechecking each compilation unit in turn, in the context of the 
compilation units it is refining
@end enumerate

[[[ Discuss implications and differences.  ESC/Java2 uses (a). ]]]

@end itemize

@subsection model import statements
@itemize @bullet
@item @strong{Description:}
A model import statement has the form
@*@center{@code{//@@ model }@emph{java-import-statement}@code{;}}
@*Note that simply writing
@*@center{@code{//@@ }@emph{java-import-statement}@code{;}}
@*is not legal JML.
A model import statement may occur wherever a Java import statement may be placed.
A model import statement introduces types that are used only by annotations.
Annotations may also use types introduced by Java import statements.

@item @strong{Status:}  Model import statements are fully implemented.

@item @strong{Differences from JML or Java:}  This feature is implemented in 
ESC/Java2 as it is in JML.  However, both have the following problem.  The
model import statements are
 parsed by JML tools and by
ESC/Java2 as if they were Java import statements.  Thus they may introduce or resolve
an ambiguity in class name resolution of names used in the Java source code in a
compilation unit, or cause misinterpretation of a type name.  For example, in
@example
import java.io.*;
//@@ model import myclasses.File;
public class C extends File @{@}
@end example
@noindent
the use of @code{File} as the superclass is interpreted as @code{java.io.File}
by the Java compiler but as @code{myclasses.File} by JML tools and ESC/Java2.
Similarly, in
@example
import java.io.*;
//@@ model import myclasses.*; // class myclasses.File exists
public class C extends File @{@}
@end example
@noindent
the use of @code{File} is interpreted as @code{java.io.File} by a Java compiler
but will be deemed ambiguous between @code{java.io.File} and @code{myclasses.File} 
by the JML and ESC/Java tools.
These are as yet unresolved bugs.


@item @strong{Comment:} Though legal, there is no point to a statement of the form
@*@center{@code{/*@@ model @@*/ import }@emph{typename}@code{;}}
@* This is equivalent to simply using a Java import statement.
@end itemize

@cindex public
@cindex protected
@cindex private
@cindex spec_public
@cindex spec_protected
@c ------ section Access modifiers --------
@node Access modifiers, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Access (privacy) modifiers
Java allows the programmer to modify fields, methods,
constructors, class and interface declarations with one of the privacy or
 access modifiers @code{public}, @code{protected}, @code{private} or to omit these
 implying default (or package) access.  These modifiers affect the visibility of
 the associated declaration to other classes.  ESC/Java issues compile-time errors
 for (some) misuses of access, but the access of any given syntactic entity does not
 affect the static checking that is performed.
 
 JML also imposes some rules about access modifiers.  Some JML constructs also
 are allowed to be modified by an access modifier: the class-level
 clauses described in @ref{Annotation clauses for a class or interface}, such as @code{invariant}),
 and the behavior and example keywords 
 (@code{behavior}, @code{normal_behavior}, @code{exceptional_behavior}, 
 @code{example},
 @code{normal_example}, and @code{exceptional_example}).  In addition the method-level
 clauses (e.g. @code{requires}, @pxref{Annotation clauses for a method or constructor}) are assigned the privacy level of the behavior case
 of which they are a part (if in a heavyweight specification case) or the privacy
 level of the method they modify (if in a lightweight specification case).
 A specification clause may not use program entities with
 tighter access restrictions than it itself has.  For example, a requires clause in
 a protected @code{normal_behavior} specification case may not use @code{private}
 fields.
 
 Java program constructs that may be modified with an access modifier may also be
 modified with one or the other of @code{spec_public} and @code{spec_protected}.
 A program construct modified with @code{spec_public} is considered to have
 public access for any specification and may be used in any 
 specification clause; a program construct modified with @code{spec_protected}
 may be used in any non-public specification clause.  JML constructs may not be
 modified with @code{spec_public} or @code{spec_protected}.
 
 Note that @code{spec_public}, but not
@code{spec_protected}, was present in ESC/Java

 
@noindent
@strong{Status:} Parsing and type checking of access modifiers
are fully implemented.  The access
modifiers do not affect static checking.  [[[ Need to verify checks for spec_public and spec_protected, and access checks
 in general. - Behavior sections do not retain or use their access modifiers.  ALso ghost and model fields/routines]]]
 


@section Type modifiers

A class may be modified with the Java modifiers @code{public}, @code{protected},
@code{private}, @code{static}, @code{final}, @code{abstract} and @code{strictfp} and the JML 
modifier @code{pure}.  An interface may be modified with the
Java modifiers @code{public}, @code{protected},
@code{private}, @code{static}, @code{strictfp} and the JML 
modifiers @code{pure}, @code{spec_public}, @code{spec_protected}.  The access modifiers are described in 
@ref{Access modifiers}.
  In addition the superclass and
super interfaces may be modified with the keyword @code{weakly}.


@subsection pure (JML)
@itemize @bullet
@item @strong{Description:} The @code{pure} modifier, when applied to a class or
interface, indicates that every method of the class or interface is @code{pure}.
Thus, no method may assign to variables other than those declared within the body
of the routine.  Constructors may only assign to the fields of the object
being constructed.

@item @strong{Status:} Parsed and fully implemented.

@item @strong{Differences from JML or Java:} None.

@item @strong{Comment:} A method inherits purity from the methods it overrides;
that is, if an overridden method is pure, the overriding method will be pure
whether or not it is declared pure.  This is not the case for classes or 
for interfaces.  A subclass may add non-pure methods, even if it has a pure
superclass.  Declaring a class pure is precisely equivalent to declaring all of its
methods and constructors pure. [[[ Verify with JML]]]

@end itemize


@subsection weakly (JML)

@itemize @bullet
@item @strong{Description:} This annotation is used to modify super classes and 
super interfaces in a class
or interface declaration.  An example of its syntax is this:
@example
   public class A extends B /*@@ weakly */ 
      implements C /*@@ weakly */, D /*@@ weakly */ @{ ... @}
@end example
@noindent
@*[[[ Need a description of the semantics ]]]

@item @strong{Status:} Parsed and ignored by ESC/Java2.

@item @strong{Differences from JML or Java:} Parsed but ignored by ESC/Java2.
  This 
feature is not present in ESC/Java.

@end itemize

@subsection final (Java)

@itemize @bullet
@item @strong{Description:} A final class may not have subclasses.
@item @strong{Status:} This modifier is parsed and checked.  It does not need
any static checking.
@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection abstract (Java)

@itemize @bullet
@item @strong{Description:} A class must be declared abstract if it has abstract
methods.  An abstract class may not be instantiated; only non-abstract subclasses
of an abstract class may be instantiated.  All interfaces are by definition
abstract; using the @code{abstract} modifier on an interface has been deprecated.

@item @strong{Status:} This modifier is parsed and checked.  It does not need
any static checking.
@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection strictfp (Java)

@itemize @bullet
@item @strong{Description:} The @code{strictfp} modifier determines the semantics
of floating point operations within
the class so modified.

@item @strong{Status:} This modifier is parsed and typechecked.  The static checker
does not make use of this information.

@item @strong{Differences from JML or Java:} None.

@end itemize


@subsection static (Java)
@itemize @bullet
@item @strong{Description:} @code{static} is a Java modifier that may be applied
to classes and interfaces that are members
of enclosing classes.  

@item @strong{Status:} Implemented.

@item @strong{Differences from JML or Java:} None.
@end itemize

@section Annotations pertinent to a class or interface
These annotations may appear anywhere a declaration 
within a class or interface may appear.  They define specification-only
ghost or model fields of the type and state specifications that apply to
the whole object (not just to individual methods).

@subsection Ghost fields
@itemize @bullet
@item @strong{Description:} A ghost field is a field of the object that can hold a
value or reference to an object, but is used only in specifications.  Its
value is changed using the @code{set} annotation within the body of
a method or constructor (@pxref{set}).  
A ghost field may have an initializer, just as a 
Java program field may, but the ghost field may be initialized in only one
compilation unit of a refinement sequence.  A ghost field may have modifiers that
a Java field declaration would have (access modifiers (@pxref{Access modifiers}), @code{static}, @code{final},
@code{volatile}, @code{transient}) as well as the JML
modifiers @code{non_null}, @code{monitored} and @code{instance} 
(@pxref{Annotation modifiers for a field declaration}).

An interface may also declare ghost fields; these fields may be 
referenced by annotations in the interface or its subtypes.
  Such ghost fields are by default static,
but may be modified by the JML modifier @code{instance}, in which case they are
a field of every object that implements the interface.


@item @strong{Status:} Ghost fields are completely supported.

@item @strong{Differences from JML or Java:} 
[[[ Check that that rule about at most one
initialization is actually checked/enforced/correct.  
Check that modifiers work.]]]

@end itemize

@subsection Model fields
@itemize @bullet
@item @strong{Description:} Model fields are declarations within an annotation
prefixed by the modifier @code{model}.  They do not represent actual 
specification fields as do @code{ghost} values.  Rather, their values are 
implied by the concrete representation of the class, either
by an explicit expression in a @code{represents} clause or implicitly by
a boolean condition in a @code{\such_that} form of the 
@code{represents} clause.  They are used to supply values
that @emph{model} the behavior of the class.

A model field may have these modifiers: access modifiers (@pxref{Access modifiers}), @code{static},
 [[[ these ???: @code{final},
@code{volatile}, @code{transient})]]] and the JML
modifiers @code{non_null}, @code{monitored} and @code{instance} (@pxref{Annotation modifiers for a field declaration}).
Model fields may not have initializers.
[[[ An initializer expression would make nice syntactic sugar for the 
combination of a model declaration and a represents clause. ]]]

@item @strong{Status:} Model fields are parsed and used in typechecking.  However,
@code{represents} clauses are not implemented in the static checking within
ESC/Java2; consequently annotations containing model fields are not yet checked.

@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection Model methods
@itemize @bullet
@item @strong{Description:} Model methods are method declarations within an
annotation and prefixed with the modifier @code{model}.  They declare methods that
may be used in model programs and (if pure) in specifications.  Model methods
may have these Java modifiers: @code{public}, @code{protected}, @code{private},
@code{static}, @code{final}, @code{synchronized}, @code{strictfp};
they may have these JML modifiers: @code{pure}, @code{non_null}, @code{monitored},
@code{helper}.


@item @strong{Status:} Model methods are parsed and converted to regular Java 
methods within ESC/Java2.  However, the static checking mechanism of ESC/Java is
not able to handle method calls in specification expressions.

@item @strong{Differences from JML or Java:} Model methods are parsed and 
converted to regular Java 
methods within ESC/Java2.  Consequently, ESC/Java2 will not detect their (illegal) 
use within the implementation of a Java routine.


@end itemize

@subsection Model constructors
@itemize @bullet
@item @strong{Description:} Model constructors are constructor
 declarations within an
annotation and prefixed with the modifier @code{model}.  They declare 
constructors that
may be used in model programs and (if pure) in specifications.
A model constructor
may have these Java modifiers: @code{public}, @code{protected}, @code{private};
it may have these JML modifiers: @code{pure}, @code{helper}.  Constructors may
be @code{strictfp} only by virtue of the entire class being declared
@code{strictfp}.


@item @strong{Status:} Model constructors are parsed and converted to regular Java 
constructors within ESC/Java2.  However, the static checking mechanism of ESC/Java is
not able to handle constructor calls in specification expressions.

@item @strong{Differences from JML or Java:} Model constructors are parsed and 
converted to regular Java 
constructors within ESC/Java2.  Consequently, ESC/Java2 will not detect their (illegal) 
use within the implementation of a Java routine.

@end itemize

@subsection model class and model interface
@itemize @bullet
@item @strong{Description:} [[[ description needed ....]]]

@item @strong{Status:} [[[ status unknown ....]]]

@item @strong{Differences from JML or Java:} [[[bugs...]]]

@end itemize


@subsection initializer
@itemize @bullet
@item @strong{Description:} Java allows initializer blocks within a type 
declaration.  These are blocks of code contained simply within a pair of
curly braces.  The code is executed when a new object is being created, prior
to any constructor being run.  It is executed in turn (per the textual order of
field declarations and initializers
in the source file) as the fields of the objects are being initialized.
It may have specifications (e.g. @code{requires} and @code{ensures} clauses) 
associated with it; those specifications must hold of the object 
after initialization, but prior to any constructors being executed.
The annotations may be associated with the block of Java code directly in source
files that contain such code; in specification files without code, the
@code{initializer} keyword is a stand-in for the block of code itself.

@item @strong{Status:} Not yet parsed or implemented in static checking.

@item @strong{Differences from JML or Java:} None.

@item @strong{Comment:} [[[ FIXME - How is an initializer 
specification associated with a particular
block of Java code?  Or is there just one JML initializer specification 
allowed, and it 
expresses the condition after all the field and initializing code is run?  
 ]]]

@end itemize

@subsection static_initializer
@itemize @bullet
@item @strong{Description:} Java allows static initializer blocks within a type 
declaration.  These are blocks of code contained simply within a pair of
curly braces and having the 
modifier @code{static}.
  The code is executed when the class is loaded, prior
to any object of the class being instantiated.  
It is executed in turn (per the order of static
declarations in the source file) as the static fields of the 
class are being initialized.
It may have specifications (e.g. @code{requires} and @code{ensures} clauses) 
associated with it; those specifications must hold of the class 
after loading, but prior to the instantiation of any objects
(and with the prestate being the state before loading begins).
The annotations may be associated with the block of Java code directly in source
files that contain such code; in specification files without code, the
@code{static_initializer} keyword is a stand-in for the block of code itself.

@item @strong{Status:} Not yet parsed or implemented in the static checker.

@item @strong{Differences from JML or Java:} None.


@item @strong{Comment:} [[[ FIXME - How is a static  initializer 
specification associated with a particular
block of Java code?  Or is there just one JML static initializer specification 
allowed, and it 
expresses the condition after all the field and initializing code is run?  
 ]]]

@end itemize

@subsection Java method, constructor and field declarations
@itemize @bullet
@item @strong{Description:} These declarations are identical to those defined by
Java.  An implementation or initialization for such a declaration may appear only
in the .java file, not in any repeated declaration in a specification file.
@item @strong{Status:} Parsed and typechecked fully.  Java fields may be used in
annotations.  JML also allows pure methods and constructors
to be used in annotations, but the static checker
is not yet able to handle annotations containing method and constructor calls.

@item @strong{Differences from JML or Java:} None
@end itemize

@subsection inner or nested Java class or interface declarations
@itemize @bullet
@item @strong{Description:} Java allows declarations of classes and interfaces
within a class or interface.  These are called nested classes or interfaces if
they are @code{static} and inner classes or interfaces if they are not @code{static}.

@item @strong{Status:} Implemented.

@item @strong{Differences from JML or Java:} None

@end itemize

@c ------ section Annotation clauses for a class or interface --------
@node Annotation clauses for a class or interface, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Annotation clauses for a class or interface
These clauses provide a specification of the behavior of the class and of objects
of the class.  They may be specified in any order, within annotation comments,
anywhere an element of a type declaration may appear.  They may individually have
access modifiers (@pxref{Access modifiers}) @code{public}, @code{protected}, or
@code{private}.

@subsection invariant, invariant_redundantly
@itemize @bullet
@item @strong{Description:} An @code{invariant} clause specifies a boolean 
condition that must hold before and after any call of a (non-helper) method 
of the containing type.  Invariants must hold after any (non-helper)
constructor call of the containing type.

@item @strong{Status:} Fully implemented.

@item @strong{Differences from JML or Java:} None

@end itemize

@subsection constraint, constraint_redundantly
@itemize @bullet
@item @strong{Description:} A @code{constraint} clause specifies a relation that
must hold between the pre- and post-conditions of any (non-helper) method
 of the containing type.

@item @strong{Status:} Parsed and typechecked, but not implemented in the static checker.

@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection represents, represents_redundantly
@itemize @bullet
@item @strong{Description:} A @code{represents} clause designates how a model field
is related to the concrete fields or other model fields of the implementation.

@item @strong{Status:} Parsed and typechecked, but not utilized by the static checker.

@item @strong{Differences from JML or Java:} None.

@end itemize
@subsection depends, depends_redundantly
@itemize @bullet
@item @strong{Description:} The @strong{depends} clause is obsolete; it is replaced by
@strong{in} and @strong{maps} [[[ Ref ]]],

@item @strong{Status:} Depends clauses are parsed and ignored.


@end itemize

@subsection axiom
@itemize @bullet
@item @strong{Description:} An @code{axiom} is used to specify a mathematical
property, independent of the implementation of classes or objects.

@item @strong{Status:} [[[This feature was part of ESC/Java, but needs verification 
that it is functional in ESC/Java2. ]]] Fully parsed and typechecked.

@item @strong{Differences from JML or Java:} None.


@end itemize

@subsection initially, initially_redundantly
@itemize @bullet
@item @strong{Description:} This clause specifies a condition that must hold in
the post-state of any constructor (including the default constructor). 

@item @strong{Status:} Parsed and typechecked, but not implemented in the static
checker.

@item @strong{Differences from JML or Java:} None.


@end itemize

@subsection readable
@itemize @bullet
@item @strong{Description:} description.... [[[ Description needed ]]]

@item @strong{Status:} Not implemented.

@item @strong{Differences from JML or Java:} [[[bugs...]]]


@end itemize

@subsection monitors_for
@itemize @bullet
@item @strong{Description:} description....  [[[ Description needed ]]]

@item @strong{Status:} Not implemented.

@item @strong{Differences from JML or Java:} [[[bugs...]]]


@end itemize



@section Annotations for a method or constructor
Specifications of the behavior of an individual
 method or constructor typically appear within
an annotation comment, just prior to the declaration of the method or constructor.
The specifications consist of zero or more lightweight or heavyweight behavior 
sections, an optional subclassing contract, an optional @code{implies_that}
section, and an optional @code{for_example} section.  Model methods and constructors
may also be annotated with these specifications.

@node Lightweight and heavyweight specifications, ???, ???, ???
@subsection Lightweight and heavyweight specifications
@itemize @bullet
@item @strong{Description:} Lightweight specification cases are simply a series of specification clauses and
correspond to the specification style of ESC/Java. 
Heavyweight specification cases are introduced with a @code{behavior},
@code{normal_behavior}, or @code{exceptional_behavior} keyword.  Heavyweight
specifications may have optional privacy modifiers (@pxref{Access modifiers})
 and have different defaults than do lightweight
specifications.

Within a heavyweight specification, if a particular clause type is omitted, the 
default for that clause is as follows:
@example
        requires true;
        ensures true;
        signals (java.langException) true;
        diverges false;
        assignable \everything;
        accessible \everything;
        when true;
        duration \not_specified;
        working_space \not_specified;
@end example
@noindent
The defaults defined by JML for lightweight specifications are @code{\not_specified}
in each case.  This is interpreted within ESC/Java2 as follows.  
@example
        ensures true;
        signals (java.langException) true;
        diverges true;
        assignable \everything;
        accessible \everything;
        when true;
        duration \not_specified;
        working_space \not_specified;
@end example
@noindent
The default for the requires clause is determined as follows: @footnote{Michael Moeller contributed to this formulation of the defaults for requires.}
@itemize @bullet
@item If there are some other clauses explicitly given, but no requires clause, the default is @code{requires true;}
@item If there is no specification at all and the routine is a constructor or is
a method does not override any super class or super interface methods, the default is
@code{requires true;}
@item If there is no specification at all (including no @code{non_null} modifiers)
and the method does override some super class
or super interface method, the default is @code{requires false; }
@end itemize
The reasons for these defaults are explained in @ref{Specifications and inheritance}.

Note that the defaults for the @code{diverges} clause are different between the
lightweight and heavyweight forms.  The lightweight default, @code{diverges true},
puts the least restrictions on the implementation; it states that the
implementation is allowed to be non-terminating (but not required to be).  The
heavyweight default, @code{diverges false}, requires the implementation to
terminate with either an exception or a normal return.  [[[ However, this is not
checked in the current implementation. ]]]

@item @strong{Status:} The lightweight and heavyweight specification forms,
including nesting using @code{@{|} and @code{|@}} and combination with @code{also},
 are 
fully parsed and implemented (though not all clause types, as described below, 
are fully implemented or handled by the static checker).

@item @strong{Differences from JML or Java:} None, except that ESC/Java2 does not
constrain the order of clauses as rigidly as do JML tools. [[[ Say more]]] [[[ Esc/Java2 does not currently check the access modifiers on behavior and example
keywords.  What happens with the privacy checking? ]]]

@anchor{Desugaring}
@item @strong{Comment:} The ESC/Java2 (and ESC/Java) translator,
which produces the verification conditions to be checked by the static checker,
 accepts a set
of specification clauses in lightweight form.  In order to handle the nested and
heavyweight forms and the combination of specifications using @code{also}, either
within one source file or across a refinement sequence, ESC/Java2 @emph{desugars}
the more complicated syntax into a simpler form.  For this purpose ESC/Java2 largely
follows the desugaring as outlined in [[[FIXME - provide ref]]], but it does not need
to desugar all clause types down to one instance of that clause type.  That paper
provides more details on the desugaring process; the 
equivalent but slightly simpler version
used in ESC/Java2 is outlined here. Note that the desugaring process must take care
not to lose the location information that is helpful to the user when warning
messages are issued.

The desugaring process first eliminates nesting by replicating and distributing 
the requires clauses across the nested groups of clauses.  
Any @code{old} clauses are desugared by replacing any references to them by
the expression with which they are initialized (evaluated in the pre-state);
any @code{forall} clause is desugared by wrapping any clause within its
scope in a @code{\forall} quantified expression.
Also, each lightweight specification case,
 @code{normal_behavior} and 
@code{exceptional_behavior} keyword is desugared into a @code{behavior}
specification.  Specifications from corresponding methods in the
refinement sequence are combined, connected by @code{also}.
That produces a series of specification cases, connected by @code{also}, 
each consisting one group of clauses (that is, one specification case).  
ESC/Java2's static checker will accept a single specification case.
 For each specification case,
 a composite precondition predicate is 
formed by taking the conjunction of the predicates in each of the @code{requires}
clauses in that specification case, 
and making that conjunction the argument of an 
@code{\old} function:
@center{@emph{pre-predicate} = @code{\old(} @emph{p1} @code{&&} @emph{p2} ... @code{)} }.  
@*Each clause within the specification case is altered by
constraining its action using that conjunction.  Calling that combined predicate
@emph{pre-predicate}, we transform each clause as follows:
@itemize @bullet
@item @code{ensures} @emph{pred}@code{;}
@*becomes 
@*@code{ensures} @emph{pre-predicate} @code{==>} @emph{pred}@code{;}

@item @code{diverges} @emph{pred}@code{;}
@*becomes 
@*@code{diverges} @emph{pre-predicate} @code{==>} @emph{pred}@code{;}

@item @code{modifies} @emph{list}@code{;} 
@*where @emph{list} consists of a comma-separated
sequence of elements of the form 
@*@center{@emph{item}}
@* or 
@*@center{@emph{item} @code{if} @emph{pred}}
@* becomes a set of separate clauses of the form
@*@center{@code{modifies} @emph{item} @code{if} @emph{pre-predicate} @code{;}}
@*or 
@*@center{@code{modifies} @emph{item} @code{if} @emph{pre-predicate} @code{&&} @emph{pred}@code{;}}

@item @code{signals} (@emph{type} @emph{id} @code{)} @emph{pred}@code{;}
@*becomes
@*@code{signals} (@emph{type} @emph{id} @code{)} @emph{pre-predicate} @code{==>} @emph{pred}@code{;}
@item when -- [[[ complete this ]]]
@item accessible -- [[[ complete this ]]]
@item callable -- [[[ complete this ]]]
@item duration -- [[[ complete this ]]]
@item working_space -- [[[ complete this ]]]
@end itemize
The requires clauses are desugared by replacing all of the requires clauses in all
of the specification cases with a single requires clause whose predicate is the 
disjunction of the conjuctions formed for each specification case, 
without the enclosing
@code{\old}.  When the static checker creates a VC to be used as a precondition
for calling a method, it forms a disjunction of the requires clauses for the
method and all the declarations that it overrides. 

@end itemize

@subsection also

@itemize @bullet
@item @strong{Description:} JML allows multiple specifications for a single method;
these are separated and connected by the @code{also} keyword.  Furthermore, if
the method has additional specifications in an earlier source file in the refinement
sequence or attached to an overridden method in a super class or interface, then
(and only then)
the specification must begin with @code{also} to indicate that there are some
previous specifications of which the reader should be aware.

@item @strong{Status:} The use of @code{also} is completely implemented, with
desugaring occuring as described above.  

@item @strong{Differences from JML or Java:} None.

@cindex also_requires
@cindex also_modifies
@cindex also_ensures
@cindex also_exsures
@item @strong{Comment:} This syntax for combining specifications is different than
and not backwards compatible with the syntax used in ESC/Java.  That tool did not
allow combining multiple specifications using @code{also} and did not support
refinement sequences.  Where there was inheritance of specification clauses from a
super class or interface, the keywords @code{also_requires}, @code{also_ensures}, 
@code{also_modifies}, and @code{also_exsures} were required.  These keywords are
not supported in ESC/Java2 and such specifications will need to be rewritten using
the new @code{also} syntax.
@end itemize

@subsection model_program

@itemize @bullet
@item @strong{Description:} Model programs are an alternate way to provide 
specifications for a method.  Rather than stating logical conditions that
the pre- and
post-states must satisfy, the behavior is specified by a @emph{model program},
which specifies the behavior using typical imperative programming constructs.
However, a model program allows some non-deterministic (and non-executable) 
constructs as well.  Note that there are a number of JML constructs which are only
used within model programs. These are described in @ref{Statements within model programs}.

@item @strong{Status:} Model programs are parsed and ignored.  They are permitted
as a specification case, as defined by JML.  Any constructs unique
to model programs are simply skipped over by the parser.

@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection implies_that
@itemize @bullet
@item @strong{Description:} The @code{implies_that} keyword introduces
specification cases that are logical consequences of the usual behavior and lightweight
specifications.  They could be used as specifications to be checked in the same
way that the other specifications are.  Alternatively, it could be verified that
they are logical consequences of
 the other specifications; the results could then be used as 
additional useful statements of behavior; these in turn could
help with proofs involving use of
the method or constructor with which the @code{implies_that} specification
 is associated.

@item @strong{Status:} The specifications in an @code{implies_that} section are
parsed [[[and typechecked?]]], but not used within any static checking.

@item @strong{Differences from JML or Java:} None.

@end itemize


@subsection for_example specification
@itemize @bullet
@item @strong{Description:} The @code{for_example} keyword introduces 
specification cases that are useful and instructional examples for the reader of
the specifications.  Hence they must be logical consequences of the 
other
specifications.  Each case may be lightweight or be introduced by one of the
keywords @code{example}, @code{normal_example},
and @code{exceptional_example}; these keywords may have associated access modifiers
(@pxref{Access modifiers}).
@item @strong{Status:} The specifications in a @code{for_example} section are
parsed [[[and typechecked?]]], including the @code{example}, @code{normal_example},
and @code{exceptional_example} keywords.
However, they are not used within any static checking, nor is it 
verified that they follow from the other specifications.

@item @strong{Differences from JML or Java:} None.


@end itemize


@c ------ Annotation clauses for a method or constructor --------
@node Annotation clauses for a method or constructor, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Annotation clauses for a method or constructor

In this section we describe the clause types that may be part of specifications,
including @code{implies_that} and @code{for_example} sections.
Note that some clauses have alternate 
keywords reflecting different personal preferences or different usages between
ESC/Java and other JML tools.  These alternates are complete synonyms.



@subsection forall
@itemize @bullet
@item @strong{Description:} The @code{forall} declaration declares a
universally quantified variable; the scope of the declaration is all 
subsequent clauses for the same routine up to the @code{also} or @code{\@}}
marking the end of the specification case seequence containing the @code{forall}
declaration, or until end of the behavior, implies_that or for_example section.  No
initializer is allowed.  The clause is desugared by wrapping each 
desugared clause in an appropriate @code{\forall} expression.

@item @strong{Status:} Fully implemented.  However, the semanics need clarifying and the static checker objects to quantified expressions.
[[[ Declaring multiple variables within one declaration is not implemented.]]]

@item @strong{Differences from JML or Java:} None.


@end itemize

@subsection old
@itemize @bullet
@item @strong{Description:} The @code{old} declaration is used within a 
routine specification to define a value that may be used in subsequent clauses
of the specification.  The variable declared must be initialized.  The
initialization expression is always evaluated in the pre-state, regardless of
how the variable is used in subsequent clauses.  The scope
of the variable extends from its declaration (not including the initializer),
to the `also' or `|@}' that marks the end of the specification case sequence 
containing the @code{old} declaration, or until the end of the behavior,
implies_that or for_example section.
The uses of @code{old} variables are desugared by substituting the initialization
expression, wrapped in an appropriate @code{\old} expression, at the point of
use.

@item @strong{Status:} Implemented.  [[[ Not yet supported: multiple variables
within one declaration; array initializers. ]]]

@item @strong{Differences from JML or Java:} None.


@end itemize


@subsection requires, requires_redundantly, pre, pre_redundantly
@itemize @bullet

@item @strong{Description:} A requires clause specifies a condition that must hold in the pre-state of the method.  The remaining 
clauses of the specification case
must hold whenever the requires clause (or the conjunction of multiple
requires clauses) holds.  The expression in the clause
may also be @code{\not_specified}, which is equivalent to omitting the clause.
The expression must have boolean type and is evaluated in the pre-state.

@item @strong{Status:} The requires clause is implemented and is utilized by ESC/Java2
in generating verification conditions.
@item @strong{Differences from JML or Java:} ESC/Java2 will warn about the use of
instance variables in the precondition of a constructor (since those variables do
not yet exist prior to allocation); JML does not.
@end itemize

@subsection ensures, ensures_redundantly, post, post_redundantly
@itemize @bullet
@item @strong{Description:} An ensures clause states a condition that must hold in
the post-state of a method or constructor whenever the associated preconditions
hold in the pre-state and the method or constructor exits normally.
  The expression in the clause
may also be @code{\not_specified}, which is equivalent to omitting the clause.
The expression must have boolean type and is evaluated in the post-state.

@item @strong{Status:} Implemented and used by the static checker.
@item @strong{Differences from JML or Java:} None.

@end itemize

@cindex signals
@cindex signals_redundantly
@cindex exsures
@cindex exsures_redundantly
@subsection signals, signals_redundantly, @*exsures, exsures_redundantly
@itemize @bullet
@item @strong{Description:} A signals clause states a condition that must hold in
the post-state of a method or constructor whenever the associated preconditions
hold in the pre-state and the method or constructor exits with an exception of
(or a subclass of) the designated type.  The expression in the clause
may also be @code{\not_specified}, which is equivalent to omitting the clause.
The expression must have boolean type and is evaluated in the post-state (though the
keyword @code{\result} is not valid in a @code{signals} clause.

@item @strong{Status:} Implemented and used by the static checker.

@item @strong{Differences from JML or Java:} None.

@end itemize

@cindex modifies
@cindex modifiable
@cindex assignable
@cindex modifies_redundantly
@cindex modifiable_redundantly
@cindex assignable_redundantly
@subsection modifies, modifiable, assignable, modifies_redundantly, modifiable_redundantly, assignable_redundantly
@itemize @bullet
@item @strong{Description:} The modifies clause indicates which memory locations
may be assigned within
 the associated routine when the routine is called in a pre-state
that satisfies the associated preconditions.  In JML a modifies clause may also
have its own conditional predicate that further constrains when the associated 
memory locations may be assigned.  The list of locations in the modifies clause
may also contain the special keywords @code{\nothing}, @code{\everything},
@code{not_specified}.
The conditional expression must have boolean type; any expressions in the clause are
evaluated in the pre-state.

@item @strong{Status:} Implemented and used by the static checker.  However, 
ESC/Java2 ignores the conditional predicate of a modifies clause.  Furthermore
ESC/Java2 (like ESC/Java) does not check at all that the modifies clause is valid
for the routine for which it is a specification.  It does use the modifies clause
when reasoning about other routines that use the routine in question.  
For example, given 

@example
int i;
int k;

//@@ modifies i;
void m() @{ i = 9; @}

//@@ modifies k;
void n() @{ i = 10; @}

void p() @{
        m();
        n();
@}
@end example
@noindent
ESC/Java2 does not complain that routine @code{n} actually does modify the field
@code{i}, even though it claims to modify only @code{k}.  Also, in reasoning about
method @code{p}, it will know that after the call to @code{m}, the field @code{i}
may have a value different from the value before the call of @code{m}; but because
@code{n} claims not to modify @code{i}, ESC/Java2 will presume that the value of
@code{i} after the call of @code{n} is the same as the value before the call.

Note also that the behavior in the absence of a @code{modifies} clause in ESC/Java2
(as in ESC/Java) is @code{modifies \nothing;}.  The default defined by JML is
@code{modifies \everything}.  [[[ This will change - ESC/Java2's default will be the same an JML's but the implementation needs to be worked out. ]]]

@item @strong{Differences from JML or Java:} JML has recently implemented data 
groups using the @code{in} and @code{maps} annotations.  JML allows these data
groups to be used in modifies clauses, but these are not yet 
handled by ESC/Java2.


@end itemize

@cindex diverges
@cindex diverges_redundantly
@subsection diverges, diverges_redundantly
@itemize @bullet
@item @strong{Description:} This clause states a predicate that must hold 
(in the pre-state) if the
method never terminates (given that
the associated precondition holds in the pre-state).
  The expression in the clause
may also be @code{\not_specified}, which is equivalent to omitting the clause.
The expression must have boolean type and is evaluated in the pre-state.

@item @strong{Status:} Parsed and typechecked, but not used in any static checking.

@item @strong{Differences from JML or Java:} None.


@end itemize

@cindex when
@subsection when
@itemize @bullet
@item @strong{Description:} description.... [[[ description needed ]]]
  The expression in the clause
may also be @code{\not_specified}, which is equivalent to omitting the clause.
The expression must have boolean type and is evaluated in the pre-state.

@item @strong{Status:} Parsed and typechecked, but not used in any static checking.
@item @strong{Differences from JML or Java:} None.

@end itemize

@cindex duration
@subsection duration
@itemize @bullet
@item @strong{Description:} description....[[[ description needed ]]]
  The expression in the clause
may also be @code{\not_specified}, which is equivalent to omitting the clause.
The expression must have @code{long} type and is evaluated in the post-state.
[[[ I think the pre-state is better - what about exceptional termination?]]]

@item @strong{Status:} Parsed and typechecked but not used in any static checking.
@item @strong{Differences from JML or Java:} None.


@end itemize

@cindex working_space
@subsection working_space
@itemize @bullet
@item @strong{Description:} description....[[[ description needed ]]]
  The expression in the clause
may also be @code{\not_specified}, which is equivalent to omitting the clause.
The expression must have @code{long} type and is evaluated in the post-state.
[[[ I think the pre-state is better - what about exceptional termination?]]]

@item @strong{Status:} Parsed and typechecked, but not used in any static checking.

@item @strong{Differences from JML or Java:} None.


@end itemize


@cindex accessible
@subsection accessible
@itemize @bullet
@item @strong{Description:} description....[[[ description needed ]]]
  The list of locations in the clause
may also contain the special keywords @code{\nothing}, @code{\everything},
Any expressions (e.g. array indices) are evaluated in the pre-state.

@code{not_specified}.

@item @strong{Status:} status....  - status unknown

@item @strong{Differences from JML or Java:} bugs...


@end itemize

@cindex callable
@subsection callable
@itemize @bullet
@item @strong{Description:} description....[[[ description needed ]]]
  The list of locations in the clause
may also contain the special keywords @code{\nothing}, @code{\everything},
Any expressions (e.g. array indices) are evaluated in the pre-state.

@code{not_specified}.

@item @strong{Status:} status....  - status unknown

@item @strong{Differences from JML or Java:} bugs...


@end itemize



@subsection measured_by
@itemize @bullet
@item @strong{Description:} description.... [[[ Description needed ]]]
  The expression in the clause
may also be @code{\not_specified}, which is equivalent to omitting the clause.
[[[ What is the type of the expression ? ]]]

@item @strong{Status:} Parsed and ignored.

@item @strong{Differences from JML or Java:} bugs...


@end itemize

@subsection Redundancy
@itemize @bullet
@item @strong{Description:} Many clauses have a redundant form, indicated by 
using a keyword with a @strong{_redundantly} suffix.
The intention of these clauses is to indicate specifications that are implied by
other, nonredundant, specifications.  The writer may choose to include the
redundant specifications in order to point out some non-obvious implications of other
specifications, either to facilitate understanding by the reader or to assist the
prover in verifying conclusions.

Note that the implies_that and for_example specifications are additional forms of
redundancy.


@item @strong{Status:} Currently in ESC/Java2 a command-line option selects 
between using redundant specifications (those with keywords ending in 
@code{_redundantly} in the same way as nonredundant 
specifications (the default) or ignoring them (when the option @code{-noredundancy}
is chosen).
@end itemize



@c ------ Annotation modifiers for a method or constructor --------
@node Annotation modifiers for a method or constructor, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Annotation modifiers for a method or constructor

Annotation modifiers can appear between the last specification clause or  
javadoc comment and the type designator or class name that is part of the method
or constructor.  JML modifiers and Java modifiers may appear in any order.  Though
less common and not the usual style, ESC/Java2 (following ESC/Java) allows 
JML modifiers to appear after the
method declaration and before the opening left brace of the body or the terminating
semicolon if there is no body.

Besides the modifiers listed here, methods and constructors may also have the
access modifiers described in @ref{Access modifiers}.

@subsection pure (JML)
@itemize @bullet
@item @strong{Description:} The @code{pure} modifier applied to a
method indicates that the method does not assign to any 
non-local memory location during
its execution; it may not even modify and then restore the original value.  It is
equivalent to having no modifies clauses at all in the specification,
 except perhaps 
@*@center{@code{modifies \nothing;}}
@*In the case of a constructor, the only fields that may be modified are the fields
of the object itself, which are initialized as a result of the action of the 
constructor.  In this case the @code{pure} modifier is equivalent to 
specifications of the form
@*@center{@code{modifies this.*;}}
@*Note that if a method is declared pure, then all overriding methods are also pure,
whether or not they have an explicit declaration to that effect.

@item @strong{Status:} Fully supported.  [[[ Error checks for modifies clauses in
a pure constructor are not enabled. Default modifies clause for a pure constructor not implemented. ]]]

@item @strong{Differences from JML or Java:} None.

@end itemize


@subsection non_null (JML - methods only)
@itemize @bullet
@item @strong{Description:} Modifying a routine with the @code{non_null} modifier
is valid only for methods that return objects as return values (and not for 
constructors).  The modifier specifies that the return value is never null.  It is
equivalent to a specification of 
@*@center{@code{ensures \result != null; }}
@*added to each specification case of the method's specification in all of the
files of the refinement sequence (but not of a 
superclass's specification of that method).

Note that superclass and subclass declarations of a method each independently
may have or not have @code{non_null} declarations.  A method's implementation 
must satisfy the superclass specification and independently satisfy the subclass
specification.  There is a more thorough discussion in @ref{Inheritance and non_null}.

@item @strong{Status:} Parsed, typechecked and supported by the static checker.

@item @strong{Differences from JML or Java:} None.
@end itemize


@subsection helper (JML)
@itemize @bullet
@item @strong{Description:} This modifier indicates that the method or constructor
in question is used as an internal helper routine and that the method or constructor
is therefore not expected to satisfy any of the class-level invariants or
constraints, in either its pre-state or its post-state.  The method or constructor
is still expected to satisfy any specifications (e.g. ensures clauses) that are
explicitly associated with this method or constructor.

@item @strong{Status:} Parsed, typechecked and supported by the static checker.

@item @strong{Differences from JML or Java:} JML only allows private methods and
constructors to be helpers.  ESC/Java2 also allows any constructors, 
final methods or methods of
final classes to be helpers.  (ESC/Java2's rule is that only routines that cannot
be overridden may be helpers.)
@end itemize


@cindex final
@subsection final (Java - methods only)
@itemize @bullet
@item @strong{Description:} This Java modifier indicates that a method may not be
overridden.  It may also be applied to model methods.
@item @strong{Status:} Fully implemented.  This feature does not affect the
static checking; it simply produces a typechecking error if a final method is
overridden.

@item @strong{Differences from JML or Java:} None.
@end itemize

@cindex static
@subsection static (Java - methods only)
@itemize @bullet
@item @strong{Description:} @code{static} is a Java modifier (which may be used on
JML annotations as well) that indicates that the declaration in question is a
member only
of the class and not of each instance of the class.  

@item @strong{Status:} Fully implemented.

@item @strong{Differences from JML or Java:} None.


@end itemize


@cindex synchronized
@subsection synchronized (Java - methods only)
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize


@cindex native
@subsection native (Java - methods only)
@itemize @bullet
@item @strong{Description:} A native method is one whose implementation is 
provided outside of the Java language.  Consequently such a method will not have
an implementation.
@item @strong{Status:} Fully implemented.  The static checker will indicate that
the method passes its checks since there is no body to check.
@item @strong{Differences from JML or Java:} None.
@end itemize


@cindex strictfp
@subsection strictfp (Java - methods only)
@itemize @bullet
@item @strong{Description:} This modifier indicates that all of the floating
point operations within the method must hold to strict semantics.
@item @strong{Status:} Parsed and ignored by ESC/Java2.  No static checking of
floating point semantics is performed.  Note that the Java Language
Specification stipulates that constructors may
be @code{strictfp} only by virtue of the entire class being declared
@code{strictfp}.
@item @strong{Differences from JML or Java:} None.
@end itemize

@c ------ Annotation assertions for a field declaration --------
@node Annotation assertions for a field declaration, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Annotation assertions for a field declaration

A field declaration (including ghost and model field declarations)
may be followed by 
field assertions, which are introduced by the @code{in} and @code{maps}
keywords.  These declarations associate a field or its sub-fields with 
specific datagroups, which can then be used as items in a modifies 
clause.  Datagroup items are objects of type 
@code{org.jmlspecs.models.JMLDataGroup}.  Thus if either of these assertions
is used, you will need to have declared relevant ghost variables of
type @code{JMLDataGroup}, and perhaps have imported the appropriate model
class.  That means further that you will need to have the JML model
classes in your classpath (or sourcepath).
 
Note again that these assertions @b{follow} the field declaration.

@subsection in (JML)
@itemize @bullet
@item @strong{Description:} This assertion follows a field declaration and lists
the datagroups of which the field is a part.  A field is automatically a part of the
datagroup with the same name as itself.
@item @strong{Status:} Parsed, not typechecked, and ignored.
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize


@subsection maps, \into (JML)
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} Parsed, not typechecked, and ignored.
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize


@c ------ Annotation modifiers for a field declaration --------
@node Annotation modifiers for a field declaration, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Annotation modifiers for a field declaration

A field declaration (including ghost and model field declarations)
may have both Java and JML modifiers.
In addition to the access modifiers (@pxref{Access modifiers}),
 the following modifiers are relevant to field declarations.


@subsection non_null (JML)
@itemize @bullet
@item @strong{Description:} This modifier on a field declaration indicates that the
field in question never has a null value, after the object is constructed.  
It is equivalent to a class invariant
of the form
@*@center{@code{invariant @emph{field} != null;}}
@*with the same access modifiers as the field itself.

@item @strong{Status:} Fully implemented and supported by the static checker.
@item @strong{Differences from JML or Java:} None.
@end itemize

@subsection monitored (JML)
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize

@subsection uninitialized (JML)
@itemize @bullet
@item @strong{Description:} [[[ESC/Java does not allow this on a field declaration, but should it? ]]]
@item @strong{Status:} Not implemented.
@item @strong{Differences from JML or Java:} Not part of JML.
@end itemize

@subsection final (Java)
@itemize @bullet
@item @strong{Description:} This Java modifier indicates that the field it
modifies may not be assigned to, after it has been initialized (either by
an initializer or in a constructor).  Java has some
complex rules about definite-assignment that are relevant but not discussed here.
@item @strong{Status:} It is supported by the ESC/Java2 parser and type checker.
It does not have any effect on the static checking. [[[ There are checks only
that variables with initializers are not subsequently assigned to.]]]
@item @strong{Differences from JML or Java:} None.
@end itemize

@subsection volatile (Java)
@itemize @bullet
@item @strong{Description:} This Java modifier affects the optimizations that 
might be applied and the semantics of the order of writing the values of object
fields to memory.  It affects multi-threaded programs only.
@item @strong{Status:} Parsed but ignored by the static checker.
@item @strong{Differences from JML or Java:} None.
@end itemize

@subsection transient (Java)
@itemize @bullet
@item @strong{Description:} Fields designated @code{transient} are not saved as
part of an object's persistent state.
@item @strong{Status:} Parsed but ignored by the static checker.  Any implications
of this modifier would be part of the specifications of serialization for the 
object.
@item @strong{Differences from JML or Java:} None.
@end itemize

@subsection static (Java)
@itemize @bullet
@item @strong{Description:} @code{static} is a Java modifier (which may be used on
JML ghost and model field declarations as well)
 that indicates that the declaration in question is a member of the class
and not of each instance of the class.  

@item @strong{Status:} Fully implemented.

@item @strong{Differences from JML or Java:} None.


@end itemize


@subsection instance (JML)
@itemize @bullet
@item @strong{Description:} @code{instance} is a JML modifier that indicates the
opposite of @code{static}, that is, that the field in question is a member of each
instance of the object, not just of the class.  Within a class declaration,
field declarations are non-static by default (and @code{instance} is not needed).
However, within an interface, field declarations (including ghost and model
declarations) are @code{static} and @code{final} by default.  The
@code{instance} modifier may be applied to ghost or model field declarations in
an interface, making those fields non-static and non-final (unless also declared
@code{final}).  (JML allows the modifier @code{instance} only on ghost and model 
field declarations, in either classes or interfaces.)

@item @strong{Status:} Implemented

@item @strong{Differences from JML or Java:} [[[ Check that the defaults with respect to 'final' are enforced.  CHeck that illformed JML uses are checked and forbidden by ESC/Java]]]


@end itemize

@section Annotation modifiers for formal parameters

These modifiers may precede 
the type name of a formal parameter within the 
declaration of the method or constructor.
[[[ Check whether JML modifiers may follow the type name or the identifier. ]]]

@subsection non_null (JML)
@itemize @bullet
@item @strong{Description:} Modifying a formal parameter with a @code{non_null}
modifier is equivalent to adding a precondition stating that the parameter is not
equal to @code{null} and requiring that any assignment to that variable 
assign a non-null value.  It is only legal for reference types, not for 
primitive types.  The non_null condition is in addition to the composite
specification formed from the complete refinement sequence.  Hence it is 
equivalent to adding a precondition requiring the parameter be non_null to the
desugared specification of the routine (as well as the conditions on subsequent
assignments within the body of the routine).

Note that superclass and subclass declarations of a method each independently
may have or not have @code{non_null} declarations.  A method's implementation 
must satisfy the superclass specification and independently satisfy the subclass
specification.  A more thorough discussion is given in @ref{Inheritance and non_null}.

@item @strong{Status:} The modifier is parsed, checked and supported by the
static checker.

@item @strong{Differences from JML or Java:} None known. [[[FIXME - does JML detect 
problems with overriding methods?]]].  

@item @strong{Comment:} The original ESC/Java did not permit a subclass to modify a
formal parameter as @code{non_null} in an overriding declaration.  The 
declarations of the top-most declaration were used for all overriding declarations.
@end itemize

@subsection final (Java)
@itemize @bullet
@item @strong{Description:} This Java modifier indicates that a formal parameter
may not be the target of an assignment in the body of the routine.
@item @strong{Status:} Fully implemented.  This feature does not affect the
static checking; it simply produces a typechecking error if a final parameter is
the target of an assignment.

@item @strong{Differences from JML or Java:} None.
@end itemize


@section Annotation statements within the body of a method or constructor
These annotation statements may be intermixed with the statements within the
body of a method or constructor.  They may also be used within model programs.

@subsection assume, assume_redundantly
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize


@subsection assert, assert_redundantly
@itemize @bullet
@item @strong{Description:} This statement will generate a static checker warning
if a program execution can be found in which the associated predicate is false.
Note that this is different than the Java assert statement, both in syntax and in
semantics.  The command-line options @code{-jmlAssertions} will cause Java
assertions to behave like JML assertions (@pxref{Java and JML assert statements}). 
@item @strong{Status:} Fully implemented.
@item @strong{Differences from JML or Java:} None.
@end itemize

@c ------ set --------
@node set, ???, ???, ???
@c  node-name,  next,  previous,  up
@subsection set
@itemize @bullet
@item @strong{Description:} The JML set statement is used as a statement within the
body of a routine to assign a value to a ghost field or variable.  ESC/Java allowed
only fields to be set.  ESC/Java2 allows in addition the declaration of local
ghost variables and the assignment of values to them using set statements.
@item @strong{Status:} Implemented.
@item @strong{Differences from JML or Java:} None.
@end itemize

@subsection unreachable
@itemize @bullet
@item @strong{Description:} This is a statement that asserts that the command-flow
of the program will never reach this point.  If the static checker suspects that there
is a program execution that can do so, it will issue a warning.
It is equivalent to an annotation stating @code{assert false}.
There is no conditional unreachable statement but the equivalent can be created using
an assert statement.
@item @strong{Status:} Implemented.
@item @strong{Differences from JML or Java:} [[[ DOes JML have an unreachable statement?]]]
@end itemize


@subsection hence_by
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize


@subsection loop_invariant, loop_invariant_redundantly, @*maintaining, maintaining_redundantly
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize

@subsection decreases, decreasing, decreases_redundantly, @*decreasing_redundantly
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]
@item @strong{Status:} [[[ Comment needed. ]]]
@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]
@end itemize

@subsection ghost declarations
@itemize @bullet
@item @strong{Description:} JML and ESC/Java2 (but not ESC/Java) allow the 
declaration of local ghost variables within the body of a routine, 
just as Java allows local declarations.  These can then be used in subsequent
annotation statements within the body, such as assert, assume, or set statements.
Such declarations may also be declared @code{final} or @code{non_null} and may have
initializers.
@item @strong{Status:} Implemented.  
@item @strong{Differences from JML or Java:} None.
@end itemize

@section Modifiers that may be applied to local declarations

Declarations within the body of a method, constructor or initialization code 
introduce local variables used only during the execution of that body of code.
Privacy modifiers, @code{static}, and @code{instance} are not applicable to these
declarations.  The following modifiers are allowed.

@subsection non_null (JML)

@itemize @bullet
@item @strong{Description:} A local declaration (including ghost and model declarations) 
of a variable of reference type
within the body of a method or 
constructor may be modified with the JML annotation @strong{non_null}.  This
requires that the initial value and any subsequently assigned value for that
variable must not be null.  [[[ must have an initializer ???]]]

@item @strong{Status:} Fully implemented (in ESC/Java and ESC/Java2).
[[[ Failure to initialize is not detected. Or failure to initialize with null value.  Also ghost declarations. ]]]

@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection uninitialized (JML)
@itemize @bullet
@item @strong{Description:} This JML modifier may be applied to a local variable
declaration within the body of a block of code.  It indicates that although the
variable has been initialized with an initial value, it should be considered as
uninitialized.  That is, a warning will be issued if its value is used before having
been assigned a new value.

@item @strong{Status:} Implemented (as in ESC/Java).

@item @strong{Differences from JML or Java:} This modifier is not part of JML.
@end itemize


@subsection final (Java)
@itemize @bullet
@item @strong{Description:} This Java modifier has the usual meaning that the
variable may not be altered (or even reassigned its same value) after it has been
declared and initialized.

@item @strong{Status:} Implemented.  

@item @strong{Differences from JML or Java:} This modifier is not part of JML.
@end itemize


@section JML functions (extensions to expressions)

JML defines a number of new operators, functions, and other constructions for use within expressions
that are part of annotations.

@subsection New operators in JML
[[[FIXME - describe precendence]]]

@itemize @bullet

@cindex @code{<==>}
@item @code{<==>} : 
This operator (equivalence) takes two boolean arguments; it returns a boolean value of 
@code{true} if the two arguments are both @code{true} or both @code{false}, and 
@code{false} otherwise.  
@*@strong{Status: }Implemented.

@cindex @code{<=!=>}
@item @code{<=!=>} : 
This operator (inequivalence) takes two boolean arguments; it returns a boolean value of 
@code{false} if the two arguments are both @code{true} or both @code{false}, and 
@code{true} otherwise.  @code{(A <==> B)} is equivalent to 
@code{!(A <=!=> B)}.
@*@strong{Status: }Implemented.

@cindex @code{==>}
@item @code{==>} : 
This operator (implies) takes two boolean arguments and returns a boolean value of 
@code{true} if the first is @code{false} or the second is @code{true},
and returns @code{false} if the first is @code{true} and the second is @code{false}.  
@*@strong{Status: }Implemented.

@cindex @code{<==}
@item @code{<==} : 
This operator (reverse implication, or explies) takes two boolean arguments and returns a boolean value of 
@code{true} if the second is @code{false} or the first is @code{true},
and returns @code{false} if the second is @code{true} and the first is @code{false}.  
@code{(A ==> B)} is equivalent to @code{(B <== A)}.
@*@strong{Status: }Implemented.

@cindex @code{<:}
@item @code{<:} : 
This operator takes two arguments of type @code{\TYPE} (or, equivalently, of
type @code{java.lang.Class}); it returns @code{true}
if the left-hand argument is the same type as or a subtype of the right-hand
argument. 
@*@strong{Status: }Implemented.

@cindex @code{<}
@cindex @code{<=}
@item @code{<} , @code{<=} : 
In addition to their usual meaning in Java (and corresponding meanings in JML), the
less-than and less-than-or-equal operators are used to compare locks.  Any object that is listed as a 
monitor (in a @code{monitors_for} clause) or is identified implicitly or 
explicitly in a Java synchronization statement is a lock,
in addition to its declared use as an object.  In order to reason about deadlocks,
the user must define a partial order on locks and have the code acquire the locks
only in increasing order.  The partial order may be defined using @code{axiom} clauses;
the operators are used to compare locks by this partial order.  
They take two locks as arguments and return
@code{true} if the left-hand object is less than (or less than or equal to,
respectively) the right-hand object according to the partial order axioms,
and returns @code{false} otherwise.
The comparison is independent of whether the locks have actually been acquired; 
the @code{\lockset} expression supplies that information.  The ESC/Java User's
Manual provides additional information and examples about Deadlock and Race detection.
@*@strong{Status: }Implemented. [[[ Are they in JML ???]]]
@end itemize


@subsection New JML expressions (functions and values)

@itemize @bullet

@cindex \result
@item \result : This keyword denotes the result of a method that returns a value.
It may be used in an @code{ensures} clause (but not a @code{signals} clause.
[[[ What about duration, working_space clauses ]]]
@*@strong{Status:} Implemented.

@cindex \old
@item \old : This pseudo-function takes one argument of any type and returns the value
of its argument.  It is used to indicate that the expression which is its argument
must be evaluated in the pre-state.  It is used in ensures and signals clauses to
distinguish pre- and post-state values.
@*@strong{Status: } Implemented.

@item \not_modified This function of a single argument returns a boolean value
indicating whether the argument has the same value in the pre- and post-state.  It
may be used in an ensures clause.  It is equivalent to @code{x == \old(x)}.
@*@strong{Status: } Implemented (not part of the original ESC/Java). [[[ JML allows multiple arguments, equivalent to the conjunction of the single-argument results. Esc/Java2 does not. ]]]

@item \fresh [[[ description, status, differences needed here ]]]
@item \reach [[[ description, status, differences needed here ]]] - deprecated
@item \duration - [[[ description, status, differences needed here ]]]
@item \space - [[[ description, status, differences needed here ]]]
@item \working_space - [[[ description, status, differences needed here ]]]

@item \nonnullelements - [[[ description, status, differences needed here ]]]
@item \typeof - [[[ description, status, differences needed here ]]]
@item \elemtype - [[[ description, status, differences needed here ]]]
@item \type - [[[ description, status, differences needed here ]]]

@item \is_initialized - [[[ description, status, differences needed here ]]]
@item \invariant_for - [[[ description, status, differences needed here ]]]
@item \lblneg - [[[ description, status, differences needed here ]]]
@item \lblpos - [[[ description, status, differences needed here ]]]

@cindex @code{\lockset}
@item \lockset : This value has type @code{\LockSet}.  The value is the set of objects whose
locks are held by the current thread. 
@*@strong{Status:} This feature is fully implemented by ESC/Java2 (as inherited from ESC/Java).

@cindex \lockset membership
@item membership in a \lockset : A @code{\lockset} contains objects.  Membership
in a @code{\lockset} is tested using this syntax, for some object expression
@code{o} : @code{\lockset[o]} .  This expression returns a boolean, which is true
if the object is in the lockset.
@*@strong{Status:} This feature is fully implemented by ESC/Java2 (as inherited from ESC/Java). [[[ Is it in JML ? ]]]

@cindex @code{\max}
@item @code{\max} : This function takes an argument of type @code{\LockSet}.  
It returns an object of type @code{java.lang.Object}.  The result is one of the
elements of the argument; the function satisfies the following for any 
@code{\LockSet} @code{s} and Object @code{o}: @code{s[o] ==> (o <= \max(s))}.
@*@strong{Status:} This feature is fully implemented by ESC/Java2 (as inherited from ESC/Java).


@item Operators for overflow checking : These are under development in JML and are
not yet implemented in ESC/Java2.


@cindex informal predicate
@cindex (*
@cindex *)
@item @emph{informal predicate} : An informal predicate consists of text 
(not including newline or carriage return characters) enclosed
within the delimiters @code{(*} and @code{*)}.  Informal predicates are interpreted
as boolean expressions that are always true (independent of what the text may say!),
and they may only be used in 
contexts where a boolean expression is allowed. 
@*@strong{Status: }This feature is fully implemented
in ESC/Java2 (as well as ESC/Java).


@end itemize

@subsection New JML types

JML adds some new types that may be used as type names in declarations of
variables within annotations.

@itemize @bullet

@cindex @code{\TYPE}
@item @code{\TYPE} : This is a JML type name used to denote the type of type designations.
For example, @code{\typeof} and @code{\type} produce results of type @code{\TYPE}, 
and the @code{<:} operator takes arguments of type @code{\TYPE}.  Values of type
@code{\TYPE} can also be compared using the @code{==} operator.
@*@strong{Status:} This is fully implemented.  
[[[ In JML \TYPE and java.lang.Class are now equivalent.  This is not yet the case in
ESC/Java2. ]]]

@cindex @code{\bigint}
@item @code{\bigint} : This is a new type name used in JML to denote an integral type 
equivalent to the mathematical integers.  That is, it has infinite range and no
underflow or overflow as a result of a fixed bit depth.
@*@strong{Status:} The type name is parsed but is equivalent to @code{long}.

@cindex @code{\real}
@item @code{\real} : This is a new type name used in JML to denote a type 
equivalent to the mathematical real numbers.  That is, it has infinite range 
and precision and no
underflow, overflow, or rounding error as do @code{float} and @code{double}.
@*@strong{Status:} The type name is parsed but is equivalent to @code{double}.

@cindex @code{\LockSet}
@item @code{\LockSet} : This type may not be named (there is no token @code{\LockSet}).  However the type is implicitly used as the type of the JML token
@code{\lockset}, as the type of the argument of @code{\max}, and in the LockSet
membership operation.

@end itemize

@cindex quantified expressions
@cindex @code{\forall}
@cindex @code{\exists}
@cindex @code{\num_of}
@cindex @code{\max}
@cindex @code{\min}
@cindex @code{\sum}
@cindex @code{\product}
@subsection quantified expressions - \forall, \exists, \num_of, \max, \min, \sum, \product
As described in the JML documentation, quantified expressions take the form
@*@center{@code{( @emph{quantifier-keyword} @emph{type} @emph{idlist} ; @emph{range-expr} ; @emph{expr} )}}
@*or
@*@center{@code{( @emph{quantifier-keyword} @emph{type} @emph{idlist} ; ; @emph{expr} )}}
@*or
@*@center{@code{( @emph{quantifier-keyword} @emph{type} @emph{idlist} ; @emph{expr} )}}
@*The @emph{range-expr} is a boolean expression; its default value is @strong{true}.
The @emph{idlist} is a comma-separated list of identifiers; these are the bound
variables of the quantification.
@*@strong{Status:} 
@itemize @bullet
@item @code{\forall}, @code{\exists}: Fully implemented and used in static checking.
@item @code{\num_of}, @code{\max}, @code{\min}, @code{\sum}, @code{\product}:
 Parsed and ignored.  The expressions are translated to values of 0, and so may lead to unexpected results.
@end itemize
@noindent
@strong{Comment:} The keyword @code{\max} is used both as a quantifier and as
a function.  The parser is able to distinguish the two usages.

@cindex set comprehension
@subsection set comprehension

JML has a syntax for expressions whose value is a set.  An example is
@*@center{@code{new JMLObjectSet @{ Integer i | o.has(i) && i.intValue() > 0 @}}}

@noindent
No side-effects are permitted in the predicate.
@*@strong{Status: }ESC/Java2 parses and typechecks set comprehension expressions, with
the following omissions:
@itemize @bullet
@item Expressions containing set comprehension are not used in static checking
@item No restrictions on the type of the set are imposed
@item The JML restrictions on the form of the predicate are not checked
@item ESC/Java2 should check and forbid Java or JML modifiers in the bound variable declaration
@end itemize

@subsection \not_specified
This may be used, within the guidelines of the JML grammar, as the predicate or
store-ref expression in an annotation clause.  JMJL allows tools to provide their 
own behavior for @code{\not_specified}.  Escjava2 treats such clauses as if they
were not present, making them equivalent to the default for that clause type.
@*@strong{Status: } Fully implemented.

@subsection \private_data
[[[ description, status, differences needed here ]]]


@subsection \other 
[[[ description, status, differences needed here ]]]


@subsection new instance expressions
[[[ description, status, differences needed here ]]]

@subsection new array expressions
[[[ description, status, differences needed here ]]]

@subsection Other Java operators and expression syntax
[[[ description, status, differences needed here ]]]

@section store-ref expressions

[[[ This whole section needs thorough correction and review ]]]

Some annotations require a list of @emph{store-ref expressions}, which are 
expressions whose value is a set of references to fields of classes or objects;
in particular, the value has type @code{org.jmlspecs.models.JMLObjectSet}.
For example, the @code{modifies} clause designates a set 
(that is, a @code{JMLObjectSet} of @emph{store-refs} that
are allowed to be assigned to within a method.  This section describes the 
syntactic features that designate such sets.  [[[ Not sure this is right in the
wake of data groups and in/maps clauses ]]]




@subsection [ @emph{ident} | @code{super} | @code{this} ] @code{.} [ @emph{ident} | @code{this} ]
This designates a field of an object.  [[[ Describe the function of the this suffix]]]
@*@strong{Status: } Implemented within modifies clauses.

@subsection [ @emph{ident} | @code{super} | @code{this} ] @code{.*}  
This designates all static and instance fields, of any privacy level, including
those inherited from superclasses and interfaces, of the given object.
@*@strong{Status: } Not implemented.

@subsection [ @emph{ident} | @code{super} | @code{this} ] @code{[@emph{expr}]}  
This designates an element of the given array object.   [[[ Describe the function of the this and super prefix ]]]
@*@strong{Status: } Implemented within modifies clauses.
Not
@subsection [ @emph{ident} | @code{super} | @code{this} ] @code{[@emph{expr}..@emph{expr2}]}  
This designates a range of elements of the given array object.
@*@strong{Status: } Not implemented.

@subsection [ @emph{ident} | @code{super} | @code{this} ] @code{[*]}  
This designates all the elements of the given array object.
@*@strong{Status: } Not implemented.

@subsection @emph{classname}.* 
This designates all static fields, of any privacy level, including
those in superclasses and interfaces, of the given class.
@*@strong{Status: } Not implemented.

@cindex \nothing
@subsection \nothing 
This designates an empty set of store-refs.  It may be used with the 
@code{modifies}, @code{accessible}, and @code{callable} clauses.
If @code{\nothing} appears in a sequence of store-refs, it is ignored.
@*@strong{Status: } Fully implemented.

@cindex \everything
@subsection \everything 
This designates a universal set - the set of references to all object and class
fields for every object and class allocated in the current state of the program.
  It may be used with the 
@code{modifies}, @code{accessible}, and @code{callable} clauses.
@*@strong{Status: } Fully parsed - refer to the clause descriptions for specific
behavior.

@cindex model program statements
@node Statements within model programs, ???, ???, ???
@section Statements within model programs
A model program consists of imperative programming statements and control 
structures, much like a typical Java program.  However, a model program allows
some non-deterministic (and non-Java) statements as well.  These are described in 
this section.

[[[ Need enumeration and discussion of these. ]]]


@section Other issues
[[[ descriptions needed here ]]]

[[[ Use of JMLDataGroups in modifies clauses; what syntactic structures use stsore-refs? ]]]

@subsection nowarn annotations
JML allows an annotation to suppress warnings otherwise produced by the static checker.  These are discussed in @ref{Nowarn annotations and warnings}.

@c --------------------- Java and JML assert statements
@node Java and JML assert statements, ???, ???, ???
@subsection Java and JML assert statements

JML has an assert statement of the form
@*@center{@code{//@@ assert }@emph{predicate}@code{;}}
@*The static checker will evaluate the predicate in the appropriate context.  If it
cannot establish that the predicate is always true, an ESC/Java warning will be
issued.

Java 1.4 also has an assert statement with the syntax
@*@center{@code{assert }@emph{value}@code{: }@emph{predicate}@code{;}}
@*If the predicate is not true, then a @code{java.lang.AssertionError} is created,
with the given @emph{value} as its argument, and the exception is thrown.

In versions of Java before 1.4, @code{assert} was a legitimate identifier name; in
Java 1.4 it is a keyword and may not be used as an identifier.  To achieve
backwards compatibility, Java compilers have a @code{-source} command line option;
ESC/Java2 behaves in a way similar to typical Java compilers:
@itemize @bullet
@item specifying 
@code{-source 1.4} causes ESC/Java2 to interpret @code{assert} as a keyword;
@item 
omitting the @code{-source} option or specifying an argument other than @code{1.4}
causes ESC/Java2 to treat @code{assert} as an identifier and to issue errors
 on encountering uses
of the word as a keyword.
@end itemize

There are three options for how ESC/Java2 should treat Java @code{assert}
 statements (when @code{-source 1.4} is specified).  ESC/Java2 provides 
command-line options to achieve each of these behaviors.
@enumerate A
@item Parse but ignore them.
@item Treat them as Java does, namely, as equivalent to 
@*@center{@code{if ( ! }@emph{predicate}@code{) throw new java.lang.AssertionError(}@emph{value}@code{);}}
@item Treat them as a JML assert statement, namely, as equivalent to
@*@center{@code{//@@ assert }@emph{predicate}@code{;}}
@end enumerate
@noindent
The command line options for these three cases are
@enumerate A
@item @code{-source 1.4}
@item @code{-javaAssertions} or @code{-eajava}
@item @code{-jmlAssertions} or @code{-eajml}
@end enumerate
@noindent


Note that there are, internally, three independent conditions:
@itemize @bullet
@item The version of Java being recognized.  This is controlled by the @code{-source} option.
@item Whether Java assert statements are enabled (given that Java 1.4 source is
being processed).  Java has them disabled by 
default.  This is controlled by the options @code{-disableassertions}, 
@code{-enableassertions}, @code{-da}, @code{-ea}.  The use, as in Java, of
package names with these assertions or of enabling or disabling system
assertions is not implemented in ESC/Java2.
@item Whether to treat Java 1.4 assert statements in Java mode or JML mode (given
that Java assertions are enabled).  This is controlled by the
@code{-javaAssertions} and @code{-jmlAssertions} options.  @code{-javaAssertions}
is the default; both options also effectively do @code{-source 1.4 -ea}.
@end itemize


Here are some examples of use:
@itemize @bullet
@item  
@example
        public void m() @{
                assert false : "Message";
        @} 
@end example
@noindent 
Java behavior: ESC/Java2 will issue an Unexpected Exception warning
@*JML behavior: ESC/Java2 will issue an Assert warning

@item  
@example
        public void m() @{
                assert false : "Message"; \\ nowarn;
        @} 
@end example
@noindent 
Java behavior: ESC/Java2 will issue an Unexpected Exception warning
@*JML behavior: ESC/Java2 will not issue any warning (suppressed by the nowarn annotation)

@item  
@example
        public void m() @{
                assert true : "Message";
        @} 
@end example
@noindent
Java behavior: No warnings - no exception ever thrown
@*JML behavior: No warnings - predicate is always true

@item  
@example
        //@ exsures (java.lang.AssertionError e) true;
        public void m() @{
                assert false : "Message";
        @} 
@end example
@noindent
Java behavior: ESC/Java2 will issue an Unexpected Exception warning
@*JML behavior: ESC/Java2 will issue an Assert warning
@* [[[ There may be a bug here - ESC/Java complains about types in an exsures
clause that are not in the throws list of the declaration, but ESC/Java2 does not.]]]

@item  
@example
        //@ exsures (java.lang.AssertionError e) true;
        public void m() throws AssertionError @{
                assert false : "Message"; 
        @} 
@end example
@noindent
Java behavior: No warnings - the exsures clause allows the exception.
@*JML behavior: Assert error.


@item  
@example
        //@ exsures (java.lang.AssertionError e) false;
        public void m() throws AssertionError @{
                assert false : "Message"; 
        @} 
@end example
@noindent
Java behavior: Postcondition warning - the exsures clause disallows the exception.
@*JML behavior: Assert error.


@end itemize

@subsection Methods and constructors without bodies in Java files

Java requires non-abstract, non-final methods and constructors to have a defined
body.  Some tools, such as javadoc, allow the bodies to be stubbed with a 
semicolon in place of the usual block statement.  ESC/Java2 also allows methods
and constructors within .java files to be represented simply by a semicolon.  This
allows classes to be documented and specified before the implementation is 
completed.  JML tools (except jmldoc) and ESC/Java require bodies to be present.

@subsection Methods and constructors in annotation expressions

JML allows the use of pure methods and constructors in annotation expressions; 
the original ESC/Java did not.  ESC/Java2 follows JML.  However, there is as yet
no static checking of expressions containing methods and constructors.

@subsection  Original ESC/Java also_ specifications

The original ESC/Java utilized the keywords @code{also_requires}, @code{also_ensures},
@code{also_exsures}, and @code{also_modifies} to add annotations to subclasses.  The
semantics was such that these annotations were simply textually conjoined with the 
annotations from a super class or interface.  The syntax and semantics in JML and
ESC/Java2 has changed.  These keywords are now deprecated and are translated into
the corresponding keyword without @code{also_}.  However, the semantics of annotations
in the presence of inheritance is now somewhat different and 
is described by the desugaring process
(@pxref{Desugaring}).

@subsection  anonymous classes

Java allows anonymous classes that are named classes with some method overrides.
An anonymous class is a subclass of the named class and is nested within the
class in which it is defined.  One can add specifications to the anonymous class
body and the members within it.  However, since there are no quantities declared with
the static type of the anonymouse type, those specifications are not used in 
checking any uses of the routines of the anonymous class.
ESC/Java2
does recognize that the anonymous class is a subclass and not the same class as its
super class.

@*@strong{Status: }There is no checking of the implementation of any of the methods
of an anonymous class.

@subsection block-level class declarations

[[[ comments ]]]

@subsection  @code{field}, @code{method} and @code{constructor} keywords

JML is designed to work with any Java code.  In particular that code may use
JML keywords as variables and type names.  This can create a problem in parsing
annotations.  For example, if @code{helper} has been declared a class, then an
 annotation that begins with
@center{@code{//@@ helper model ...}}
@noindent
@*could be interpreted as the beginning of a declaration with type @code{helper} and
identifier @code{model} or as the beginning of a model method declaration with JML
modifier helper.  Though in some cases sufficient lookahead could distinguish these
different uses, JML has defined the keywords @code{field}, @code{method}, and
@code{constructor} to help disambiguate such situations.  These are used in ghost
and model field, method, and constructor declarations.  They have the effect that
any identifiers appearing after these keywords in a JML annotation are not
interpreted as JML keywords (except for non_null in formal parameters as described
below).  For example, in
@*@center{@code{//@@ public model non_null helper method requires ensures() @{@};}}
@noindent
@*@code{non_null} and @code{helper} are JML keywords, but @code{requires} is 
expected to be a Java type name and @code{ensures} is interpreted as an identifier,
the name of the method being declared.

The one exception to this rule is that @code{non_null} is needed as a JML modifier
within the formal parameter declarations.  A parser is capable of distinguishing
these cases, however.  Thus in 
@*@center{@code{//@@ public model requires ensures(non_null Object o, non_null oo);}}
@noindent
@*the first occurrence of @code{non_null} is a JML modifier, but the second is
expected to be a Java type name.
[[[ ESC/Java treats non_null specially in this case, but the JML tools do not.  For
JML you cannot use non_null here and need to write explicit pre/post-conditions instead.]]]
@noindent
@code{Status: } Fully implemented.

@subsection Equivalence of @code{\TYPE} and @code{java.lang.Class}

In Java, the types of classes can be treated as first class values of type
@code{java.lang.Class}.  In JML the type @code{\TYPE} has been defined as the type 
type values.  The following table shows the relationships between Java and JML
syntax and quantities.  In the following @code{T} is a type name, 
such as @code{java.lang.String}, @code{t} is an expression of @code{\TYPE} type, and
@code{e} is an expression of any type.

@multitable @columnfractions .45 .20 .35
@item
	@tab JML
	@tab Java
@item Type names denoting the type of type values
	@tab \TYPE
	@tab java.lang.Class
@item Expression whose value is the type value corresponding to a given type name
	@tab @code{\type(T)}
	@tab @code{T.class}
@item Expression whose value is the type value corresponding to the name in a String
	@tab
	@tab @code{Class.forName(s)}
@item Expression whose value is the type value corresponding to the dynamic type of an expression 
	@tab @code{\typeof(e)}
	@tab @code{e.getClass()}
@item subtype relationship between two type values 
	@tab @code{t1 <: t2}
	@tab @code{t2.isAssignableFrom(t1)}
@item Expression has type or is subtype of type name
	@tab @code{\typeof(t) <: \type(T)}
	@tab @code{t instanceof T}
@item A type value corresponding to the element type of an array type
	@tab @code{\elemtype(t)}
	@tab @code{t.getComponentType()}
@end multitable

In JML, @code{\TYPE} and @code{java.lang.Class} have been made equivalent; thus the 
corresponding quantities in each row may be used interchangeably (in annotations).
However, this equivalence is not yet implemented in ESC/Java2.

The location where the equivalence is particularly needed is in writing the 
specifications for a method such as @code{java.lang.Object.getClass()}, which is
inherited by every reference type in Java.  The natural specification 
(in java.lang.Object) is
@example
//@@ ensures \result == \typeof(this);
java.lang.Class getClass();
@end example
@noindent
which can only be written if the type of the left-hand-side (@code{java.lang.Class})
can be compared to the type of the right-hand-side (@code{\TYPE}).

@subsection exceptions in annotation expressions
[[[Discuss the behavior of logical and short-circuit operators in the presence of undefined expressions (or expressions that throw exceptions).]]]

@c ----------------------- Specifications and inheritance
@node Specifications and inheritance, ???,???,???
@subsection Specifications and inheritance

@subsubsection Desugaring in the presence of inheritance
ESC/Java has some limitations and some unsoundness in handling the inheritance of
specifications.  If a superclass stated a precondition (with a requires clause), 
then a subclass could not state an additional precondition.  If a superinterface
stated a precondition, an implementing class was permitted to state a precondition
using the @code{also_requires} keyword, but the discussion in the ESC/Java User's
Manual acknowledged this to be an unsound construct.

ESC/Java2 has corrected this problem by using the syntax and desugaring approach
outlined by JML.  JML allows subclasses to have additional @code{requires} clauses,
and does not utilize the @code{also_requires} syntax.
Consider the following example (the handling of super interfaces is the same as the
handling of super classes):
@example
public interface Super @{
        //@@    requires P1;
        //@@    ensures Q1;
        public void m();
@}

public class D extends Super @{
        //@@ also
        //@@    requires P3;
        //@@    requires PP3;
        //@@    ensures Q3;
        public void m();
@}
@end example
@noindent
Now ESC/Java would combine the interface and subclass specifications as follows:
@example
        //@@ requires P1;
        //@@ requires P3;
        //@@ requires PP3;
        //@@ ensures Q1;
        //@@ ensures Q3;
@end example
@noindent
This does not satisfy behavior inheritance.  The desugaring provided by ESC/Java2
is correct:
@example
        //@@ requires P1 || (P3 && PP3);
        //@@ ensures P1 ==> Q1;
        //@@ ensures (P3 && PP3) ==> Q3;
@end example

Here is a larger example:
@example
public class Super @{
        //@@    requires P1;
        //@@    ensures Q1;
        //@@ also
        //@@    requires P2;
        //@@    ensures Q2;
        public void m();
@}

public class D extends Super @{
        //@@ also
        //@@    requires P3;
        //@@    requires PP3;
        //@@    ensures Q3;
        //@@ also
        //@@    requires P4;
        //@@    ensures Q4;
        public void m();
@}
@end example
@noindent
The specifications in @code{Super} desugar (in ESC/Java2) to
@example
        //@@ requires P1 || P2;
        //@@ ensures P1 ==> Q1;
        //@@ ensures P2 ==> Q2;
@end example
@noindent
The specifications in @code{D} desugar to
@example
        //@@ requires (P3 && PP3) || P4;
        //@@ ensures  (P3 && PP3) ==> Q3;
        //@@ ensures  P4 ==> Q4;
@end example
@noindent
but they are then combined with the super class specifications to produce the composite specification:
@example
        //@@ requires P1 || P2 || (P3 && PP3) || P4;
        //@@ ensures  P1 ==> Q1;
        //@@ ensures  P2 ==> Q2;
        //@@ ensures  (P3 && PP3) ==> Q3;
        //@@ ensures  P4 ==> Q4;
@end example

With this approach the unsoundness of @code{requires} noted in section C.0.4 of the
ESC/Java User's Manual is corrected.  However, the behavior of some specifications
will change, since specifications of an overriding method are no longer 
simply textually conjoined with the specifications of an overridden method.  For
example in ESC/Java, the specification of @code{m()} in this code
@example
public class Super @{
        //@@ requires i > 0;
        public int m(int i) @{...@}
@}
public class D @{
        //@@ ensures \result > 0;
        public int m(int i) @{...@}
@}
@end example
@noindent
was interpreted as
@example
        //@@ requires i > 0;
        //@@ ensures \result > 0;
@end example
@noindent
whereas in ESC/Java2 it is
@example
        //@@ requires i > 0 || true;
        //@@ ensures i > 0 ==> true;
        //@@ ensures true ==> \result > 0;
@end example
@noindent
which is equivalent to
@example
        //@@ requires true;
        //@@ ensures \result > 0;
@end example

@cindex clause defaults
@cindex defaults
@cindex inheritance of specifications
@subsubsection Defaults and inheritance

The defaults for missing clauses were described in @ref{Lightweight and heavyweight specifications}. The effect of
the default for @code{requires} is demonstrated in these examples.

Given
@example
class Super @{
        //@@ requires P;
        //@@ ensures Q;
        public void m();
@}

class Derived extends Super @{
        // no spec given - default is 'requires false'
        public void m();
@}
@end example
@noindent the two classes behave as if they had these specifications
@example
class Super @{
        //@@ requires P;
        //@@ ensures P ==> Q;
        public void m();
@}

class Derived extends Super @{
        //@@ also
        //@@ requires P;
        //@@ ensures P ==> Q;
        public void m();
@}
@end example


Given
@example
class Super @{
        // no spec given - default is 'requires true'
        public void m();
@}

class Derived extends Super @{
        //@@ also
        //@@ requires P;
        //@@ ensures Q;
        public void m();
@}
@end example
@noindent the two classes behave as if they had these specifications
@example
class Super @{
        //@@ requires true;
        public void m();
@}

class Derived extends Super @{
        //@@ also
        //@@ requires true;
        //@@ ensures P ==> Q;
        public void m();
@}
@end example

Finally, given
@example
class Super @{
        // no spec given - default is 'requires true'
        public void m();
@}

class Derived extends Super @{
        // no spec given - default is 'requires false'
        public void m();
@}
@end example
@noindent the two classes behave as if they had these specifications
@example
class Super @{
        //@@ requires true;
        public void m();
@}

class Derived extends Super @{
        //@@ also
        //@@ requires true;
        public void m();
@}
@end example

[[[ What does jmlrac do with this issue?]]]

@node Inheritance and non_null, ???, ???, ???
@subsubsection Inheritance and non_null

The syntactic rules and semantic meaning of 
@code{non_null} on formal parameters in the presence of inheritance
differ between ESC/Java and ESC/Java2.
A @code{non_null} annotation on a formal parameter is equivalent to 
(a) a requirement that the parameter not be assigned a null value in the body
of the implementation of the routine, and
(b) an additional
precondition in all of the specification cases of the method's (or constructor's)
specifications.  Item (b) means that
@example
... specifications ...
public void m(/*@@ non_null */ Object o, Object oo)
@end example
@noindent
is equivalent to
@example
//@@ requires o != null;
//@@ @{|
     ... specifications ...
//@@ |@}
@end example
@noindent
Similarly a non_null annotation on the result is equivalent to an additional
post-condition:
@example
... specifications ...
public /*@@ non_null*/ Object m()
@end example
@noindent
is equivalent to
@example
//@@ ensures o != null;
//@@ @{|
     ... specifications ...
//@@ |@}
@end example
@noindent
[ This syntax is not legal JML since an ensures may not appear outside of the
nested specifications, but the intent is evident: the ensures clause is distributed
to each specification case. ]

Confusing situations can arise if formal parameters in a overridden and overiding
declaration differ in non_null annotations. 

@itemize @bullet
@item Case 1: Super class has non_null, subclass has a spec, but no non_null

@example
class Super @{
    public void nonnull(/*@@ non_null */ Object o);
        
    public void m(/*@@ non_null */ Object o) @{
        nonnull(o);           // Line A - OK
        o = null;             // Line B - FAILS
    @}
@}
class Derived extends S @{
    //@@ also
    //@@ requires true; 
    public void m(Object o) @{
        nonnull(o)            // Line C - FAILS
        o = null;             // Line D - OK
    @}
 
    public void mm() @{
        Object o;
        m(o);                 // Line E - OK
        (new S()).m(o);       // Line F - FAILS
    @}
@}
@end example
In this case, ESC/Java has @code{Derived.m} inherit the non_null specification from the
overridden method.  Hence ESC/Java reports errors for lines B, D, E and F, with A and C being OK.
In ESC/Java2, however, @code{Derived.m} has its own specification
and so does not inherit the non_null specification.
It must still satisfy the parent spec (which in this case simply has a trivial
postcondition).  So Lines B and F are errors and A is not.  However, the combined spec for
@code{Derived.m} is (ignoring other clause types)
@example
        requires o != null;
        ensures true;
        also
        requires true;
        ensures true;
@end example
which is equivalent to @code{requires true;}.  Thus lines D and E are OK, and C
will provoke an error.

If the precondition were @code{requires false;}, then the combined spec would be
@example
        requires o != null;
        ensures true;
        also
        requires false;
@end example
@noindent
which is equivalent to @code{requires o != null;}.  Then E would fail, and C and D
would be OK.  In otherwords, it is the same as Case 2 below.


 
@item Case 2: Super class has non_null, subclass has no spec and no non_null

@example
class Super @{
    public void nonnull(/*@@ non_null */ Object o);
        
    public void m(/*@@ non_null */ Object o) @{
        nonnull(o);           // Line A - OK
        o = null;             // Line B - FAILS
    @}
@}
class Derived extends S @{

    public void m(Object o) @{
        nonnull(o); // Line C - OK - precondition limits values of o
        o = null;   // Line D - OK - no restriction on 
                    //               assignments in this body
    @}

    public void mm() @{
        Object o;
        m(o);                 // Line E - FAILS
        (new S()).m(o);       // Line F - FAILS
    @}
@}
@end example
In this case Derived.m has no specification.  Consequently it has a default
specification of @code{requires false;} and effectively inherits the overridden
method's specification, including the @code{non_null}.
Lines B and F are still errors, and A is not, because of the specification of Super.m; 
lines D and E are errors, and C is not.
 

@item Case 3: Super class has no non_null, but subclass does

@example
class Super @{
    public void nonnull(/*@@ non_null */ Object o);
        
    public void m(Object o) @{
        nonnull(o);           // Line A - FAILS
        o = null;             // Line B - OK
    @}
@}
class Derived extends S @{

    public void m(/*@@ non_null */ Object o) @{
        nonnull(o);      // Line C - FAILS - annotation ignored
        o = null;        // Line D - OK - annotation ignored
    @}
 
    public void mm() @{
        Object o;
        m(o);                 // Line E - OK
        (new S()).m(o);       // Line F - OK
    @}
@}
@end example
@noindent In this case, it is the derived class that has the @code{non_null} specification,
but not the super class.  This is a problematic case, since the body of the
overriding method may be called through the overridden signature, in which case
the actual argument may not be constrained to be non_null.  Hence the non_null
annotation on the overriding formal paramater can be misleading.  Therefore in
ESC/Java2, a non_null annotation is ignored if there is any overridden method that
has that formal parameter declared without a non_null argument.  A caution message
is provided to warn the user of this behavior. 

Thus, ESC/Java2 will allow lines B and F since the super class does not limit the values
of the parameter; similarly line A provokes an error.  Although the parameter of
@code{Derived.m} is declared @code{non_null}, the @code{non_null} annotation 
is ignored.  Consequently, there is no limitation on the value of the formal
parameter (since it may have been called through the super class's signature), and
hence line C fails; similarly, there is no limitation on what may be assigned to
the formal parameter variable, so line D is ok.  Finally, line E is ok since there
is no additional precondition created by the ignored @code{non_null}.

Note that 
 behavior equivalent to the @code{non_null} declaration on a formal parameter
can be obtained by adding appropriate explicit
preconditions requiring the formal parameter to be non_null in the appropriate
circumstances.  Furthermore, if it is actually desired to have the formal
parameter be non_null within the body, code such as the following can be
written.  Instead of
@example
        public void m(/*@@ non_null */ Object o) @{
                ...
        @}
@end example
@noindent write
@example
        public void m(Object oo) @{
                /*@@ non_null */ Object o = oo;
                ...
        @}
@end example
@end itemize  

Finally note that
@itemize @bullet
@item ESC/Java does not allow overriding methods to have
non_null parameters, whether or not the overridden method does.
@item There are no particular issues with respect to @code{non_null} on the result
type; overriding and overridden methods may have any combination of @code{non_null}
annotations or lack thereof.
@end itemize  


[[[ What does jmlrac do with the inheritance of non_null? ]]]

@chapter ESC/Java2 features

This chapter describes some of the features and usage of ESC/Java2.

@c ------ section Error and warning messages --------
@node Error and warning messages, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Error and warning messages

@cindex error messages
@cindex fatal errors
@cindex cautions
@cindex warnings
ESC/Java2 continues ESC/Java's use of four levels of error messages:
@itemize @bullet
@item  @strong{fatal} errors are problems (usually invalid syntax) that prevent 
ESC/Java from proceeding further in parsing and checking files;
@item  @strong{errors} indicate illegally formed input files, though processing may
continue to find other errors or even to attempt static checking of the files 
(errors or checks subsequent to the first problem may be erroneous as a result of
earlier problems);
@item  @strong{cautions} indicate situations that are not illegal, but may be
misleading to the user - a common example is features that are parsed 
but not checked (also some illegal JML constructs are reported using cautions if 
ESC/Java2 can unambiguously correct them);
@item  @strong{warnings} indicate situations in which the static checking phase could
not determine that annotation specifications were satisfied, such as an inability
to determine that an object reference is non-Null when it is dereferenced.
@end itemize
The reporting of cautions and warnings can be controlled by command-line options
 (@code{-noCautions}, @code{-nowarn}, @code{-warn}, @code{-nocheck}).

@c ------ Nowarn annotations and warnings --------
@node Nowarn annotations and warnings, ???, ???, ???
@c  node-name,  next,  previous,  up
@section Nowarn annotations and warnings
@subsection nowarn annotations
@itemize @bullet
@item @strong{Description:} 
A nowarn annotation has the form
@*@center{@code{//@@ nowarn @emph{comma-separated-list-of-warning-types};}}
@*or simply
@*@center{@code{//@@ nowarn ;}}
@*The annotation is associated with the line in the source file on which it is located, rather 
than with a grammatical construct.  It is used to suppress warnings from the
static checker associated with a construct on that line.  If there is no list of
warning types, then all warnings associated with this line are suppressed.  
The warnings of a given type can also be suppressed using command-line options.
The nowarn annotations have no effect on errors or cautions, since these are
produced by parsing or semantic errors in the source code itself.

@item @strong{Status:} Implemented.

@item @strong{Differences from JML or Java:} JML supports the parsing of these
annotations, but since JML does no static checking, it ignores them.  ESC/Java
did not require a terminating semicolon, but JML does.  ESC/Java2 accepts 
nowarn annotations with or without a terminating semicolon; it issues a caution if the
semicolon is missing.  [[[ JML should allow a nowarn without a list to be 
terminated by an end of line. ]]]
@end itemize


@subsection nowarn warning types

The static checker used in ESC/Java2 (and in ESC/Java) produces warnings (as
opposed to errors or cautions) when it detects source code that might violate the
specifications.  These warnings are categorized into types and can be suppressed
or enabled by warning type name, using either the 
@code{nowarn} annotation or the command-line options @code{-nowarn}, which 
suppresses individual warning types, or @code{-warn}, which 
enables individual warning types, or @code{-nocheck}, which turns off all 
static checking.  The following list of the warning types is
excerpted (except where additions are explicitly noted) and quoted from the 
"ESC/Java User's Manual".

The additional warning pseudo-type name "All" may be used with the @code{-nowarn}
command-line option to turn off all warnings; @code{-warn} may then be used to
selectively turn on individual warning types.  The "All" type may not be used 
with @code{-warn}.

@itemize @bullet
@item
@strong{ArrayStore} warns that the control may reach an assignment
@code{A[I] = E} when the value of
@code{E} is not assignment compatible with
the actual element type of @code{A}.

@item
@strong{Assert} warns that control may reach a pragma 
@code{assert E} when the value of @code{E} is false.

@item
@strong{Cast} warns that control may reach a cast @code{(T)E}
when the value of @code{E} cannot be cast to the type @code{E}.

@item
@strong{Deadlock} warns that control may reach a @code{synchronized}
statement that would acquire a lock in violation of the locking order,
or that a @code{synchronized} method may start by acquiring a lock
in violation of the locking order.

@item
@strong{Exception} warns that a routine may terminate abruptly by
throwing an exception that is not an instance of any type listed explicitly
in the routine's throws clause.

@item
@strong{IndexNegative} warns that control may reach an array access
@code{A[I]}
when the value of the index
@code{I} is negative.

@item
@strong{IndexTooBig} warns that control may reach an array access
@code{A[I]}
when @code{A.length <= I}.

@item
@strong{Invariant} warns that some object invariant may not hold
when control reaches a routine call, or that some object invariant may
not hold on exit from the current body.

@item
@strong{LoopInv} warns that some loop invariant may not hold when
it is supposed to.

@item
@strong{OwnerNull} warns that a constructor may violate the implicit
postcondition @code{this.owner != null}.

@item
@strong{NegSize} warns of a possible attempt to allocate an array
of negative length.

@item
@strong{NonNull} warns of a possible attempt to assign the value
null to a variable whose declaration is modified by a @code{non_null}
pragma, or to call a routine with an actual parameter value of null when
the declaration of the corresponding formal parameter is modified by (or
inherits) a @code{non_null} pragma.

@item
@strong{NonNullInit} warns that a constructor may fail to establish
a non-null value for an instance field of the constructed object when the
declaration of that instance field is modified by a @code{non_null} pragma.

@item
@strong{Null} warns of a possible attempt to dereference null, for
example, by field access @code{O.f}, an array access @code{O[i]}, a
method call @code{O.m(...)}, a synchronized statement @code{synchronized
(O) ...}, or a throw statement @code{throw O}, where @code{O} evaluates
to @code{null}.

@item
@strong{Post} warns that a routine body may fail to establish some
normal postcondition (on terminating normally) or some exceptional postcondition
(when terminating by throwing an exception of a relevant type).

@item
@strong{Pre} warns that control may reach a routine call when some
precondition of the routine does not hold.

@item
@strong{Race} warns of a possible attempt to access a monitored
field while not holding the requisite lock(s).

@item
@strong{Reachable} warns that control may reach an @code{unreachable}
pragma.

@item
@strong{Uninit} warns that control may reach a read access to a
local variable before execution of any assignment to the variable other
than an initializer in a declaration modified by an @code{uninitialized}
pragma.

@item
@strong{Unreadable} warns that control may reach a read access of
a field or variable @code{x} when the expression in a @code{readable_if}
pragma modifying @code{x}'s declaration is false.

@item
@strong{ZeroDiv} warns of a possible attempt to apply the integer
division (@code{/}) or remainder (@code{%}) operator with zero as the
divisor.

@end itemize

@section Command-line options

ESC/Java2 has implemented a number of command-line options that are not present
in ESC/Java, as well as documenting some of those in ESC/Java.  ESC/Java2 also
kept many experimental (and undocumented) options from ESC/Java.  The following 
is a partial list of command-line options available in ESC/Java2; those not
labelled "ESC/Java2 only" were inherited from ESC/Java and are available in both 
tools, though the behavior may be slightly different.

Note that in ESC/Java2 (and in ESC/Java) all command-line options and their 
arguments must precede all file names.

@itemize
@cindex -bootclasspath
@item @code{-bootclasspath} @emph{directory-path} : specifies the location of 
system binary files; this directory path is appended to any specification for the
classpath in finding class files; the default is the platform-dependent classpath
specified by Java preferences (using the -v option will show the full classpath
being used)
@cindex -classpath
@cindex classpath
@item @code{-classpath} @emph{directory-path} : specifies the directories in which
binary (.class) files for types are sought; the default is to use the value of
the CLASSPATH environment variable, or to use just the current directory if 
neither -classpath nor CLASSPATH is specified [[[ What about java property ]]]
@cindex -da
@item @code{-da} : synonym for @code{-disableassertions}
@cindex -ea
@item @code{-ea} : synonym for @code{-enableassertions}
@cindex -eajava
@item @code{-eajava} : synonym for @code{-javaAssertions}
@cindex -eajml
@item @code{-eajml} : synonym for @code{-jmlAssertions}
@cindex -disableassertions
@item @code{-disableassertions} : as in Java, causes parsing to read Java 1.4 source but ignores
 any Java assert statements
@cindex -enableassertions
@item @code{-enableassertions} : as in Java, causes parsing to read Java 1.4 source
and to use Java assert statements 
@cindex -help
@item @code{-help} : causes the program to print information about command-line options and then to terminate [ESC/Java2 only]
@cindex -javaAssertions
@item @code{-javaAssertions} : causes parsing to read Java 1.4 source and to treat
Java assert statements as Java does, as a throw of a @code{java.lang.AssertionError}
exception
@cindex -jmlAssertions
@item @code{-jmlAssertions} : causes parsing to read Java 1.4 source and to treat
Java assert statements like JML assert statements
@cindex -noCautions
@cindex cautions
@item @code{-noCautions} : suppresses the reporting of any cautions
@cindex -nocheck
@item @code{-nocheck} : will not execute the static checking phase, though does all
the parsing, typechecking and verification condition generation
@cindex -nowarn
@item @code{-nowarn} @emph{warning-type} : turns off the reporting of warnings of the given type; use a warning-type of `All' to turn off all warnings
@cindex -package
@item @code{-package} @emph{package-name} : includes all the source files in the given package in the list of source files being processed [ESC/Java2 only]
[[[ wihch suffixes ?]]]
@anchor{-parsePlus}
@cindex -parsePlus
@item @code{-parsePlus} : causes ESC/Java2 to process annotations following
the markers @code{//+@@} and @code{/*+@@} (@pxref{Format of annotations}).
@cindex -quiet
@item @code{-quiet} : turns off any informational messages, leaving only reports of errors, warnings and cautions.
@cindex -source
@cindex 1.3
@cindex 1.4
@cindex assert
@item @code{-source} @emph{version} : interprets the source code according to the 
definition of Java for the given version.  The only implemented effect of this
option is the interpretation of @code{assert} as a keyword if the version is
@code{1.4} and as a normal identifier if the version is not @code{1.4}.  The default
is version @code{1.3}.  In the absence of other options, enabling Java 1.4 will
cause Java assertions to be treated as exceptions (the @code{-javaAssertions} mode).
@xref{Java and JML assert statements}.
@cindex -sourcepath
@cindex sourcepath
@item @code{-sourcepath} @emph{directory-path} : specifies the directories in which
source and specification files for types are sought; the default is to use the 
classpath [ESC/Java2 only]

@cindex -v
@cindex verbose
@item @code{-v} : verbose output describing the steps of processing (ESC/Java2 has
added more output to that produced by ESC/Java)
@cindex -warn
@item @code{-warn} @emph{warning-type} : turns on the reporting of warnings of the given type

@item [[[FIXME - check for others to be documented]]]

@end itemize

@section Environment variables affecting ESC/Java2

There are several environment variables which alter the behavior of ESC/Java2 
or Simplify, which is called by ESC/Java2.  These are described in this section.

[[[ Finish comments ]]]
@itemize @bullet

@item ESCTOOLS_RELEASE
@item ESCTOOLS_ROOT
@item SIMPLIFY - the name of the Simplify executable appropriate to the platform on which ESC/Java2 is running.  Current options are Simplify-1.5.4.linux, Simplify-1.5.4.macosx, Simplify-1.5.4.solaris, and Simplify-1.5.4.exe (for Windows).  [[[ Only the first two have had any testing. ]]]
@item CLASSPATH
@item BOOTCLASSPATH
@item ESC_SPECS
@item ESCJ_VERBOSE - normally not set.  When set to some value, then more verbose output is obtained.  This is simply output describing the environment variables used in invoking the tool.
@item ESCJ_STDARGS - the command-line options to be used (in addition to any additional ones on the command-line for escjava2).  (Default: -nowarn Deadlock)
@item ESC_REMOTE_DEBUG - normally not set.  When set to some value, then the value of
JAVA_VM_DEBUG_FLAGS is included in the options supplied to the virtual machine, 
inttended to be used to invoke the virtual machine in a debuggin mode.
@item JAVA - the name of the executable of the Java virtual machine (default: java)
@item JAVA_VM_FLAGS - the set of options to be supplied to the Java virtual machine ( the default is an empty string)
@item JAVA_VM_DEBUG_FLAGS - a set of flags to be used when ESC_REMOTE_DEBUG is set, intended to be used to invoke the virtual machine in a debugging mode (default is a set of options appropriate for debugging on my machine!)
@end itemize

These variables affect the running of the Simplify prover.
@itemize bullet
@item ESCJ_SIMPLIFY_ARGS - the command-line arguments to use in running simplify (default: -noprune -noplunge)
@item PROVER_KILL_TIME - the maximum number of seconds to spend on any one proof attempt (default: 300)
@item PROVER_CC_LIMIT - the maximum number of static checker warnings to report for any given routine (default: 10)
@item ... and many others, undocumented, but all beginning with PROVER_  ...
@end itemize

These variables are set automatically to match a standard release.  For normal operation
they should not be set.  They would be
set to another value only in debugging or other unusual circumstances.  However, if
they are set in the environment to an arbitrary value, they would cause a malfunction of the tool.
Note that Esc/Java2 invokes a simplify script which then invokes a Simplify executable.
@itemize @bullet
@item ESC_CLASSPATH - the classpath needed to run the ESC/Java2 (i.e. to find its
class files). This is different than the classpath needed to find the source and
class files being checked; those classpaths are set with the -classpath and -sourcepath
command-line options.
@item ESCJ_SIMPLIFY_DIR - the directory in which to find the Simplify executable
@item ESCJ_SIMPLIFY_SCRIPT - the full path to the simplify script
@end itemize

[[[ Predicate abstraction uses some undocumented java properties. ]]]

@c -----------------------------------------------------------------------------
@chapter Changes to static checking in ESC/Java2

Most of the changes from ESC/Java to ESC/Java2 are changes to the parser so that
ESC/Java2 will parse and typecheck all of current JML, as well as being upgraded to
handle Java 1.3 and 1.4.  However, there are a few ways in which the static
checking has been modified.  They are described in this chapter.

@section Handling of specification inheritance

The semantics of the inheritance of specifications has changed from ESC/Java to 
ESC/Java2; ESC/Java2 now matches the semantics of JML.  The implementation 
required changes in the way that translation of specifications into guarded
commands is performed.  The change in semantics is described with 
examples in @ref{Specifications and inheritance}.

@section non_null

[[[ discussion needed ]]]

@section Translation of the Java 1.4 assert statement

The handling of the Java 1.4 assert statement is discussed in 
@ref{Java and JML assert statements}.
The assert statement is translated into equivalent Java or JML constructs and the
static checker is used without modification.

@section The @code{\TYPE} and @code{java.lang.Class} types

[[[ discussion needed ]]]

@section The initially clause

[[[ discussion needed - no change yet ]]]


@section The constraint clause

[[[ discussion needed - no change yet ]]]

@section Use of modifies clauses in checking routine bodies

ESC/Java does not check the correctness of the @code{modifies} clauses.  However, 
it does use that information during the checking of the body of a routine in the
following way.  A pre-state value of variables that are mentioned in modifies 
clauses is defined; then when a variable reference occurs within a @code{\old}
construct, the pre-state value is used.  However, variables not mentioned in
a modifies clauses are presumed not to change in the course of the routine body
and hence are not mapped to a pre-state value.  Instances of those variables in
an @code{\old} construct are simply mapped to the current value, which may not be
the pre-state value if indeed the variable is modified.  In this example
@example
public class E @{
        public static int i,j;
        
        //@@ requires i == j;
        //@@ modifies i;
        //@@ ensures i == \old(i);
        //@@ ensures i + j == \old(i + j);
        public void m() @{
                ++i;
                --j;
        @}
@}
@end example
@noindent
ESC/Java reports a failure on the second postcondition; this is because the @code{j}
in the @code{\old} construct is translated the same as the @code{j} outside of the
{\old} construct.

ESC/Java2 mitigates problems caused by errors in modifies clauses by maintaining
pre-state values for any variable mentioned in an @code{\old} construct (in 
addition to those in modifies clauses).  As a result, the static checking of the
routine body proceeds correctly despite any errors in the modifies clauses.

@section Defaults for modifies clauses

ESC/Java had an implicit default for a missing modifies clause, namely that nothing
was modified (@code{modifies \nothing;} in JML).  JML defines the default instead
to be @code{modifies \everything;}.  ESC/Java2 has implemented this as the default.
The implicit use of @code{modifies \nothing;} had the danger of missing or hiding
many errors in usage, since unexpected changes to variables caused by calling a
routine are a not unusual source of bugs.  However, some outstanding issues are
discussed in the following section.


@section modifies \everything

The use of @code{\nothing}, @code{\everything}, and @code{\not_specified} in
a modfies clause are now implemented.  @code{not_specified} is equivalent to
@code{\everything}, and @code{\everything} is the default.
However there are two issues outstanding.
@itemize @bullet
@item With this default, any method that has no annotations is assumed to have the
behavior @code{modifies \everything;}.  There is very little reasoning that can
be performed as a result.  Thus any use of the ESC/Java2 tool will require having
specification files for system classes and for many of the other classes in the
user's body of code.
@item The logic to reason about routine bodies that contain calls of methods that
are specified with @code{modifies \everything;} has not yet been defined or 
implemented.  A caution is issued in these cases.  But to avoid breaking tests,
this caution is not yet turned on.
@end itemize

[[[ This needs updating when 'modifies everything' is implemented. ]]]

@section Checking of modifies

[[[ nothing yet, but I hope for it ]]]

@c [[[ methods in annotations - sure would be nice ]]]




@c -----------------------------------------------------------------------------
@chapter Incompatibilities

@section Major features of Java not implemented in ESC/Java2
[[[ Discussion needed for all of these]]]

@section non-public top-level class definitions

[[[These are currently not checked.]]]

@subsection anonymous and block-level classes

These are supported, but the bodies of methods are not checked.

Java allows classes to be declared as anonymous classes and as local classes within a 
block statement.  These constructs are parsed and type-checked.  However,
@itemize @bullet
@item Although annotations can be added to the methods declared within an anonymous 
class, the body of the implementation of these methods are not checked against the
specifications.
@item Since there are no variables whose static type is that of the anonymous class,
the pre- and post-conditions of the methods in the anonymous class are not used when
checking calls of those methods.
@item Classes declared at block-level may have specifications and the these 
specifications are used when the methods of the class are called.
@item The bodies of the block-level classes are not checked against their specifications.
@end itemize

@subsection serialization
[[[ discussion needed ]]]

@subsection most multi-threading considerations
[[[ discussion needed ]]]




@section Major features of JML not implemented in ESC/Java2
[[[ Discussion needed for all of these]]]


@subsection datagroups
[[[ discussion needed ]]]

@cindex implies_that
@cindex for_example
@subsection implies_that and for_example behavior
These sections of a routine's specification provide specifications that are 
implied by the regular specifications.  They are parsed and typechecked, but no use
of them is made in static checking; they are not used as an aid to reasoning, nor
is it checked that they follow from the other specifications.


@section Incompatibilities with ESC/Java
This section describes ESC/Java features that are not present or behave 
differently in ESC/Java2; the many additions to ESC/Java provided by ESC/Java2 are
not discussed.

@subsection Error messages and warnings
ESC/Java2 has added error messages to conform with current JML semantics.  
Some old ESC/Java errors and warnings are no longer appropriate and
have been removed.

[[[ FIXME - discussion needed ]]]

@subsection also
@subsection inheritance of specifications
@subsection non_null on formal parameters and results of routines
@subsection monitored_by
@subsection readable_if
@subsection initially (old style)
@subsection monitored_by (old style)

@subsection semicolon termination

@section Non-JML features in ESC/Java2

There are some syntactic constructs accepted by ESC/Java and continue to be 
accepted by ESC/Java2 that are not part of JML.

[[[ discussion needed - have not checked how some of these are used in ESC/Java, so
they may not be relevant to the discussion here.]]]

@subsection  loop_predicate
@subsection  \lblpos, \lblneg
@subsection  skolem_constant
@subsection  still_deferred
@subsection  writable_deferred
@subsection  writable_if
@subsection  readable_if
@subsection  monitored_by
@subsection  dttfsa
@subsection  uninitialized
ESC/Java2 and ESC/Java include the @code{uninitialized} annotation.  This is not 
present in JML.

@subsection  placement of annotations
@subsection  semicolon termination
JML requires annotations to be terminated with semicolons.  
ESC/Java2 will warn about missing semicolons, but does not require them.

@subsection  need for the field, method, constructor keywords
[[[ ESC/Java2 parses non_null in method declarations ]]]

@subsection omission of method bodies
ESC/Java2 does not require bodies of methods and constructors to be present, even in
.java files.  The JML checker does require such bodies in .java files, although not
in specification files with other suffixes.

@subsection Errors and cautions
Some JML errors are reported as cautions by ESC/Java2.  This enables as much 
checking to be performed as possible in cases in which the correction to the error
seems obvious.


@c node  Concept Index,  , , Top
@c node-name, next, previous, up
@unnumbered Concept Index

@printindex cp

@bye
