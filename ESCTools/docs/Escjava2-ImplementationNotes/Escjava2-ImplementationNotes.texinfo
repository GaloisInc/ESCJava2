\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename Escjava2-ImplementationNotes.info
@settitle ESC/Java2 Implementation Notes
@c @setchapternewpage odd
@c %**end of header

@c FIXME - indexing needs major work

@comment ----- title and copyright pages
@titlepage
@title ESC/Java2 Implementation Notes
@subtitle VERY MUCH A PRELIMINARY, INCOMPLETE DRAFT

@author David R. Cok
@email{cok@@frontiernet.net}

@author Joseph R. Kiniry
@email{joseph.kiniry@@ucd.ie}

@sp 1


@center November 2005

@sp 2

@b{Abstract:} ESC/Java2 is a tool for statically checking program
specifications.  It expands significantly upon ESC/Java, on which it
is built.  It now is consistent with the definition of JML and of 
Java 1.4.  It adds additional static checking to that in ESC/Java;
most significantly, it adds support for checking frame conditions and
annotations containing method calls.  This document describes the
status of the implementation of ESC/Java2, along with some notes
regarding the details of that implementation.

@sp 2

@b{Keywords:}  Behavioral interface specification, Java,
JML, Escjava, ESC/Java, ESC/Java2, model-based specification, assertion,
precondition, postcondition, frame.

@b{2003 CR Categories:}
D.2.1 [@i{Software Engineering}]
        Requirements/Specifications --- languages, tools, theory,
        JML, ESC/Java, ESC/Java2;
D.2.4 [@i{Software Engineering}]
        Software/Program Verification --- assertion checkers, class invariants,
        formal methods, programming by contract;
F.3.1 [@i{Logics and Meanings of Programs}]
        Specifying and Verifying and Reasoning about Programs ---
                assertions, invariants, logics of programs,
                pre- and post-conditions, specification techniques.

@sp 1

Copyright @copyright{} 2003-2004 David R. Cok
Copyright @copyright{} 2005 Joseph R. Kiniry


@sp 4
@*CVS Version: $Revision$
@*CVS Date: $Date$
@end titlepage

@contents

@synindex vr cp
@synindex fn cp
@synindex ky cp
@synindex tp cp

@node  Top, Introduction, (dir), (dir)

@menu
* Introduction::                
* Running ESCJava2::            
* Status::                      
* features::                    
* Changes to static checking::  
* Incompatibilities::           
* Modifier Summary::            
* Bibliography::                
* Concept Index::               

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Motivation and Background::   
* Acknowledgements::            
* Dependencies::                
* Contacts::                    

Status of JML features

* File finding::                
* Format of annotations::       
* Compilation unit annotations::  
* Access modifiers::            
* Type modifiers::              
* Type Annotations::            
* Type Annotation clauses::     
* Routine Annotations::         
* Routine Annotation clauses::  
* Routine modifiers::           
* Field Annotations::           
* Field Annotation modifiers::  
* formal parameter modifiers::  
* Annotation statements::       
* Local Modifiers::             
* JML functions (extensions to expressions)::  
* store-ref expressions::       
* Statements within model programs::  
* Other issues::                

Compilation unit annotations

* refine statements::           
* model import statements::     
* automatic imports::           

Type modifiers

* pure (JML)::                  
* model (JML)::                 
* weakly (JML)::                
* non_null_by_default::         
* nullable_by_default::         
* final-type::                  
* abstract-type::               
* strictfp-type::               
* static-type::                 

Annotations pertinent to a class or interface

* Ghost fields::                
* Model fields::                
* Model methods::               
* Model constructors::          
* Model types::                 
* Java initializer blocks::     
* initializer::                 
* static initializer::          
* Java method::                 
* Nested types::                

Annotation clauses for a class or interface

* invariant::                   
* constraint::                  
* represents::                  
* axiom::                       
* initially::                   
* readable::                    
* monitorsfor::                 

Annotations for a method or constructor

* specifications::              
* also desugaring::             
* modelprogram::                
* codecontract::                
* impliesthat::                 
* forexample specification::    

Annotation clauses for a method or constructor

* forall::                      
* old::                         
* requires::                    
* ensures::                     
* signals::                     
* modifies::                    
* diverges::                    
* when::                        
* duration::                    
* workingspace::                
* accessible::                  
* callable::                    
* measuredby::                  
* Redundancy::                  

Annotation modifiers for a method or constructor

* pure-routine::                
* nonnull-routine::             
* nullable-routine::            
* helper (JML)::                
* final::                       
* static-routine::              
* synchronized-routine::        
* native-routine::              
* strictfp-routine::            

Annotation assertions for a field declaration

* in (JML)::                    
* maps::                        

Annotation modifiers for a field declaration

* nonnull (JML)::               
* nullable (JML)::              
* monitored (JML)::             
* final-field::                 
* volatile::                    
* transient::                   
* static-field::                
* instance (JML)::              

Annotation modifiers for formal parameters

* nonnull-formal::              
* nullable-formal::             
* final-formal::                

Annotation statements within the body of a method or constructor

* assume::                      
* assert::                      
* set::                         
* unreachable::                 
* henceby::                     
* loopinvariant::               
* decreases::                   
* ghost declarations::          

assert, assert_redundantly

* set::                         

Modifiers that may be applied to local declarations

* nonnull on local decls::      
* uninitialized-local::         
* final-local::                 

JML functions (extensions to expressions)

* New operators in JML::        
* New JML expressions (functions and values)::  
* New JML types::               
* quantified expressions::      
* set comprehension::           
* notspecified::                
* privatedata::                 
* other ::                      
* Other Java operators and expression syntax::  

store-ref expressions

* field store-refs::            
* wild-card field store-refs::  
* array element store-refs::    
* array range store-refs::      
* all array elements store-refs::  
* static wild-card store-refs::  
* nothing ::                    
* everything ::                 

Other issues

* nowarn annotations-JML::      
* Java and JML assert statements::  
* Methods and constructors without bodies in Java files::  
* Methods and constructors in annotation expressions::  
* Original also specifications::  
* anonymous classes::           
* block-level class declarations::  
* field-method-constructor keywords::  
* TYPE Equivalence::            
* exceptions in annotation expressions::  
* Specifications and inheritance::  

nowarn annotations

* Java and JML assert statements::  
* Specifications and inheritance::  

Specifications and inheritance

* Desugaring in the presence of inheritance::  
* Defaults and inheritance::    
* Inheritance and non_null::    

ESC/Java2 features

* Error and warning messages::  
* Nowarn annotations and warnings::  
* Command-line options::        
* Environment variables::       

Nowarn annotations and warnings

* nowarn annotations::          
* nowarn warning types::        

Changes to static checking in ESC/Java2

* Handling of specification inheritance::  
* nonnull::                     
* Translation of the Java assert statement::  
* Semantics of String::         
* TYPE and Class::              
* The initially clause::        
* The constraint clause::       
* Use of modifies clauses in checking routine bodies::  
* Defaults for modifies clauses::  
* modifies everything::         
* Checking of modifies::        
* typeof::                      
* Use of pure routines in annotations::  
* Model Fields::                
* not modified::                

Semantics of String

* Concatenation operators::     
* Explicit String literals::    
* The intern method::           

Incompatibilities

* Major features of Java not implemented::  
* Major features of JML not implemented::  
* Limitations of static checking::  
* Incompatibilities-escjava::   
* Non-JML features::            
* JML features needing clarification::  
* Extensions::                  

Major features of Java not implemented in ESC/Java2

* Java 1.5::                    
* anonymous and block-level classes::  
* serialization::               
* most multi-threading considerations::  
* Java generics::               

Major features of JML not implemented in ESC/Java2

* codecontract-notimp::         
* some aspects of store-ref expressions::  
* implies that and for example behavior::  
* splitting::                   

Incompatibilities with ESC/Java

* Error messages and warnings::  
* also::                        
* inheritance of specifications::  
* non null on formal parameters and results of routines::  
* monitored by::                
* readable if::                 
* old style initially::         
* semicolon termination::       
* Routine bodies in spec files::  

Non-JML features in ESC/Java2

* annotation comments::         
* order of clauses::            
* splitting of annotations::    
* helper::                      
* typeof applied to primitive types::  
* unreachable-nonJML::          
* notmodified::                 
* specifications of default constructor::  
* loop predicate::              
* skolem constant::             
* still deferred::              
* writable deferred::           
* writable if - nonJML::        
* readable if - nonJML::        
* monitored by - nonJML::       
* dttfsa::                      
* uninitialized::               
* placement of annotations::    
* semicolon termination - nonJML::  
* need for the field::          
* omission of method bodies::   
* Errors and cautions::         
* membership in lockset::       

JML features needing clarification

* model programs::              
* callable-clarification::      
* when-clarification::          
* initializer-clarification::   
* desugaring of forall::        
* weakly::                      
* henceby issues::              
* use of result in resources clauses::  
* instance fields::             
* splitting annotations::       
* typeof-clarification::        

@end detailmenu
@end menu

@c @node NAME, Introduction, Top, Top
@c  node-name,  next,  previous,  up


@c ------ chapter Introduction --------
@node Introduction, Running ESCJava2, Top, Top
@c  node-name,  next,  previous,  up
@chapter Introduction

@c ------ section Motivation and Background --------
@menu
* Motivation and Background::   
* Acknowledgements::            
* Dependencies::                
* Contacts::                    
@end menu

@node Motivation and Background, Acknowledgements, Introduction, Introduction
@c  node-name,  next,  previous,  up
@section Motivation and Background


ESC/Java2 extends the pioneering work on ESC/Java by a group
[Flanagan-etal02] at the Systems Research Center at DEC, later Compaq,
now HP [@url{http://www.research.compaq.com/}].  ESC/Java parses JML-like
annotations in a Java program and warns, in a modular way, about
annotations that may not be justified by the Java source of the given
classes and the specifications of other classes.  The program works
accurately enough and fast enough that it has been found to be a
useful tool.  Its usefulness is diminished by limitations in the kind
of annotations that it can parse and check and also in that its
annotation language is similar to but is neither a subset nor a
superset of JML.

The goal of the ESC/Java2 work is to extend the use of ESC/Java by
@enumerate a
@item updating the parser of ESC/Java so that it is consistent with the 
current definition of JML and Java,
@item packaging the updated tool so that it is more easily available to a 
larger set of users, consistent with the source code license
provisions of the ESC/Java source code,
@item and extending the range of JML annotations that can be checked by the 
tool, where possible and where consistent with the engineering goals
of ESC/Java.
@end enumerate

This document records the status of this implementation.  It is not
intended to be a tutorial or a reference guide for either JML or
ESC/Java or ESC/Java2.  Rather it records the status of the features
of JML: the status of their implementation in ESC/Java2, the degree to
which the annotation is logically checked, and any differences between
ESC/Java2 and JML.
@itemize @bullet
@item More detailed information on JML is available at the web site 
@uref{http://www.jmlspecs.org/}; the details of the JML definition are published in 
"Preliminary Design of JML" [LeavensBakerRuby02] and in 
"The JML Reference Manual" [Leavens-etal03]
both available from the JML website.
@item Information on the original ESC/Java tool, 
most of which still applies, is provided in "ESC/Java User's Manual", 
SRC Technical note 2000-002 (Leino, Nelson, Saxe), 
available at 
@*@center @uref{gatekeeper.dec.com/pub/DEC/SRC/technical-notes/SRC-2000-002.html}
@end itemize

@c ------ section Acknowledgements --------
@node  Acknowledgements, Dependencies, Motivation and Background, Introduction
@c  node-name,  next,  previous,  up
@section Acknowledgements


To date, the work on ESC/Java2 has been carried out primarily by David
Cok and Joe Kiniry.  Gary Leavens has provided guidance on the
semantics and the current and future state of JML.  K. Rustan M. Leino
has provided advice with respect to the original ESC/Java.

The website for the project through version 2.0a8 was hosted by the
Security of Systems group at the Radboud University Nijmegen (what used
to be known as Katholieke Universiteit Nijmegen or the University of
Nijmegen) in Nijmegen, Netherlands.
(@url{http://www.niii.kun.nl/sos/research/escjava/}).  The project is
now hosted by the KindSoftware Research Group in the Department of
Computer Science at University College Dublin from version 2.0a8
onward. (@url{http://secure.ucd.ie/})

The work of producing ESC/Java2 stands on the very much more
considerable effort of the ESC/Java team in conceiving of and
producing ESC/Java, Simplify and related tools in the first place.

It also is built upon the work in designing JML and providing tools for
JML led by Gary Leavens at Iowa State University, with contributions
from several other individuals and groups, as described on the JML web
page.

@c ------ section Dependencies and license restrictions --------
@node  Dependencies, Contacts, Acknowledgements, Introduction
@c  node-name,  next,  previous,  up
@section Dependencies and license restrictions


The ESC/Java2 tool relies on the following software packages that are
separately available and may have their own license restrictions.
@itemize @bullet
@cindex ESC/Java
@cindex Simplify
@item The original source for ESC/Java, Simplify and related tools, available 
at
@*@center @uref{http://www.research.compaq.com/downloads.html/}

@cindex Mocha
@item Part of the Mocha tool from UCBerkeley (optional), available at
@*@center @uref{http://www-cad.eecs.berkeley.edu/~mocha/download/j-mocha/}

@cindex Simplify
@cindex CM3
@item The CM3 compiler for Modula-3, which is needed to build the Simplify 
tool, available from @uref{http://www.elegosoft.com/} or
@uref{fink.sourceforge.net}.

@cindex JUnit
@item The testing framework JUnit version 3.8.1, available at 
@uref{http://www.junit.org/}.

@item Specifications of the Java system classes.  The most useful set of these 
specifications are those available with the releases of JML.

@cindex JML
@item ESC/Java2 does not depend on the JML tool set, but it is useful 
to use the two in combination.  ESC/Java2 is obviously dependent on
the grammar and semantics of JML.  JML is available at
@uref{http://www.jmlspecs.org/}.
@end itemize

@c ---------Contacts ------------------
@node Contacts,  , Dependencies, Introduction
@section Contacts and information

Further information about JML and ESC/Java2 can be obtained from these sources.

@itemize @bullet
@item The KUN ESC/Java2 website: @uref{http://www.niii.kun.nl/sos/research/escjava/}
@item The JML web site:  @uref{http://www.jmlspecs.org/}
@item The JML project on sourceforge: @uref{http://sourceforge.net/projects/jmlspecs/}
@item The JML interest mailing list on sourceforge: 
        @*@center @email{jmlspecs-interest@@lists.sourceforge.net}
@item The JML development mailing list on sourceforge: 
        @*@center @email{jmlspecs-developers@@lists.sourceforge.net}
@item The ESC/Java2 mailing list on sourceforge: 
        @*@center @email{jmlspecs-escjava@@lists.sourceforge.net}
@end itemize

JML utilizes (the Java subset of) the multijava compiler.
Information about multijava can be obtained from these sources.
@itemize @bullet
@item The multijava website: @uref{http://www.multijava.org/}
@item The multijava project on sourceforge: 
             @uref{http://sourceforge.net/projects/multijava/}
@end itemize

@c --------------------------------------------------------------------------
@node Running ESCJava2, Status, Introduction, Top
@chapter Running ESC/Java2

There are three essential items that you need in order to run ESC/Java2:
a build of ESC/Java2 itself, an executable for Simplify for your
platform, and a version of the JML specifications for the Java system
classes.  These are available together as a single release from the KUN
ESC/Java2 website (@url{http://www.cs.kun.nl/sos/research/nl}).
However, you may want to substitute an alternate version of the JML
specifications that you generate yourself or you obtain from the JML
website.  The specifications included with ESC/Java2 are a snapshot of
the JML specifications at the time of release.

There are a number of ways to run ESC/Java2.  The various command-line 
options are described in @ref{Command-line options}.

1. Double-click the esctools2.jar file that comes with the release.
This launches a GUI tool that runs ESC/Java2.  The jar file has the
JML specs built-in and uses them by default.  You will have to tell
the GUI tool the location of the appropriate Simplify executable for
your platform, what value of @env{CLASSPATH} to use, and what the
input files and other options should be.  Versions of Simplify for
several platforms are supplied with the release.

2. Execute the esctools2.jar file using the command @command{java -jar
esctools2.jar} .  This allows you to launch the GUI tool from the
command-line and to add other command-line options as initial settings
of the GUI tool.  In particular you
can specify the location of the Simplify executable with the option
@code{-simplify }@emph{PathToSimplify}, in which you supply an
absolute path to the correct Simplify executable.  A directory path
for alternate Java specifications can be supplied as the argument to
the @code{-specs} option.  The classpath is specified with the
@code{-classpath} option.

3. Execute a non-GUI version of ESC/Java2 using the script supplied
with the release: @command{./escj} .  The script can guess the
location of the release and of the Simplify executable.  You can help
it by defining the environment variable @code{ESCTOOLS_ROOT} as the
absolute path to the location of the directory containing the release.
and by defining the variable @code{SIMPLIFY} as the name of (not
the path to) the Simplify executable.  If your working directory is
something other than the directory containing the release, you will
need to provide a suitable path to the @code{escj} script when you
invoke it.
 
4. Execute a non-GUI version of ESC/Java2 using the command
@command{java -cp esctools2.jar escjava.Main} .  In this case you need
to specify the location (path and name) of the Simplify executable
using the @code{-simplify} option and the location of the reference
specifications using the @code{-specs} option.  You also need to 
specify the classpath using @code{-classpath} and any other input files
and options.

@c ------ chapter Status of JML features --------
@node  Status, features, Running ESCJava2, Top
@c  node-name,  next,  previous,  up
@chapter Status of JML features


ESC/Java2 parses correctly formatted JML files, with the exceptions
described in this document.  JML files must be correct Java source
with correctly formatted annotations, which appear to Java as
comments.  Although ESC/Java2 does some error reporting during
parsing, it does not report all parsing or type errors in either Java
or JML, nor does it necessarily terminate normally if the input is not
legal Java/JML.  There are a number of tools supporting JML that can
be used to check the well-formedness of the JML annotations in a file;
a Java compiler can be used to check the format of the Java source
code.

The authors encourage any report of a legal Java/JML file that
ESC/Java2 will not parse.  Furthermore, despite the caveat above, the
authors do want ESC/Java2 to be a useful tool; hence they are
interested in examples of legal or illegal Java/JML source code that
cause abnormal termination and in examples in which the absence of
error messages or the occurrence of an inappropriate error message is
misleading to the user.  Examples that generate unsound or incomplete
behavior beyond that already documented are also of interest.

The organization of ESC/Java2's error and warning messages is described in
@ref{Error and warning messages}.


@cindex file names
@cindex suffixes
@cindex refinement sequence
@c ------ File finding and refinement sequences --------
@menu
* File finding::                
* Format of annotations::       
* Compilation unit annotations::  
* Access modifiers::            
* Type modifiers::              
* Type Annotations::            
* Type Annotation clauses::     
* Routine Annotations::         
* Routine Annotation clauses::  
* Routine modifiers::           
* Field Annotations::           
* Field Annotation modifiers::  
* formal parameter modifiers::  
* Annotation statements::       
* Local Modifiers::             
* JML functions (extensions to expressions)::  
* store-ref expressions::       
* Statements within model programs::  
* Other issues::                
@end menu

@node File finding, Format of annotations, Status, Status
@c  node-name,  next,  previous,  up
@section File finding and refinement sequences

@cindex filenames
@cindex suffixes
JML follows Java conventions in file naming.  ESC/Java2 recognizes
Java source and class files organized into directory hierarchies
matching the package definitions, including source and class files
packaged in jar files.  The file names themselves typically consist of
a type name as a prefix and either @code{.java} or @code{.class} as a
suffix.  Specification files typically have the type name as a prefix
and one of the specification suffixes ( @code{.refines-java},
@code{.refines-spec}, @code{.refines-jml}, @code{.java}, @code{.spec},
@code{.jml}, @code{.java-refined}, @code{.spec-refined},
@code{.jml-refined}) as a suffix, though arbitrary suffixes are
permitted.

@cindex classpath
@cindex sourcepath
The ESC/Java2 program utilizes a classpath and a sourcepath, which are
standard sequences of directories or jar files separated by a
platform-dependent path separator character (a colon on Linux and
MacOSX, a semicolon on Windows).  The classpath is specified by the
-classpath command-line option, or by the CLASSPATH environment
variable if no command-line option is given, and is just the current
working directory if neither is specified.  The sourcepath is
specified by the -sourcepath command-line option; if that is not
provided, the sourcepath is identical to the classpath.

The tool also needs a set of specifications of Java system classes
(and of other library classes you may be using).  The directory path
to these specifications can be included in the sourcepath, but it is
convenient to specify them to the tool using the @code{-specs} 
option, which takes a standard directory path as its single argument.

The command-line arguments consist of options and their arguments
(described in @ref{Command-line options}) and input entries.  Input
entries may be files, directories, package names, or class names.
These input entries designate the classes on which ESC/Java2 operates.

Files and directories specified on the command-line are found with
respect to the current working directory (if the paths to the files
are relative paths).  Specifying a directory is shorthand for listing
all of the files in the directory with suffixes known to JML, namely
.refines-java, .refines-spec, .refines-jml, .java, .spec, and .jml.

Input entries may also be fully-qualified package or class names.  In
this case, the package or class is found by searching the directories
of the sourcepath.  [[[which suffixes are used? stop after the first
directory found??? ]]]

Each file on the command-line (or file implied by a directory,
package, or class) is parsed to determine the package to which it
belongs and the name of the type that it declares.  ESC/Java2 and JML
tools then use the following procedure to find the refinement sequence
for the given fully qualified type.  When the specifications of types
referenced in files being processed by ESC/Java2 are needed, they are
found using the same procedure.

@itemize @bullet

@cindex MRCU
@cindex most-refined compilation unit
@item Search each directory of the sourcepath in turn, looking for the first
sourcepath directory containing a directory hierarchy for the given
package containing a file whose name has the type name as its prefix
and one of the following suffixes: @code{.refines-java},
@code{.refines-spec}, @code{.refines-jml}, @code{.java}, @code{.spec},
@code{.jml}.  If the directory contains more than one such file, the
one with a suffix closest to the beginning of the list of suffixes is
used.  This file is called the @emph{Most-refined compilation unit}
(MRCU).

@cindex refinement sequence
@item If the MRCU contains a @code{refine} statement, then the file named in it
is sought in the sourcepath in the same package (but not necessarily
the same directory) as the MRCU.  It is an error if a file named in a
@code{refine} statement cannot be found in the sourcepath.  Files
found in this way are parsed in turn and the files named in each
@code{refine} statement are sought.  This procedure is repeated
recursively until a file is found that has no @code{refine} statement.
The sequence of files so found is called the @emph{refinement
sequence}.  The refinement sequence may contain the .java file for the
type [[[ JML allows .class files ??? ]]]

@item The rules above do not restrict the filenames of the files of the 
refinement sequence, other than that they must be in the same package
(but not necessarily in the same directory).  In particular, aside
from the suffix for the MRCU (and java and class files), there is no
restriction on the suffixes that the files may have, nor on the order
of suffixes in the refinement sequence.  There is also no restriction
on the prefixes of the file names, other than that the MRCU, the .java
file and the .class file must have the typename as the prefix.
However, it is good style if all of the files in the refinement
sequence have the same prefix.  If a file has a filename prefix that
does not match the type declared within it, it is in danger of being
misinterpreted as belonging to a different type.  Consequently a
caution is issued to the user if this situation is discovered.

@item Once an MRCU is found, the remainder of the refinement sequence 
is determined by the @code{refine} statements.  But which file is
found as the MRCU may depend on the contents @emph{and order} of the
directories in the sourcepath.  This order dependence is by design as
it is thought that the user may use this feature to choose different
starting points along the refinement sequence for processing.  It may
also lead to inadvertent errors.

@item It is an error if a sequence of refine statements defines a 
circular sequence of refinement files.

@item The .java source file and the .class file for the given 
fully-qualified type are found as defined by Java, independently of
determining the refinement sequence, using the sourcepath and the
classpath, respectively.  Note that if the .java file declares more
than one type, then there may be more than one .class file relevant to
the refinement sequence.

@item Note that if the .java file declares more than one type, 
then the files of the corresponding refinement sequence must contain
the specifications for all of the declared types.

@item The specifications for the classes declared in the files 
of a refinement sequence are the combination of the specifications in
all the files of the refinement sequence.  The Java signature of the
classes is obtained from the relevant .java or .class files.  The
source code implementation of the classes is determined from the .java
file.  If no .java file exists (or it does not contain an
implementation of a method), then the check of that method will be a
trivial pass; checks of the usage of the method within other routine
bodies will still be performed.

@item It may be that a refinement sequence exists and does not 
contain the file specified on the command-line.  ESC/Java2 issues a
caution to the user in this case.  However, if no refinement sequence
is found, no caution is issued even if the command-line file is not on
the sourcepath; it is simply used as the specification of the declared
classes.

@item It may be that the refinement sequence exists, and a 
corresponding .java file exists in the sourcepath, but the refinement
sequence does not contain the .java file.  In this case the .java file
is used as the source code of the implementation and to define the
signature of the class, but no specifications are obtained from it.  A
caution is issued to the user in this case.

@item It is not required that a .java or a .class file exist, since it is 
desired to be able to write specifications in advance of an implementation.  
However, if either one does exist then the following rules are used:
@enumerate a
@item if the implementation is needed (because this is a type whose 
implementation is being checked by ESC/Java2) as well as the
signature, then the .java file is used for both the implementation and
the signature regardless of time stamp, if it exists.
@item if only a signature is needed, then which file is used is 
determined by a command-line option (e.g. @code{-preferSource} as
described in @ref{Command-line options}).  The default is to
use the most recently modified of the two to define the Java signature
of the class (whether or not it is in the refinement sequence).
Specifications are not permitted to add new (non-model, non-ghost)
declarations of fields, routines, or enclosed classes or interfaces to
those defined in the Java implementation.
@end enumerate

@item Currently, .class files do not contain specifications.  However, 
we would like to leave open the possibility that in the future a
binary version of parsed and checked specifications could be created
that would improve processing time.

@end itemize 

@noindent
@strong{Status:} The above rules are implemented in ESC/Java2 with
the following exceptions.
@itemize @bullet
@item ESC/Java2 does not yet use the search order for the MRCU as described.
Rather it finds the file with the most active suffix anywhere in the
sourcepath, regardless of its position in the sourcepath.
@item When finding a package named as an input entry,
ESC/Java2 combines all of the packages by that name in any directory
of the sourcepath, rather than just using the first one.
@item [[[ Check the caution for CL file not in the RS - OK]]]
@item [[[ Check the caution for the Java file not in the RS -OK ]]]
@item [[[ Check the caution if a misnamed file is found in the RS. - OK]]]
@item [[[ Check that there is an error if a 'refine' file cannot be found. - OK ]]]
@item [[[ Check that the sourcepath is actually defined and used. - OK]]]
@item [[[ Can ESC/Java2 handle refining a class?  ]]]

@item [[[ Should we have an option to find MRCUs with any suffix? ]]]
@item [[[ Should we have an option to find the whole chain whatever the order of the sourcepath and suffixes?]]]
@item [[[ Should we have an option to change/expand the list of MRCU suffixes? ]]]
@item [[[ Should we have an option to define 'implicit' refine statements, in order
for example, to connect specification files to implementation files, when the 
implementation files suddenly become available and we don't want to edit all of the
files? ]]]
@end itemize

@c ------ Format of annotations --------
@node Format of annotations, Compilation unit annotations, File finding, Status
@c  node-name,  next,  previous,  up
@section Format of annotations

@cindex format of annotations
@cindex annotation markers
@cindex comments, annotation
@cindex @code{//@@}
@cindex @code{//+@@}
@cindex @code{/*@@}
@cindex @code{/*+@@}
@cindex @code{*/}
@cindex @code{@@*/}
@cindex @code{@@+*/}
@itemize @bullet
@item @strong{Comment format:} JML annotations are included in a Java 
program as specially formatted comments.  In particular, JML
annotations recognized by ESC/Java2 are either
@itemize @bullet

@item single-line comments beginning with @code{//@@}, or

@item multi-line comments enclosed between @code{/*@@} and either 
@code{*/} or @code{@@*/} , or

@cindex @code{<esc>}
@cindex @code{<ESC>}
@cindex @code{<jml>}
@cindex @code{<JML>}

@item annotations embedded in a javadoc comment between any of the 
four pairs of markers @code{<esc>} and @code{</esc>}, @code{<ESC>} and
@code{</ESC>}, @code{<jml>} and @code{</jml>}, or @code{<JML>} and
@code{</JML>}.  
The original ESC/Java only recognized the first pair.
These annotation pairs may not be nested, but there may be multiple
annotations in sequence.  ESC/Java2 and JML do not restrict where in
the javadoc comment an annotation may occur.  However, javadoc
requires the annotation to be a part of the textual description and to
precede any tag descriptions that are part of the comment.  The jmldoc
tool allows multiple annotations to be intermixed with the tag
descriptions.  Neither ESC/Java2 nor the JML tools require the
annotation to be enclosed between @code{<pre>} and @code{</pre>} tags;
however, if you expect reasonable formatting in a javadoc-produced
HTML page, you will likely wish to do so.  The jmldoc tool does not
require @code{<pre>} and @code{</pre>} tags to produce good
formatting.
@end itemize
Both the JML tools and ESC/Java2 allow multiple @@ symbols in the
opening and closing comment markers (e.g. @code{//@@@@@@@@} is
equivalent to @code{//@@}).

ESC/Java2 recognizes these additional comment forms:
@itemize @bullet
@item single-line comments beginning with @code{//-@@} ;
@item multi-line comments enclosed between @code{/*-@@} and either 
@code{*/} or @code{@@*/} ;
@end itemize
@noindent These are used for (primarily experimental)
constructs that are known to ESC/Java2
but are not part of JML.

Note that JML recognizes additional annotations in these forms:
@itemize @bullet

@item single-line comments beginning with @code{//+@@} ;

@item multi-line comments enclosed between @code{/*+@@} and either 
@code{*/} or @code{@@*/} or @code{@@+*/} ;

@end itemize
These latter forms are part of JML but not ESC/Java2 to allow for
syntax defined by JML but ignored by ESC/Java2.  It is hoped that the
result of the current work on ESC/Java2 will diminish the need for the
JML-only comments.  They may remain useful as a way to retain JML
annotations that are not processed (though they could be) by
ESC/Java2.  
@*@strong{Status:} All of these annotation markers are
implemented.  
@*@strong{Differences:} None.

There is also an interaction between javadoc comments and embedded annotations
of which the annotation writer should be aware.  Consider the text
@example
/**  Javadoc material.
<esc>
	... annotations ...
</esc>
     More javadoc material.
*/
public void m();
@end example
@noindent
It is somewhat ambiguous as to whether (a) to associate `Javadoc material'
with the embedded annotations and `More javadoc material' with the method
declaration or (b) to associate all of the javadoc material with the method
declaration.  The javadoc tool will do the latter, and consequently the jmldoc
tool does also [[[ or will, this is an outstanding bug.]]]  But the
writer, and the flow of the text, may well have meant the former.  It is
better to avoid embedded annotations if this confusion may arise.



@item @strong{-parsePlus option:} The @code{-parsePlus} command-line option
instructs ESC/Java2 to parse all annotations recognized by JML (particularly 
including the //+@@ and /*+@@ annotation markers).  This is used mainly
in testing to find and attempt to process the JML-only annotations, but may be
 useful in other circumstances. @xref{-parsePlus}.

@item @strong{Initial `@@' symbols in annotations:} Within a 
multi-line annotation, a sequence of `@@' symbols that follow
whitespace at the beginning of a line are treated as white space.
Within an annotation embedded in a Javadoc comment, a sequence of `*'
symbols (but not `@@' symbols) that follow whitespace at the beginning
of a line are treated as white space.

@item @strong{Splitting annotations across comments:} 
JML tools will parse and process annotations that are split
across multiple comments (e.g. a multi-line annotation in which each
line begins with @code{//@@}).  ESC/Java2 expects an annotation to be
entirely contained within one single- or multi-line comment.  The
latter behavior is `correct' JML; however, the JML tools will
correctly process and not warn about annotations split across multiple
comments.  To be specific:
@itemize @bullet
@item ESC/Java2 requires that any
 clause beginning with a keyword (e.g. invariant, requires)
and ending with a semicolon must be contained 
 within one annotation comment.  For example, write
@example
//@@ requires i != 0 && j != 0;
@end example
@noindent
or
@example
/*@@ requires i != 0 &&
  @@          j != 0;
  @@*/
@end example
@noindent not
@example
//@@ requires i != 0 && 
//@@          j != 0;   
@end example
@item ESC/Java2 requires that model methods, model
 constructors and model programs be defined within one annotation comment.
 For example, write
 @example
 /*@@ public model int m(int i, int j) @{
          return i+j;
      @}
  @@*/
@end example
@noindent not
@example
//@@ public
//@@ model int m(int i, int j) @{
//@@          return i+j;
//@@ @}
@end example
@item The tool also requires that a Java modifier 
(e.g. @code{public}) be in the same comment as a JML annotation
(e.g. @code{behavior} or model method) that it modifies.  For example,
write
@example
//@@ public behavior
@end example
@noindent not
@example
//@@ public
//@@ behavior
@end example
@item Finally, any @code{in} or @code{maps} clauses following a ghost or 
model field declaration must be within the same annotation comment as the
declaration.  Thus, write
@example
//@@ model T t; in a;
@end example
@noindent not
@example
//@@ model T t;
//@@ in a;
@end example
@end itemize

Thus, @code{requires} and @code{ensures} clauses must each be wholly
within a single annotation comment; individual keywords such as
@code{pure}, @code{normal_behavior}, @code{also}, @code{@{|} or
@code{implies_that} may be in annotation comments by themselves (with
any relevant access modifiers).  [[[ FIXME - JML rules need to be
clarified.]]]
 
@item @strong{Multiple annotations per comment:} It is legal JML 
to include multiple annotations per comment; in fact it is common
practice and good style to include many related annotations within one
multi-line comment.  ESC/Java2 supports this practice (though ESC/Java
had some difficulties).

@anchor{Terminating semicolons}
@item @strong{Terminating semicolons:} JML requires annotations 
to be terminated by semicolons.  The original ESC/Java did not.  The
absence of semicolons is illegal JML, but is sometimes tolerated by
ESC/Java2. ESC/Java2 will warn if a semicolon is missing.  Such
warnings can be suppressed with the @code{-noSemicolonWarnings}
command-line option.

@end itemize


@node Compilation unit annotations, Access modifiers, Format of annotations, Status
@section Compilation unit annotations
Compilation unit annotations are placed prior to the declaration of any
 type within the compilation unit.

@menu
* refine statements::           
* model import statements::     
* automatic imports::           
@end menu

@node refine statements, model import statements, Compilation unit annotations, Compilation unit annotations
@subsection refine statements
@itemize @bullet
@item @strong{Description:} A JML refine statement indicates 
that the containing compilation unit adds additional specifications to
those contained in the referenced file.  If present, it must be
located after any Java package statement and before any Java or model
import statements.  There may be only one refine statement in a
compilation unit.  It has the form 
@*@center @code{//@@ refine "}@emph{filename}@code{";}
@*The refine statements define a
@emph{refinement sequence} as described in @ref{File finding}.  Here
we focus on the combining of the compilation units in a refinement
sequence to produce a single set of specifications for a type.  Each
compilation unit has its own set of declarations and specifications,
all of which must be consistent.  They are subject to the following
rules, violations of which provoke error messages.


@itemize @bullet

@item All files of the refinement sequence must belong to the 
same package (though not necessarily the same directory); the type
names of the declared types must be identical (including case).

@item If a .java or a .class file exists for a type, the 
specifications may not add any Java (that is, non-model, non-ghost)
declarations to the signature.  They may only repeat declarations.
The specification files may declare specifications for a method that
is not implemented in the Java implementation if (a) the declaration
overrides a method in a superclass or superinterface or, for
interfaces, a method in @code{java.lang.Object} and (b) the
declaration is within an interface or is an abstract declaration in a
class.  This enables the specification writer to write specifications
for a routine in a class or interface that must be obeyed by
subtypes, even if the class or interface itself does not provide a new
implementation.  [[[ The requirement that the introduced declaration
be abstract is not enforced. Don't think it needs to be abstract. ]]]

@item If a field is redeclared, it must be redeclared with the 
same type and the same Java modifiers.  An initializer of a java field
may be present only in the .java file.  An initializer of a ghost
field may be declared in only one file of a refinement sequence.

@item These JML modifiers must be consistent across all redeclarations
of a field:
@code{model}, @code{ghost}, @code{instance}.  The modifiers
@code{spec_public}, @code{spec_protected}, @code{non_null},
@code{nullable} and @code{monitored} may be added by a refinement file,
but may not be removed.

@item If a method or constructor is redeclared, it must be redeclared with the
same return type, the same Java modifiers, and the same names for its formal
parameters.  An implementation may be present only in the .java file. (The
restriction on the formal parameter names is to simplify reading and to avoid
having the implementation have to rename variables in specifications.)

@item These JML modifiers must be consistent across all method and constructor
redeclarations: @code{model}.  These JML modifiers may be added by a
refinement but may not be removed: @code{spec_public},
@code{spec_protected}, @code{helper}, @code{non_null}, @code{pure}.

@item The Java modifier @code{final}, as applied to a formal parameter, must be
consistent across all redeclarations of a method or constructor.  The JML 
modifier @code{non_null} may be added, but not removed.

@item If a refinement file redeclares a method or constructor from a previous
refinement, or if the method is overriding a method in a superclass
or interface (including the case where a type redeclares a method with
specifications even though there is no Java declaration), the
specification for that redeclared or overriding method must begin with
`@code{also}' (and must not begin with `@code{also}' when those
conditions are not satisfied).

@item A type redeclaration must have the same set of Java modifiers.  
In addition the JML modifier @code{model} must be consistent; the JML
modifiers @code{pure}, @code{spec_public}, and @code{spec_protected}
may be added by a refinement but not removed.

@end itemize


@item @strong{Status:} The refine statement is implemented in ESC/Java2.
[[[ Check that all the rules above regarding consistency of modifiers
are enforced. They are not all yet.]]]

@item @strong{Comment on combining refinements:} There are (at least) 
3 ways to carry out the combining of refinements:
@enumerate a
@item by syntactically combining the 
relevant text;
@item by typechecking each compilation unit independently and 
then combining the signatures;
@item by typechecking each compilation unit in turn, in the context of the 
compilation units it is refining.
@end enumerate

[[[ Discuss implications and differences.  ESC/Java2 uses (a). ]]]

@end itemize

@node model import statements, automatic imports, refine statements, Compilation unit annotations
@subsection model import statements
@itemize @bullet
@item @strong{Description:}
A model import statement has the form 
@*@center @code{//@@ model }@emph{java-import-statement}@code{;}
@*Note that simply writing
@*@center @code{//@@ }@emph{java-import-statement}@code{;}
@*is not
legal JML.  A model import statement may occur wherever a Java import
statement may be placed.  A model import statement introduces types
that are used only by annotations.  Annotations may also use types
introduced by Java import statements.

@item @strong{Status:}  Model import statements are fully implemented.

@item @strong{Differences from JML or Java:}  This feature is implemented in 
ESC/Java2 as it is in JML.  However, both have the following problem.
The model import statements are parsed by JML tools and by ESC/Java2
as if they were Java import statements.  Thus they may introduce or
resolve an ambiguity in class name resolution of names used in the
Java source code in a compilation unit, or cause misinterpretation of
a type name.  For example, in
@example
import java.io.*;
//@@ model import myclasses.File;
public class C extends File @{@}
@end example
@noindent
the use of @code{File} as the superclass is interpreted as @code{java.io.File}
by the Java compiler but as @code{myclasses.File} by JML tools and ESC/Java2.
Similarly, in
@example
import java.io.*;
//@@ model import myclasses.*; // class myclasses.File exists
public class C extends File @{@}
@end example
@noindent
the use of @code{File} is interpreted as @code{java.io.File} by a Java
compiler but will be deemed ambiguous between @code{java.io.File} and
@code{myclasses.File} by the JML and ESC/Java2 tools.  These are as yet
unresolved bugs.


@item @strong{Comment:} This form is also illegal:
@*@center @code{/*@@ model @@*/ import }@emph{typename}@code{;}
@* Either use a Java import statement (without a @code{model} keyword) or
enclose the entire model import statement in an annotation comment.
@end itemize

@node automatic imports,  , model import statements, Compilation unit annotations
@subsection automatic imports
@itemize @bullet
@item @strong{Description:}  In Java programs, the package 
@code{java.lang.*} is automatically imported into each compilation
unit.  Similarly, in JML, the package @code{org.jmlspecs.lang.*} is
automatically imported, as a model import, into each compilation unit.

@item @strong{Status:} Fully implemented in ESC/Java2.

@item @strong{Differences:} None.

@end itemize

@cindex public
@cindex protected
@cindex private
@cindex spec_public
@cindex spec_protected
@c ------ section Access modifiers --------
@node Access modifiers, Type modifiers, Compilation unit annotations, Status
@c  node-name,  next,  previous,  up
@section Access (privacy) modifiers
Java allows the programmer to modify fields, methods, constructors,
class and interface declarations with one of the privacy or access
modifiers @code{public}, @code{protected}, @code{private} or to omit
these implying default (or package) access.  These modifiers affect
the visibility of the associated declaration in other classes.
ESC/Java2 issues compile-time errors for (some) misuses of access, but
the access of any given syntactic entity does not affect the static
checking that is performed.
 
JML also imposes some rules about access modifiers.  Some JML
constructs are allowed to be modified by an access modifier: the
class-level clauses described in @ref{Type Annotations}, such as
@code{invariant}, and the behavior and example keywords
(@code{behavior}, @code{normal_behavior}, @code{exceptional_behavior},
@code{example}, @code{normal_example}, and
@code{exceptional_example}).  In addition the method-level clauses
(e.g. @code{requires}, @pxref{Routine Annotation clauses}) are
assigned the privacy level of the behavior case of which they are a
part (if in a heavyweight specification case) or the privacy level of
the method they modify (if in a lightweight specification case).  A
specification clause may not use program entities with tighter access
restrictions than it itself has.  For example, a requires clause in a
protected @code{normal_behavior} specification case may not use
@code{private} fields.
 
Java program constructs that may be modified with an access modifier
may also be modified with one or the other of @code{spec_public} and
@code{spec_protected}.  A program construct modified with
@code{spec_public} is considered to have public access for any
specification and may be used in any specification clause; a program
construct modified with @code{spec_protected} may be used in any
specification clause in a derived type.  JML constructs may not be
modified with @code{spec_public} or @code{spec_protected}.
 
Note that @code{spec_public}, but not @code{spec_protected}, was
present in ESC/Java

 
@noindent
@strong{Status:} Parsing of access modifiers is fully implemented.
The access modifiers do not affect static checking.  Checking that
access is used consistently is not implemented.  [[[ Need to verify
checks for spec_public and spec_protected, and access checks in
general. - Behavior sections do not retain or use their access
modifiers.  ALso ghost and model fields/routines]]]
 

@node Type modifiers, Type Annotations, Access modifiers, Status
@section Type modifiers

A class may be modified with the Java modifiers @code{public},
@code{final}, @code{abstract} and @code{strictfp} and the JML
modifiers @code{pure}, @code{model}, @code{spec_public}, and
@code{spec_protected}.  An interface may be modified with the Java
modifiers @code{public}, @code{strictfp} and the JML modifiers
@code{pure}, @code{model}, @code{spec_public}, and
@code{spec_protected}.  Nested classes and interfaces may have the
additional modifiers @code{static}, @code{protected}, and
@code{private}.  The access modifiers are described in @ref{Access
modifiers}.  In addition the superclass and superinterfaces may be
modified with the keyword @code{weakly}.

@menu
* pure (JML)::                  
* model (JML)::                 
* weakly (JML)::                
* non_null_by_default::         
* nullable_by_default::         
* final-type::                  
* abstract-type::               
* strictfp-type::               
* static-type::                 
@end menu

@node pure (JML), model (JML), Type modifiers, Type modifiers
@subsection pure (JML)
@itemize @bullet
@item @strong{Description:} The @code{pure} modifier, when applied to a class or
interface, indicates that every method and constructor of the class or
interface is @code{pure}.  Thus, no method may assign to variables
other than those declared within the body of the routine.
Constructors may only assign to the instance fields of the object
being constructed (and its superclasses).

@item @strong{Status:} Parsed and fully implemented.

@item @strong{Differences from JML or Java:} None.

@item @strong{Comment:} A method inherits purity from the methods it overrides;
that is, if an overridden method is pure, the overriding method will
be pure whether or not it is declared pure.  This is not the case for
classes or for interfaces.  A subclass may add non-pure methods, even
if it has a pure superclass.  Declaring a class pure is precisely
equivalent to declaring all of its methods and constructors pure. [[[
Verify with JML]]]

@end itemize

@node model (JML), weakly (JML), pure (JML), Type modifiers
@subsection model (JML)
@itemize @bullet
@item @strong{Description:} The @code{model} modifier indicates that the
class or interface is only to be used in annotations.  It is not part of 
the Java program.

@item @strong{Status:} Parsed and fully implemented.

@item @strong{Differences from JML or Java:} JML does not yet properly handle
model classes, especially those at the top level.  Both JML and ESC/Java2 
parse model types as if they were Java types and so will not detected
erroneous uses of model types in Java code; both tools may also have some
related name lookup bugs.
@end itemize

@node weakly (JML), non_null_by_default, model (JML), Type modifiers
@subsection weakly (JML)

@itemize @bullet
@item @strong{Description:} This annotation is used to 
modify superclasses and superinterfaces in a class
or interface declaration.  An example of its syntax is this:
@example
   public class A extends B /*@@ weakly */ 
      implements C /*@@ weakly */, D /*@@ weakly */ @{ ... @}
@end example
@noindent
@noindent [[[ Need a description of the semantics ]]]

@item @strong{Status:} Parsed and ignored by ESC/Java2.

@item @strong{Differences from JML or Java:} Parsed but ignored by ESC/Java2.
  This feature was not present in ESC/Java.

@end itemize

@c @author kiniry
@node non_null_by_default, nullable_by_default, weakly (JML), Type modifiers
@subsection non_null_by_default (JML)

@itemize @bullet
@item @strong{Description:} This annotation is used to 
denote a @code{non_null} default semantics for reference types in a
given class.  An example of its syntax is this:
@example
   public /*@@ non_null_by_default @@*/ class A @{ ... @}
@end example
@noindent
@noindent If a class is labeled with the annotation
@code{non_null_by_default} then every field, formal parameter, and
method has a default specification of @code{non_null}.  Local variables
do not have any default specification.

If a class is annotated @code{non_null_by_default} and a formal
parameter, method, or field is annotated @code{non_null} then the latter
spec is redundant and the user is notified of such.

If a class is annotated @code{non_null_by_default} and a formal
parameter, method, or field is annotated with @code{nullable} then this
specified annotation overrides the class annotation and the reference
may be null.

[[ The scope of this annotation to the class to which it is applied
as well as nested (possibly anonymous) classes.  The class-scoped
annotation is not inherited. ]]

[[ An interface may be annotated with @code{non_null_by_default}.  All
constants, formal parameters, and methods in the interface have a
default specification of @code{non_null}.  All concrete implementations
of this interface must be consistent with these default
specifications. ]]

@item @strong{Status:} The modifier is parsed.  Typechecking implementation
      is underway.  This modifier is not yet used by the static checker.

@item @strong{Differences from JML or Java:} In the current JML2
implementation the @code{non_null_by_default} annotation is file-scoped
rather than class-scoped.

@end itemize

@c @author kiniry
@node nullable_by_default, final-type, non_null_by_default, Type modifiers
@subsection nullable_by_default (JML)

@itemize @bullet
@item @strong{Description:} This annotation is used to 
denote a @code{nullable} default semantics for reference types in a
given class.  An example of its syntax is this:
@example
   public /*@@ nullable_by_default @@*/ class A @{ ... @}
@end example
@noindent
@noindent If a class is labeled with the annotation
@code{nullable_by_default} then every field, formal parameter, and
method has a default specification of @code{nullable}.  Local variables
do not have any default specification.

If a class is annotated @code{nullable_by_default} and a formal
parameter, method, or field is annotated @code{nullable} then the latter
spec is redundant and the user is notified of such.

If a class is annotated @code{nullable_by_default} and a formal
parameter, method, or field is annotated with @code{non_null} then this
specified annotation overrides the class annotation and the reference
may be null.

[[ The scope of this annotation to the class to which it is applied
as well as nested (possibly anonymous) classes.  The class-scoped
annotation is not inherited. ]]

[[ An interface may be annotated with @code{nullable_by_default}.  All
constants, formal parameters, and methods in the interface have a
default specification of @code{nullable}.  All concrete implementations
of this interface must be consistent with these default
specifications. ]]

@item @strong{Status:} The modifier is parsed.  Typechecking implementation
      is underway.  This modifier is not yet used by the static checker.

@item @strong{Differences from JML or Java:} In the current JML2
implementation the @code{nullable_by_default} annotation is file-scoped
rather than class-scoped.

@end itemize

@node final-type, abstract-type, nullable_by_default, Type modifiers
@subsection final (Java)

@itemize @bullet
@item @strong{Description:} A final class may not have subclasses.
@item @strong{Status:} Parsed, typechecked, and used by the static checker.

@item @strong{Differences from JML or Java:} None.

@end itemize

@node abstract-type, strictfp-type, final-type, Type modifiers
@subsection abstract (Java)

@itemize @bullet
@item @strong{Description:} A class must be declared abstract 
if it has abstract methods.  An abstract class may not be
instantiated; only non-abstract subclasses of an abstract class may be
instantiated.  All interfaces are by definition abstract; using the
@code{abstract} modifier on an interface has been deprecated.

@item @strong{Status:} This modifier is parsed and checked.  It does not need
any static checking.
@item @strong{Differences from JML or Java:} None.

@end itemize

@node strictfp-type, static-type, abstract-type, Type modifiers
@subsection strictfp (Java)

@itemize @bullet
@item @strong{Description:} 
The @code{strictfp} modifier determines the semantics of floating
point operations within the class so modified.

@item @strong{Status:} This modifier is parsed and typechecked.  
The static checker does not make use of this information.  [[[ Is it
inherited, or does it just apply to the implementations given in that
class?  If so, what about interfaces (maybe applies just to
initializers in interfaces)?]]]

@item @strong{Differences from JML or Java:} None.

@end itemize

@node static-type,  , strictfp-type, Type modifiers
@subsection static (Java)
@itemize @bullet
@item @strong{Description:} @code{static} is a Java modifier 
that may be applied to classes and interfaces that are members of
enclosing classes.

@item @strong{Status:} Implemented.

@item @strong{Differences from JML or Java:} None.
@end itemize

@node Type Annotations, Type Annotation clauses, Type modifiers, Status
@section Annotations pertinent to a class or interface
These annotations may appear anywhere a declaration 
within a class or interface may appear.  They define specification-only
ghost or model fields of the type and state specifications that apply to
the whole object (not just to individual methods).

@menu
* Ghost fields::                
* Model fields::                
* Model methods::               
* Model constructors::          
* Model types::                 
* Java initializer blocks::     
* initializer::                 
* static initializer::          
* Java method::                 
* Nested types::                
@end menu

@node Ghost fields, Model fields, Type Annotations, Type Annotations
@subsection Ghost fields
@itemize @bullet
@item @strong{Description:} 
A ghost field is a field of the object that can hold a
primitive value or a reference to an object, but is used only in
specifications.  Its value is changed using the @code{set} annotation
within the body of a method or constructor (@pxref{set}).  A ghost
field may have an initializer, just as a Java program field may, but
the ghost field may be initialized in only one compilation unit of a
refinement sequence.  A ghost field may have modifiers that a Java
field declaration would have (namely, access modifiers (@pxref{Access
modifiers}), @code{static}, @code{final}, but not @code{volatile},
@code{transient}) as well as the JML modifiers @code{non_null}, @code{nullable},
@code{monitored} and @code{instance} (@pxref{Field Annotation modifiers}).

An interface may also declare ghost fields; these fields may be
referenced by annotations in the interface or its subtypes.  Such
ghost fields are by default static, but may be modified by the JML
modifier @code{instance}, in which case they are a field of every
object that implements the interface.


@item @strong{Status:} Ghost fields are completely supported.

@item @strong{Differences from JML or Java:} None.
[[[Check that modifiers work.]]]

@end itemize

@node Model fields, Model methods, Ghost fields, Type Annotations
@subsection Model fields
@itemize @bullet
@item @strong{Description:} Model fields are declarations within an annotation
prefixed by the modifier @code{model}.  They do not represent actual
specification fields as do @code{ghost} values.  Rather, their values
are implied by the concrete representation of the class, either by an
explicit expression in a @code{represents} clause or implicitly by a
boolean condition in a @code{\such_that} form of the @code{represents}
clause.  They are used to supply values that @emph{model} the behavior
of the class.

A model field may have these modifiers: access modifiers
(@pxref{Access modifiers}), @code{static}, [[[ what about @code{final}
]]] and the JML modifiers @code{non_null}, @code{nullable}, [[[@code{monitored} ???]]] and
@code{instance} (@pxref{Field Annotation modifiers}).  
Model fields may not have initializers.  [[[ An
initializer expression would make nice syntactic sugar for the
combination of a model declaration and a represents clause. ]]]

@item @strong{Status:} Model fields are parsed and used in typechecking. 
[[[ Inconsistencies between multiple represents clauses are usually not found. ]]]


@item @strong{Differences from JML or Java:} None.

@end itemize

@node Model methods, Model constructors, Model fields, Type Annotations
@subsection Model methods
@itemize @bullet
@item @strong{Description:} Model methods are method declarations within an
annotation and modified with the modifier @code{model}.  They declare
methods that may be used in model programs and (if pure) in
specifications.  Model methods may have these Java modifiers:
@code{public}, @code{protected}, @code{private}, @code{static},
@code{abstract}, @code{final}, @code{synchronized}, @code{strictfp};
they may have these JML modifiers: @code{pure}, @code{non_null},
@code{nullable}, and @code{helper}.

Model methods may be declared in multiple specification files, but may have 
an implementation in at most one.


@item @strong{Status:} Model methods are parsed and converted to regular Java 
methods within ESC/Java2.  The use of model methods in 
static checking is described in [[[ ??? ]]]

@item @strong{Differences from JML or Java:} Model methods are parsed and 
converted to regular Java methods within ESC/Java2.  Consequently,
ESC/Java2 will not detect their (illegal) use within the
implementation of a Java routine.  [[[ Some related scoping issues in the
presence of inheritance. ]]]

@end itemize

@node Model constructors, Model types, Model methods, Type Annotations
@subsection Model constructors
@itemize @bullet
@item @strong{Description:} Model constructors are constructor
 declarations within an annotation and modified with the modifier
@code{model}.  They declare constructors that may be used in model
programs and (if pure) in specifications.  A model constructor may
have these Java modifiers: @code{public}, @code{protected},
@code{private}; it may have these JML modifiers: @code{pure},
@code{helper}. Constructors may be @code{strictfp} only by virtue of
the entire class being declared @code{strictfp}.

Model constructors may be declared in multiple specification files,
but may have an implementation in at most one.

@item @strong{Status:} Model constructors are parsed and converted 
to regular Java constructors within ESC/Java2.  
@item @strong{Differences from JML or Java:} Model constructors are parsed and 
converted to regular Java constructors within ESC/Java2.
Consequently, ESC/Java2 will not detect their (illegal) use within the
implementation of a Java routine.

@end itemize

@node Model types, Java initializer blocks, Model constructors, Type Annotations
@subsection Model class and model interface declarations
@itemize @bullet
@item @strong{Description:} A model type (class or interface) declaration
is a conventional type declaration modified by the JML keyword @code{model}
(and in an annotation comment).  The entire declaration must be within one
annotation comment.  The model type may be used within annotation expressions
and statements.  Model types may have the same modifiers as top-level
and nested java type declarations, as appropriate (see Appendix A).

@item @strong{Status:} Implemented.

@item @strong{Differences from JML or Java:} Model types are in the same
name space as conventional Java types.  Thus in some cases the
resolution of a type name in Java code could resolve to a model type
name rather than to the correct Java type.  This is a bug in the name
scoping of both JML and ESC/Java2; the workaround is to rename the
model type so that it does not hide a Java type name.

@end itemize

@node  Java initializer blocks, initializer, Model types, Type Annotations
@subsection Java initializer blocks
@itemize @bullet
@item @strong{Description:} Java permits blocks of code within braces in
the body of a class (but not interface) declaration.  In the process of
loading a class, each initializer of a static field and each initializer code
block with a static modifier is executed in textual sequential order.  
Similarly, when an instance of a class is created, each initializer of a 
non-static field and each non-static initializer block is executed in 
textual sequential order.  Each initializer block may be preceded by a
specification, just like a method specification.  The preconditions and
postconditions specified must hold just before and just after the execution
of the initializer block.  Note that no invariants or other class-level 
specifications are required to hold until all static initialization and class
loading is complete (for static invariants) or until a constructor has 
completed execution (for instance invariants).

@item @strong{Status: } Most specifications are parsed but not all and 
      no reasoning is implemented.

@item @strong{Differences from JML or Java:} None.
@end itemize

@node initializer, static initializer, Java initializer blocks, Type Annotations
@subsection initializer
@itemize @bullet
@item @strong{Description:} The JML @code{initializer} and 
@code{static_initializer} keywords are used in specification files as
stand-ins for all of the instance and class initialization that is
performed as part of object creation or class loading. Within a class
declaration in a compilation unit there may be just one each of the
@code{initializer} and @code{static_initializer} keywords, each preceded
by specifications (like those preceding a routine declaration or a Java
initialization block).  If more than one compilation unit of a
refinement sequence has these keywords, then the associated
specifications are combined just like routine specifications are
combined.  The composite specifications associated with an
@code{initializer} keyword give preconditions that must hold before any
instance initialization and postconditions that must hold after any
instance initialization (but before constructors are executed).
Similarly, the specifications of a @code{static_initializer} keyword
hold before and after the static initialization of the class.  Note that
these are different than the specifications for a Java initializer
block, which apply only to that block.

@item @strong{Status:} Not yet parsed or implemented in static checking.

@item @strong{Differences from JML or Java:} None. 
[[[ What access modifiers are allowed and used ???]]]


@end itemize

@c -----------------------------------------------------------------------
@node static initializer, Java method, initializer, Type Annotations
@subsection static_initializer
@itemize @bullet
@item @strong{Description:} See the description above.

@item @strong{Status:} Not yet parsed or implemented in the static checker.

@item @strong{Differences from JML or Java:} None.
[[[ What access modifiers are allowed and used ???]]]

@end itemize

@c -----------------------------------------------------------------------
@node Java method, Nested types, static initializer, Type Annotations
@subsection Java method, constructor and field declarations
@itemize @bullet

@item @strong{Description:} These declarations are identical 
to those defined by Java.  An implementation or initialization for
such a declaration may appear only in the .java file, not in any
repeated declaration in a specification file.  The modifiers allowed
are listed in Appendix A.

@item @strong{Status:} Parsed and typechecked fully.  
Java fields may be used in annotations.  JML and ESC/Java2 also allow
pure methods and pure constructors to be used in annotations.

@item @strong{Differences from JML or Java:} None
@end itemize

@c -----------------------------------------------------------------------
@node Nested types,  , Java method, Type Annotations
@subsection Nested Java type declarations
@itemize @bullet

@item @strong{Description:} Java allows declarations of classes and interfaces
within a class or interface.  These are called nested classes or
interfaces.  Inner classes or interfaces are nested classes or interfaces
that are not @code{static}.  The modifiers allowed are listed in 
Appendix A.

@item @strong{Status:} Implemented.

@item @strong{Differences from JML or Java:} None

@end itemize

@c ------ section Annotation clauses for a class or interface --------
@node Type Annotation clauses, Routine Annotations, Type Annotations, Status
@c  node-name,  next,  previous,  up
@section Annotation clauses for a class or interface
These clauses provide a specification of the behavior of the class and
of objects of the class.  They may be specified in any order, within
annotation comments, anywhere an element of a type declaration may
appear.  They may individually have access modifiers (@pxref{Access
modifiers}) @code{public}, @code{protected}, or @code{private}.

@menu
* invariant::                   
* constraint::                  
* represents::                  
* axiom::                       
* initially::                   
* readable::                    
* monitorsfor::                 
@end menu

@c ----------------------------------------------------------------------
@node invariant, constraint, Type Annotation clauses, Type Annotation clauses
@subsection invariant, invariant_redundantly
@itemize @bullet
@item @strong{Description:} An @code{invariant} clause specifies a boolean 
condition that must hold before and after any call of a (non-helper) method 
of the containing type.  Invariants must hold after any (non-helper)
constructor call of the containing type.  In checking the implementation of
a method, invariants are assumed as part of the preconditions and must be
established as part of the postconditions.

An @code{invariant} clause may be declared @code{static}, in which case it
may only reference static fields and routines.

@item @strong{Status:} Fully implemented, except that ESC/Java2 does not
check the restriction on static invariants.

@item @strong{Differences from JML or Java:} None

@end itemize

@c ----------------------------------------------------------------------
@node constraint, represents, invariant, Type Annotation clauses
@subsection constraint, constraint_redundantly
@itemize @bullet
@item @strong{Description:} 
A @code{constraint} clause specifies a relation that must hold between
the pre- and post-conditions of any (non-helper) method of the
containing type.  If the clause is declared @code{static}, then all field
and routine references within the constraint predicate must be static.

@item @strong{Status:} Parsed and typechecked.  The static checker issues a 
warning if the constraint is not true as part of the postconditions of any 
method (but does not check constraints in association with constructors).

@item @strong{Differences from JML or Java:} ESC/Java2 does not check the
restriction on static constraints.

@end itemize

@c ----------------------------------------------------------------------
@node represents, axiom, constraint, Type Annotation clauses
@subsection represents, represents_redundantly
@itemize @bullet
@item @strong{Description:} 
A @code{represents} clause designates how a model field is related to
the concrete fields or other model fields of the implementation.
The represents clause must be declared static when and only when the model
field for which it is providing a representation is declared static; if
the clause is static then all field and routine references must be static.

@item @strong{Status:} Parsed, typechecked, and used by the static checker.

@item @strong{Differences from JML or Java:} None.  ESC/Java2 does not check 
the restrictions on static.

@end itemize

@c ----------------------------------------------------------------------
@node axiom, initially, represents, Type Annotation clauses
@subsection axiom
@itemize @bullet
@item @strong{Description:} An @code{axiom} is used to specify a mathematical
property, independent of the implementation of classes or objects.
Axioms are always considered to be static.
[[[ Describe circumstances in which an axiom is added to the proof context]]]
[[[ Are access modifiers allowed ???]]]

@item @strong{Status:} Implemented.

@item @strong{Differences from JML or Java:} None.


@end itemize

@c ----------------------------------------------------------------------
@node initially, readable, axiom, Type Annotation clauses
@subsection initially, initially_redundantly
@itemize @bullet
@item @strong{Description:} This clause specifies a condition 
that must hold in the post-state of any (non-helper) constructor
(including the default constructor).  Within the body of a
constructor, any superclass @code{initially} clauses are assumed to hold
after the execution of a (non-helper) @code{super(...)} call,
including a possible implied call of the default superclass
constructor.  A class does not inherit any superclass @code{initially}
clauses; @code{initially} clauses are not permitted in interfaces.
If the clause is declared static, it may only reference static fields
and routines.

@item @strong{Status:} Implemented.  @code{Initially} clauses are 
typechecked as 
additional postconditions on every constructor of a class.  Failures provoke
an `Initially' warning.

@item @strong{Differences from JML or Java:} None.  
[[[ Actually TBD - JML has not
clarified the semantics of @code{initially} clauses, such 
as whether they are inherited and whether they can be
present in interfaces. ]]]


@end itemize

@c ---------------------------------------------------------------------------
@node readable, monitorsfor, initially, Type Annotation clauses
@subsection readable and writable
@itemize @bullet
@item @strong{Description:} 
JML allows class-level clauses of the form 
@*@center @code{readable} @emph{field} @code{if} @emph{predicate} @code{;}
@*and
@*@center @code{writable} @emph{field} @code{if} @emph{predicate} @code{;}
@*These specify a predicate that must be true in the state in which a read
or write access of a class field is attempted.  These are useful to 
specify the access protocol for a variable shared across threads, but can also
be used simply to indicate under what circumstances a field's value is 
defined.

@item @strong{Status:} Implemented.  However, the semantics is
not well-defined for the situation
in which the field referred to in the clause is declared in a superclass of
the class declaration containing the clause.

@item @strong{Differences from JML or Java:}
ESC/Java also allows a @code{readable_if} and @code{writable_if} modifier
for field declarations (each taking simply a predicate and are positioned
just prior to the field declaration, as, for example, a @code{non_null}
modifier would be).  @code{readable_if} is deprecated in JML and 
@code{writable_if} is not defined at all.  Hence these forms are discouraged 
in ESC/Java2 as well.


@end itemize

@c ---------------------------------------------------------------------------
@node monitorsfor,  , readable, Type Annotation clauses
@subsection monitors_for
@itemize @bullet
@item @strong{Description:} This clause associates a list of expressions with
a given field name.  The field identified must be a field of the class
containing the declaration.  All of the expressions must evaluate to objects
(not to primitive values).  If the field is static, all of the objects must
be static.  The effect is to associate the expression values as monitors for
the given object.

@item @strong{Status:} Implemented.
[[[ Should a list of ids be allowed? ]]]
[[[ Should syntax such as this.*, T.* for classname T be allowed? ]]]
[[[ Is a static modifier allowed???]]]

@item @strong{Differences from JML or Java:} None.

@end itemize

@c ---------------------------------------------------------------------------
@node Routine Annotations, Routine Annotation clauses, Type Annotation clauses, Status
@section Annotations for a method or constructor
Specifications of the behavior of an individual method or constructor
typically appear within an annotation comment, just prior to the
declaration of the method or constructor.  The specifications consist
of zero or more lightweight or heavyweight behavior sections, an
optional @code{code_contract} section, an optional @code{implies_that}
section, and an optional @code{for_example} section.  Model methods
and constructors may also be annotated with these specifications.

@menu
* specifications::              
* also desugaring::             
* modelprogram::                
* codecontract::                
* impliesthat::                 
* forexample specification::    
@end menu

@c ---------------------------------------------------------------------------
@node specifications, also desugaring, Routine Annotations, Routine Annotations
@subsection Lightweight and heavyweight specifications
@itemize @bullet
@item @strong{Description:} Lightweight specification cases are simply 
a series of specification clauses and correspond to the specification
style of ESC/Java.  Heavyweight specification cases are introduced
with a @code{behavior}, @code{normal_behavior}, or
@code{exceptional_behavior} keyword.  Heavyweight specifications may
have optional privacy modifiers (@pxref{Access modifiers}) and have
different defaults than do lightweight specifications.

Within a heavyweight specification, if a particular clause type is
omitted, the default for that clause is as follows:
@example
        ensures true;
        signals (java.lang.Exception) true;
        diverges false;
        assignable \everything;
        accessible \everything;
        callable \everything;
        when true;
        duration \not_specified; [[[ infinite ???]]]
        working_space \not_specified; [[[ infinite ???]]]
@end example
@noindent
The defaults defined by JML for lightweight specifications are
@code{\not_specified} in each case.  This is interpreted within
ESC/Java2 as follows.
@example
        ensures true;
        signals (java.lang.Exception) true;
        diverges true;
        assignable \everything;
        accessible \everything;
        callable \everything;
        when true;
        duration \not_specified;
        working_space \not_specified;
@end example
@c [[[ need measured_by eventually ]]]
@noindent
The default for the requires clause is determined as follows:
@footnote{Michael M@"oller contributed to this
formulation of the defaults for requires.}
@itemize @bullet

@item If there are some other clauses explicitly given, but no 
requires clause, the default is @code{requires true;}

@item If there is no specification at all and the 
routine is a constructor or is a method that does not override any
superclass or superinterface methods, the default is @code{requires
true;}

@item If there is no specification at all (including no 
@code{non_null} modifier) and the method does override some superclass
or superinterface method, the default is @code{requires false;}

@item For the default constructor, if no specifications 
have been given, the default requires specification is the same as the
requires specification of the corresponding superclass constructor.

@end itemize

The reasons for these defaults are explained in 
@ref{Specifications and inheritance}.

The modifies clause has this exception to the above rule: For the
default constructor, if no specifications have been given, the default
modifies specification is the same as the modifies specification of
the corresponding superclass constructor. (This is not a textual
replication; rather the subclass constructor may modify the same set
of locations, under the same conditions, as the superclass
constructor.)  Note that the defaults for the @code{diverges} clause
are different between the lightweight and heavyweight forms.  The
lightweight default, @code{diverges true}, puts the least restrictions
on the implementation; it states that the implementation is allowed to
be non-terminating (but not required to be).  The heavyweight default,
@code{diverges false}, requires the implementation to terminate with
either an exception or a normal return.  [[[ However, this is not
checked in the current implementation. ]]]

@item @strong{Status:} The lightweight and heavyweight specification forms,
including nesting using @code{@{|} and @code{|@}} and combination with
@code{also}, are fully parsed and implemented (though not all clause
types, as described below, are fully implemented or handled by the
static checker).

@item @strong{Differences from JML or Java:} 
None, except that ESC/Java2 does not constrain the order of clauses as
rigidly as do JML tools. JML requires forall, old and requires clauses
to precede any other clauses; with a warning level of -w2 (not the
default), JML will also warn about deviations from a recommended order
of the other clause types.  ESC/Java2 will accept clauses in any order
(but note that the scope of @code{forall} and @code{old} does not
include clauses that precede them). [[[ Esc/Java2 does not currently
check the access modifiers on behavior and example keywords.  What
happens with the privacy checking? ]]]

@anchor{Desugaring}
@item @strong{Comment:} The ESC/Java2 (and ESC/Java) translator,
which produces the verification conditions to be checked by the static
checker, accepts a set of specification clauses in lightweight form.
In order to handle the nested and heavyweight forms and the
combination of specifications using @code{also}, either within one
source file or across a refinement sequence, ESC/Java2 @emph{desugars}
the more complicated syntax into a simpler form.  For this purpose
ESC/Java2 largely follows the desugaring as outlined in [[[FIXME -
provide ref]]], but it does not need to desugar all clauses of a given
type down to one instance of that clause type.  That paper provides
more details on the desugaring process; @footnote{Its treatment of
assignable clauses is incorrect.}  the equivalent but slightly simpler
version used in ESC/Java2 is outlined here. Note that the desugaring
process must take care not to lose the location information that is
helpful to the user when warning messages are issued.

The desugaring process first eliminates nesting by replicating and
distributing the @code{forall}, @code{old}, and @code{requires}
clauses across the nested groups of clauses.  Any @code{old} clauses
are desugared by replacing any references to them by the expression
with which they are initialized (evaluated in the pre-state); any
@code{forall} clause is desugared by wrapping any clause within its
scope in a @code{\forall} quantified expression.  Also, each
lightweight specification case, @code{normal_behavior} and
@code{exceptional_behavior} keyword is desugared into a
@code{behavior} specification.  Specifications from corresponding
methods in the refinement sequence are combined, connected by
@code{also}.  That produces a series of specification cases, connected
by @code{also}, each consisting of one group of clauses (that is, one
specification case).  ESC/Java2's static checker will accept a single
specification case.  For each specification case, a composite
precondition predicate is formed by taking the conjunction of the
predicates in each of the @code{requires} clauses in that
specification case, and making that conjunction the argument of an
@code{\old} function: 
@center @emph{pre-predicate} = @code{\old(}@emph{p1} @code{&&} @emph{p2} ... @code{)}
@*Each clause within the specification case is altered by constraining
its action using that conjunction.  Calling that combined predicate
@emph{pre-predicate}, we transform each clause as follows:
@itemize @bullet

@item @code{ensures} @emph{pred}@code{;}
@*becomes 
@*@code{ensures} @emph{pre-predicate} @code{==>} @emph{pred}@code{;}

@item @code{diverges} @emph{pred}@code{;}
@*becomes 
@*@code{diverges} @emph{pre-predicate} @code{==>} @emph{pred}@code{;}

@item @code{modifies} clauses:  Multiple modifies clauses within
one specification case are combined into one clause, along with the
composite precondition for that specification case; modifies clauses
from different specification cases are not combined.

@item @code{signals} (@emph{type} @emph{id} @code{)} @emph{pred}@code{;}
@*becomes
@*@code{signals} (@emph{type} @emph{id} @code{)} @emph{pre-predicate} @code{==>} @emph{pred}@code{;}
@item when -- [[[ complete this ]]]
@item accessible -- [[[ complete this ]]]
@item callable -- [[[ complete this ]]]
@item duration -- [[[ complete this ]]]
@item working_space -- [[[ complete this ]]]
@end itemize
The requires clauses are desugared by replacing all of the requires
clauses in all of the specification cases with a single requires
clause whose predicate is the disjunction of the conjuctions formed
for each specification case, without the enclosing @code{\old}.  When
the static checker creates a VC to be used as a precondition for
calling a method, it forms a disjunction of the requires clauses for
the method and all the declarations that it overrides.

@end itemize

@node also desugaring, modelprogram, specifications, Routine Annotations
@subsection also

@comment{Need to actually say what also does! -JRK}

@itemize @bullet
@item @strong{Description:} 
JML allows multiple specifications for a single method declaration;
these are separated and connected by the @code{also} keyword.
Furthermore, if the method has additional declarations (with or
without specifications) in an earlier source file in the refinement
sequence or an overridden method in a superclass or interface, then
(and only then) the specification must begin with @code{also} to
indicate that there are some previous declarations, with possible
specifications, of which the reader should be aware.

@item @strong{Status:} 
The use of @code{also} is completely implemented, with desugaring
occurring as described above.

@item @strong{Differences from JML or Java:} None.

@cindex also_requires
@cindex also_modifies
@cindex also_ensures
@cindex also_exsures
@item @strong{Comment:} 
This syntax for combining specifications is different than and not
backwards compatible with the syntax used in ESC/Java.  That tool did
not allow combining multiple specifications using @code{also} and did
not support refinement sequences.  Where there was inheritance of
specification clauses from a superclass or interface, the keywords
@code{also_requires}, @code{also_ensures}, @code{also_modifies}, and
@code{also_exsures} were required.  These keywords are not supported
in ESC/Java2 and such specifications will need to be rewritten using
the new @code{also} syntax.
@end itemize

@c ----------------------------------------------------------------------------
@node modelprogram, codecontract, also desugaring, Routine Annotations
@subsection model_program

@itemize @bullet
@item @strong{Description:} Model programs are an alternate way to provide 
specifications for a method.  Rather than stating logical conditions
that the pre- and post-states must satisfy, the behavior is specified
by a @emph{model program}, which specifies the behavior using typical
imperative programming constructs.  However, a model program allows
some non-deterministic (and non-executable) constructs as well.  Note
that there are a number of JML constructs which are only used within
model programs. These are described in @ref{Statements within model
programs}.

@item @strong{Status:} Model programs are parsed and ignored.  
They are permitted as a specification case, as defined by JML.  Any
constructs unique to model programs are simply skipped over by the
parser.

@item @strong{Differences from JML or Java:} None.

@end itemize

@c ----------------------------------------------------------------------------
@node codecontract, impliesthat, modelprogram, Routine Annotations
@subsection code_contract
[[[ Needs discussion - also accessible, callable, captures, measured_by clauses ]]]

@c ----------------------------------------------------------------------------
@node impliesthat, forexample specification, codecontract, Routine Annotations
@subsection implies_that
@itemize @bullet
@item @strong{Description:} The @code{implies_that} keyword introduces
specification cases that are logical consequences of the usual
behavior and lightweight specifications.  They could be used as
specifications to be checked in the same way that the other
specifications are.  Alternatively, it could be verified that they are
logical consequences of the other specifications; the results could
then be used as additional useful statements of behavior; these in
turn could help with proofs involving use of the method or constructor
with which the @code{implies_that} specification is associated.

@item @strong{Status:} The specifications in an @code{implies_that} section are
parsed [[[and typechecked?]]], but not used within any static checking.

@item @strong{Differences from JML or Java:} None.

@end itemize

@c ----------------------------------------------------------------------------
@node forexample specification,  , impliesthat, Routine Annotations
@subsection for_example specification
@itemize @bullet
@item @strong{Description:} The @code{for_example} keyword introduces 
specification cases that are useful and instructional examples for the
reader of the specifications.  Hence they must be logical consequences
of the other specifications.  Each case may be lightweight or be
introduced by one of the keywords @code{example},
@code{normal_example}, and @code{exceptional_example}; these keywords
may have associated access modifiers (@pxref{Access modifiers}).

@item @strong{Status:} The specifications in a @code{for_example} section are
parsed [[[and typechecked?]]], including the @code{example},
@code{normal_example}, and @code{exceptional_example} keywords.
However, they are not used within any static checking, nor is it
verified that they follow from the other specifications.

@item @strong{Differences from JML or Java:} None.


@end itemize


@c ------ Annotation clauses for a method or constructor --------
@node Routine Annotation clauses, Routine modifiers, Routine Annotations, Status
@c  node-name,  next,  previous,  up
@section Annotation clauses for a method or constructor

In this section we describe the clause types that may be part of
specifications, including @code{implies_that} and @code{for_example}
sections.  Note that some clauses have alternate keywords reflecting
different personal preferences or different usages among ESC/Java2 and
other JML tools.  These alternates are complete synonyms.


@menu
* forall::                      
* old::                         
* requires::                    
* ensures::                     
* signals::                     
* modifies::                    
* diverges::                    
* when::                        
* duration::                    
* workingspace::                
* accessible::                  
* callable::                    
* measuredby::                  
* Redundancy::                  
@end menu

@c ---------------------------------------------------------------------------
@node forall, old, Routine Annotation clauses, Routine Annotation clauses
@subsection forall
@itemize @bullet
@item @strong{Description:} The @code{forall} declaration declares a
universally quantified variable; the scope of the declaration is all
subsequent clauses for the same routine up to the @code{also} or
@code{|@}} marking the end of the specification case containing the
@code{forall} declaration, or until end of the behavior, implies_that
or for_example section.  No initializer is allowed.  The clause is
desugared by wrapping each desugared clause that is in scope in an
appropriate @code{\forall} expression.

@item @strong{Status:} Fully implemented.  
However, the semantics need clarifying and the static checker objects
to quantified expressions.

@item @strong{Differences from JML or Java:} None.


@end itemize

@c --------------------------------------------------------------------------
@node old, requires, forall, Routine Annotation clauses
@subsection old
@itemize @bullet
@item @strong{Description:} The @code{old} declaration is used within a 
routine specification to define a value that may be used in subsequent
clauses of the specification.  The variable declared must be
initialized.  The initialization expression is always evaluated in the
pre-state, regardless of how the variable is used in subsequent
clauses.  The scope of the variable extends from its declaration
(including the initializer), to the `also' or `|@}' that marks the end
of the specification case sequence containing the @code{old}
declaration, or until the end of the behavior, implies_that or
for_example section.  The uses of @code{old} variables are desugared
by substituting the initialization expression, wrapped in an
appropriate @code{\old} expression, at the point of use.

@item @strong{Status:} Implemented.  [[[ Not yet supported: array initializers. ]]] [[[ I don't think that ESC/Java2 includes the initializer in the scope. ]]]
[[[ Check what the java behavior is and fix the definition here. ]]]

@item @strong{Differences from JML or Java:} None.


@end itemize

@c ---------------------------------------------------------------------------
@node requires, ensures, old, Routine Annotation clauses
@subsection requires, requires_redundantly, pre, pre_redundantly
@itemize @bullet

@item @strong{Description:} A requires clause specifies a 
condition that must hold in the pre-state of the method, in the
context where it is called in the program.  The remaining clauses of
the specification case must hold whenever the requires clause (or the
conjunction of multiple requires clauses) holds.  The expression in
the clause may also be @code{\not_specified}, which is equivalent to
omitting the clause.  The expression must have boolean type and is
evaluated in the pre-state.

@item @strong{Status:} The requires clause is implemented and is 
utilized by ESC/Java2 in generating verification conditions.

@item @strong{Differences from JML or Java:} None.

[[[ Decide, discuss use of this, instance variables in constructor preconditions]]]
[[[ Note any change from ESC/Java]]]

@end itemize

@c ---------------------------------------------------------------------------
@node ensures, signals, requires, Routine Annotation clauses
@subsection ensures, ensures_redundantly, post, post_redundantly
@itemize @bullet
@item @strong{Description:} An ensures clause states a condition 
that must hold in the post-state of a method or constructor whenever
the associated preconditions hold in the pre-state and the method or
constructor exits normally.  The expression in the clause may also be
@code{\not_specified}, which is equivalent to omitting the clause.
The expression must have boolean type and is evaluated in the
post-state.

@item @strong{Status:} Implemented and used by the static checker.

@item @strong{Differences from JML or Java:} None.

@end itemize

@c ---------------------------------------------------------------------------
@cindex signals
@cindex signals_redundantly
@cindex exsures
@cindex exsures_redundantly
@node signals, modifies, ensures, Routine Annotation clauses
@subsection signals, signals_redundantly, @*exsures, exsures_redundantly
@itemize @bullet
@item @strong{Description:} A signals clause states a condition 
that must hold in the post-state of a method or constructor whenever
the associated preconditions hold in the pre-state and the method or
constructor exits with an exception of (or a subclass of) the
designated type.  The expression in the clause may also be
@code{\not_specified}, which is equivalent to omitting the clause.
The expression must have boolean type and is evaluated in the
post-state (though the keyword @code{\result} is not valid in a
@code{signals} clause).

@item @strong{Status:} Implemented and used by the static checker.

@item @strong{Differences from JML or Java:} None.

@end itemize

@c ---------------------------------------------------------------------------
@cindex modifies
@cindex modifiable
@cindex assignable
@cindex modifies_redundantly
@cindex modifiable_redundantly
@cindex assignable_redundantly
@node modifies, diverges, signals, Routine Annotation clauses
@subsection modifies, modifiable, assignable, modifies_redundantly, modifiable_redundantly, assignable_redundantly
@itemize @bullet
@item @strong{Description:} The modifies clause indicates 
which memory locations may be assigned within the associated routine
when the routine is called in a pre-state that satisfies the
associated preconditions.  The list of locations in the modifies
clause may also contain the special keywords @code{\nothing},
@code{\everything}, @code{\not_specified}, and the wild-card forms
@emph{expr}@code{.*} , @emph{typename}@code{.*} ,
@emph{array}@code{[*]}, and @emph{array}@code{[}@emph{expr} @code{..}
@emph{expr}@code{]}.
Any expressions in the clause are evaluated in the pre-state.

Each location listed in the clause implicitly includes all the elements of
its datagroup, if a datagroup is associated with the location.  Other 
memory locations are added to a location's datagroup using the 
@code{in} and @code{maps} clauses (@pxref{Field Annotations}).

@item @strong{Status:} Implemented and used by the static checker.  ESC/Java2
checks that assignments within a routine are consistent with the routine's
modifies clauses and checks that the modifies clauses of called routines are
consistent with those of the caller.

However, ESC/Java2 is not yet able to properly handle the forms
@code{\everything}, @code{array[*]} and @code{array[e1..e2]} when in
the modifies clause of a routine called within the body of a calling
routine (and remember that @code{modifies \everything} is the
default).  For example, given

@example
public int i;
public int[] a;

//@@ modifies \everything;
void m() @{ ... @}

//@@ modifies a[*];
void n() @{ ... @}

//@@ modifies a[2..10];
void nn() @{ ... @}

//@@ modifies \nothing;
void p() @{
        i = 0;
        m();
        //@@ assert i == 0;
        a[3] = 0;
        n();
        //@@ assert a[3] == 0;
        a[3] = 0;
        nn();
        //@@ assert a[3] == 0;
@}
@end example
@noindent
ESC/Java2 should complain that the first assert statement in routine
@code{p} is not established, because @code{m}, which claims to
possibly modify everything, might have modified field @code{i}.  It
will complain that the modifies clauses of the two routines are in
conflict.  It will also complain about the assert statement if
@code{m} had a modifies clause of @code{modifies i;}.  Similarly the
forms of array range designators in the modifies clauses of @code{n}
and @code{nn} are not fully handled, so the second and third assert
statements do not provoke complaints.  Store-ref expressions that are
specific array elements or the forms @code{expr.*} and
@code{typename.*} are handled properly.
 
A second aspect of modifies clauses not being fully handled is 
the following.  Within a class that has a field named @code{i}
 @example
 //@@ modifies this.*;
 public void m() @{
        n();
 @}
 
 //@@ modifies i;
 public void n();
 @end example
@*provokes no complaints, since @code{i} is recognized 
as part of @code{this.*}.  However, in
@example
 //@@ modifies i;
 public void m() @{
        n();
 @}
 
 //@@ modifies this.*;
 public void n();
 @end example
ESC/Java2 will issue a warning, since it does not check that all
possible fields of the class (any of which might be modified by
@code{n}) are listed in the modifies clause of @code{m}.  The similar
situation holds for static members.
 
@end itemize

@c ----------------------------------------------------------------------------
@cindex diverges
@cindex diverges_redundantly
@node diverges, when, modifies, Routine Annotation clauses
@subsection diverges, diverges_redundantly
@itemize @bullet
@item @strong{Description:} This clause states a predicate that must hold 
(in the pre-state) if the method never terminates (given that the
associated precondition holds in the pre-state).  The expression in
the clause may also be @code{\not_specified}, which is equivalent to
omitting the clause.  The expression must have boolean type and is
evaluated in the pre-state.

@item @strong{Status:} Parsed and typechecked, but not used in 
any static checking.

@item @strong{Differences from JML or Java:} None.


@end itemize

@c ----------------------------------------------------------------------------
@cindex when
@node when, duration, diverges, Routine Annotation clauses
@subsection when
@itemize @bullet
@item @strong{Description:} description.... [[[ description needed ]]]
  The expression in the clause
may also be @code{\not_specified}, which is equivalent to omitting the clause.
The expression must have boolean type and is evaluated in the pre-state.

@item @strong{Status:} Parsed and typechecked, but not used in 
any static checking.

@item @strong{Differences from JML or Java:} None.

@end itemize

@c ----------------------------------------------------------------------------
@cindex duration
@node duration, workingspace, when, Routine Annotation clauses
@subsection duration
@itemize @bullet
@item @strong{Description:} This specification asserts that the execution of 
the routine (with the given preconditions) will not exceed the stated
number of virtual machine cycles.  The expression in the clause may
also be @code{\not_specified}, which is equivalent to omitting the
clause.  The expression must have @code{long} type and is evaluated in
the post-state.  [[[ What happens if \result is undefined because of
an exceptional return?]]]

@item @strong{Status:} Parsed and typechecked but not used in 
any static checking.

@item @strong{Differences from JML or Java:} None.


@end itemize

@c ----------------------------------------------------------------------------
@cindex working_space
@node workingspace, accessible, duration, Routine Annotation clauses
@subsection working_space
@itemize @bullet
@item @strong{Description:} This specification asserts that the execution
of the routine will not utilize more than the stated number of bytes
of heap space.  The expression in the clause may also be
@code{\not_specified}, which is equivalent to omitting the clause.
The expression must have @code{long} type and is evaluated in the
post-state.  [[[ What happens if \result is undefined because of an
exceptional return?]]]

@item @strong{Status:} Parsed and typechecked, but not used in 
any static checking.

@item @strong{Differences from JML or Java:} None.

@end itemize

@c ----------------------------------------------------------------------------
@cindex accessible
@node accessible, callable, workingspace, Routine Annotation clauses
@subsection accessible
@itemize @bullet
@item @strong{Description:} description....[[[ description needed ]]]
  The list of locations in the clause may also contain the special
keywords @code{\nothing}, @code{\everything}, Any expressions
(e.g. array indices) are evaluated in the pre-state.

[[[ COmment on @code{not_specified}. ]]]

@item @strong{Status:} status....  - status unknown

@item @strong{Differences from JML or Java:} bugs...

@end itemize

@c ----------------------------------------------------------------------------
@cindex callable
@node callable, measuredby, accessible, Routine Annotation clauses
@subsection callable
@itemize @bullet
@item @strong{Description:} description....[[[ description needed ]]]
  The list of locations in the clause
may also contain the special keywords @code{\nothing}, @code{\everything},
Any expressions (e.g. array indices) are evaluated in the pre-state.

[[[ COmment on @code{not_specified}. ]]]

@item @strong{Status:} status....  - status unknown

@item @strong{Differences from JML or Java:} bugs...

@end itemize

@c ----------------------------------------------------------------------------
@node measuredby, Redundancy, callable, Routine Annotation clauses
@subsection measured_by
@itemize @bullet
@item @strong{Description:} description.... [[[ Description needed ]]]
  The expression in the clause
may also be @code{\not_specified}, which is equivalent to omitting the clause.
[[[ What is the type of the expression ? ]]]

@item @strong{Status:} Parsed and ignored.

@item @strong{Differences from JML or Java:} bugs...

@end itemize

@c ----------------------------------------------------------------------------
@node Redundancy,  , measuredby, Routine Annotation clauses
@subsection Redundancy
@itemize @bullet
@item @strong{Description:} Many clauses have a redundant form, indicated by 
using a keyword with a @strong{_redundantly} suffix.  The intention of
these clauses is to indicate specifications that are implied by other,
nonredundant, specifications.  The writer may choose to include the
redundant specifications in order to point out some non-obvious
implications of other specifications, either to facilitate
understanding by the reader or to assist the prover in verifying
conclusions.

Note that the @code{implies_that} and @code{for_example} specifications are
additional forms of redundancy.

@item @strong{Status:} Currently in ESC/Java2 a command-line option selects 
between using redundant specifications (those with keywords ending in
@code{_redundantly}) in the same way as nonredundant specifications
(the default) or ignoring them (when the option @code{-noredundancy}
is chosen).

@end itemize

@c ------ Annotation modifiers for a method or constructor --------
@node Routine modifiers, Field Annotations, Routine Annotation clauses, Status
@c  node-name,  next,  previous,  up
@section Annotation modifiers for a method or constructor

Annotation modifiers can appear between the last specification clause
or javadoc comment and the type designator or class name that is part
of the method or constructor.  JML modifiers and Java modifiers may
appear in any order.  Though less common and not the usual style (and
discouraged), ESC/Java2 (following ESC/Java) allows JML modifiers to
appear after the method declaration and before the opening left brace
of the body or the terminating semicolon if there is no body.

Besides the modifiers listed here, methods and constructors may also have the
access modifiers described in @ref{Access modifiers}.

@menu
* pure-routine::                
* nonnull-routine::             
* nullable-routine::            
* helper (JML)::                
* final::                       
* static-routine::              
* synchronized-routine::        
* native-routine::              
* strictfp-routine::            
@end menu

@c ---------------------------------------------------------------------------
@node pure-routine, nonnull-routine, Routine modifiers, Routine modifiers
@subsection pure (JML)
@itemize @bullet
@item @strong{Description:} The @code{pure} modifier applied to a
method indicates that the method does not assign to any non-local
memory location during its execution; it may not even modify and then
restore the original value.  It is equivalent to having @code{modifies
\nothing;} in the specification.  In the case of a constructor, the
only fields that may be modified are, at most, the fields of the
object itself, which are initialized as a result of the action of the
constructor.  In this case the @code{pure} modifier is equivalent to
specifications of the form 
@*@center @code{modifies this.*;}
@*However, a constructor may have modifies clauses that are more
restrictive than @code{modifies this.*;}.  Note that if a method is
declared pure, then all overriding methods are also pure, whether or
not they have an explicit declaration to that effect.  Note that a
pure constructor may not modify static fields. 

It is also worth mentioning that it is possible to call non-pure methods
from within the pure ones provided that the changed state is locally
allocated in the pure method.

@item @strong{Status:} Fully supported. 

@item @strong{Differences from JML or Java:} None.

@end itemize

@c ---------------------------------------------------------------------------
@node nonnull-routine, nullable-routine, pure-routine, Routine modifiers
@subsection non_null (JML - methods only)
@itemize @bullet
@item @strong{Description:} Modifying a routine with the 
@code{non_null} modifier is valid only for methods that return objects
as return values (and not for constructors).  The modifier specifies
that the return value is never null.  It is equivalent to a
specification of 
@*@center @code{ensures \result != null; }
@*added
to each specification case of the method's specification in all of the
files of the refinement sequence (but not of a superclass's
specification of that method).

Note that superclass and subclass declarations of a method each
independently may have or not have @code{non_null} declarations.  A
method's implementation must satisfy the superclass specification and
independently satisfy the subclass specification.  There is a more
thorough discussion in @ref{Inheritance and non_null}.

@item @strong{Status:} Parsed, typechecked and supported by the static checker.

@item @strong{Differences from JML or Java:} None.
@end itemize

@c ---------------------------------------------------------------------------
@c @author kiniry
@node nullable-routine, helper (JML), nonnull-routine, Routine modifiers
@subsection nullable (JML - methods only)
@itemize @bullet
@item @strong{Description:} Modifying a routine with the 
@code{nullable} modifier is valid only for methods that return objects
as return values (and not for constructors).  The modifier specifies
that the return value may be null.  

Note that this modifier is @emph{not} the opposite of @code{non_null}
since the negation of the equivalent specification would be
@*@center @code{ensures !(\result != null); }
@*which is equivalent to
@*@center @code{ensures \result == null; }
@*which is not the intent of @code{nullable}.

Note that superclass and subclass declarations of a method each
independently may have or not have @code{nullable} (and @code{non_null})
declarations.  A method's implementation must satisfy the superclass
specification and independently satisfy the subclass specification.
There is a more thorough discussion in @ref{Inheritance and non-null}.

In short, a @code{nullable} method may be overridden by a
@code{non_null} method but must then be @code{non_null} thereafter.

@item @strong{Status:} The modifier is parsed.  Typechecking implementation
      is underway.  This modifier is not yet used by the static checker.

@item @strong{Differences from JML or Java:} None.
@end itemize

@c ---------------------------------------------------------------------------
@node helper (JML), final, nullable-routine, Routine modifiers
@subsection helper (JML)
@itemize @bullet
@item @strong{Description:} This modifier indicates that the 
method or constructor in question is used as an internal helper routine
and that the method or constructor is therefore not expected to satisfy
any of the class-level invariants or constraints, in either its
pre-state or its post-state.  The method or constructor is still
expected to satisfy any specifications (e.g. ensures clauses) that are
explicitly associated with this method or constructor.

@item @strong{Status:} Parsed, typechecked and supported by the static checker.

@item @strong{Differences from JML or Java:} JML only allows private 
methods and constructors to be helpers.  ESC/Java2 also allows any
constructors, final methods or methods of final classes to be helpers.
(ESC/Java2's rule is that only routines that cannot be overridden may
be helpers.)

[[[ It seems constructors and methods labeled helper are not checked
at all, and are inlined when used elsewhere.  Rather they should be
checked against their own pre and post conditions but not against
invariants, constraints, initially clauses. ]]]

[[[ Comment on inlining and resulting differences in checking. ]]]

@end itemize

@c ---------------------------------------------------------------------------
@cindex final-routine
@node final, static-routine, helper (JML), Routine modifiers
@subsection final (Java - methods only)
@itemize @bullet
@item @strong{Description:} This Java modifier indicates that a 
method may not be overridden.  It may also be applied to model
methods.

@item @strong{Status:} Fully implemented.  This feature does not affect the
static checking; it simply produces a typechecking error if a final method is
overridden.

@item @strong{Differences from JML or Java:} None.
@end itemize

@c ---------------------------------------------------------------------------
@cindex static
@node static-routine, synchronized-routine, final, Routine modifiers
@subsection static (Java - methods only)
@itemize @bullet
@item @strong{Description:} @code{static} is a Java modifier 
(which may be used on JML annotations as well) that indicates that the
declaration in question is a member only of the class and not of each
instance of the class.

@item @strong{Status:} Fully implemented.

@item @strong{Differences from JML or Java:} None.

@end itemize

@c ---------------------------------------------------------------------------
@cindex synchronized
@node synchronized-routine, native-routine, static-routine, Routine modifiers
@subsection synchronized (Java - methods only)
@itemize @bullet
@item @strong{Description:} This modifier indicates that processing must wait
until a monitor lock is available and must obtain that lock before the 
execution of the method is begun; the lock is released when the method 
execution is completed.  Each object has, implicitly, a monitor lock associated
with the object.  Before executing an instance method, it is the lock
associated with receiver object that is obtained; before executing a static
method, it is the lock associated with the class object (T.class for type T)
that is obtained.
[[[ Are the preconditions/postconditions evaluated before or after 
obtaining and releasing the locks. ]]]

@item @strong{Status:} Implemented.

@item @strong{Differences from JML or Java:} None.

@end itemize

@c ---------------------------------------------------------------------------
@cindex native
@node native-routine, strictfp-routine, synchronized-routine, Routine modifiers
@subsection native (Java - methods only)
@itemize @bullet
@item @strong{Description:} A native method is one whose implementation is 
provided outside of the Java language.  Consequently such a method
will not have an implementation.

@item @strong{Status:} Fully implemented.  The static checker 
will indicate that the method passes its checks since there is no body
to check.

@item @strong{Differences from JML or Java:} None.
@end itemize

@c ---------------------------------------------------------------------------
@cindex strictfp
@node strictfp-routine,  , native-routine, Routine modifiers
@subsection strictfp (Java - methods only)
@itemize @bullet
@item @strong{Description:} This modifier indicates that all of the floating
point operations within the method must hold to strict semantics.

@item @strong{Status:} Parsed and ignored by ESC/Java2.  No static checking of
floating point semantics is performed.  Note that the Java Language
Specification stipulates that constructors may be @code{strictfp} only
by virtue of the entire class being declared @code{strictfp}.

@item @strong{Differences from JML or Java:} None.
@end itemize

@c ------ Annotation assertions for a field declaration --------
@node Field Annotations, Field Annotation modifiers, Routine modifiers, Status
@c  node-name,  next,  previous,  up
@section Annotation assertions for a field declaration

A field declaration (including ghost and model field declarations) may
be @b{followed} by field assertions, which are introduced by the
@code{in} and @code{maps} keywords.  These declarations associate a
field or its sub-fields with specific datagroups, which can then be
used as items in a modifies clause.

[[[ Which fields may have datagroups associated with them???]]]
 
@menu
* in (JML)::                    
* maps::                        
@end menu

@c ---------------------------------------------------------------------------
@node in (JML), maps, Field Annotations, Field Annotations
@subsection in (JML)
@itemize @bullet
@item @strong{Description:} This assertion follows a field 
declaration and lists the datagroups of which the field is a part.  A
field is automatically a part of the datagroup with the same name as
itself.

@item @strong{Status:} Implemented.

@item @strong{Differences from JML or Java:} None.
@end itemize

@c ---------------------------------------------------------------------------
@node maps,  , in (JML), Field Annotations
@subsection maps, \into (JML)
@itemize @bullet
@item @strong{Description:} [[[ Comment needed. ]]]

@item @strong{Status:} Parsed, typechecked and static checked using a 
limited unrolling of any recursive definitions.

@item @strong{Differences from JML or Java:} [[[ Comment needed. ]]]

[[[ Comment on the unrolling of recursive mappings. ]]]
[[[ Potential performance improvement: unroll datagroups, wildcard refs 
only when needed. Perhaps have to do this to verify superclasses.  ]]]
[[[ Comment on non-support for wild-cards and array ranges in the middle of
spec-ref expressions.]]]

@end itemize


@c ------ Annotation modifiers for a field declaration --------
@node Field Annotation modifiers, formal parameter modifiers, Field Annotations, Status
@c  node-name,  next,  previous,  up
@section Annotation modifiers for a field declaration

A field declaration (including ghost and model field declarations) may
have both Java and JML modifiers.  In addition to the access modifiers
(@pxref{Access modifiers}), the following modifiers are relevant to
field declarations.

@menu
* nonnull (JML)::               
* nullable (JML)::              
* monitored (JML)::             
* final-field::                 
* volatile::                    
* transient::                   
* static-field::                
* instance (JML)::              
@end menu

@c ---------------------------------------------------------------------------
@node nonnull (JML), nullable (JML), Field Annotation modifiers, Field Annotation modifiers
@subsection non_null (JML)
@itemize @bullet
@item @strong{Description:} This modifier on a field declaration 
indicates that the field in question never has a null value, after the
object is constructed.  It is equivalent to a class invariant of the
form 
@*@center @code{invariant @emph{field} != null;}
@*with the same
access modifiers as the field itself.

Note that the field is not null after @emph{construction}. The field may
indeed be null after class initialization and during the execution of
constructors or helper methods called by constructors.

@item @strong{Status:} Fully implemented and supported by the static checker.

@item @strong{Differences from JML or Java:} None.
@end itemize

@c ---------------------------------------------------------------------------
@c @author kiniry
@node nullable (JML), monitored (JML), nonnull (JML), Field Annotation modifiers
@subsection nullable (JML)
@itemize @bullet
@item @strong{Description:} This modifier on a field declaration 
indicates that the field in question may have a null value.  It is
equivalent to a class invariant of the
@*@center @code{invariant @emph{field} != null || @emph{field} == null;}
@*with the same access modifiers as the field itself which, since this
specification simplifies to @code{true} because all references in Java
either have @code{null} value or they do not, is not added at all.

@item @strong{Status:} The modifier is parsed.  Typechecking implementation
      is underway.  This modifier is not yet used by the static checker.

@item @strong{Differences from JML or Java:} None.
@end itemize

@c ---------------------------------------------------------------------------
@node monitored (JML), final-field, nullable (JML), Field Annotation modifiers
@subsection monitored (JML)
@itemize @bullet
@item @strong{Description:} This modifier indicates that the field modified
is guarded by the monitor associated with @code{this} if the field is not
static and by the monitor associated with the class object if the
field is static.  On any write to the field, all monitors guarding the
field must be held by the thread executing the write; on any read of
the field, at least one of the monitors guarding the field must be
held by the thread executing the read.

Modifying a field @code{x} in class @code{C}
with @code{monitored} is equivalent to the
declaration
@*@center @code{ monitored_by x = C.class; }
@*if @code{x} is static, or to
@*@center @code{ monitored_by x = this; }
@*if @code{x} is not static.

@item @strong{Status:} Implemented.  The implementation improves on that in
ESC/Java by implementing monitors for static fields and by making the 
error messages more informative and accurate.

@item @strong{Differences from JML or Java:} None. 
[[[ Check - does JML and jmlrac support static monitors?]]]

@end itemize

@c ---------------------------------------------------------------------------
@node final-field, volatile, monitored (JML), Field Annotation modifiers
@subsection final (Java)
@itemize @bullet
@item @strong{Description:} This Java modifier indicates that the field it
modifies may not be assigned to, after it has been initialized (either
by an initializer or in a constructor).  Java has some complex rules
about definite-assignment that are relevant but not discussed here.

@item @strong{Status:} It is supported by the ESC/Java2 
parser and type checker.  It does not have any effect on the static
checking. [[[ There are checks only that variables with initializers
are not subsequently assigned to.  Is definite-assignment checked???
]]]

@item @strong{Differences from JML or Java:} None.
@end itemize

@c ---------------------------------------------------------------------------
@node volatile, transient, final-field, Field Annotation modifiers
@subsection volatile (Java)
@itemize @bullet
@item @strong{Description:} This Java modifier affects the optimizations that 
might be applied and the semantics of the order of writing the values
of object fields to memory.  It affects multi-threaded programs only.
It is not applicable to a ghost or model declaration.

@item @strong{Status:} Parsed but ignored by the static checker.

@item @strong{Differences from JML or Java:} None.

@end itemize

@c ---------------------------------------------------------------------------
@node transient, static-field, volatile, Field Annotation modifiers
@subsection transient (Java)
@itemize @bullet
@item @strong{Description:} Fields designated @code{transient} are 
not saved as part of an object's persistent state.  This is not
applicable to a ghost or model declaration.

@item @strong{Status:} Parsed but ignored by the static checker.  
Any implications of this modifier would be part of the specifications
of serialization for the object.

@item @strong{Differences from JML or Java:} None.
@end itemize

@c ---------------------------------------------------------------------------
@node static-field, instance (JML), transient, Field Annotation modifiers
@subsection static (Java)
@itemize @bullet
@item @strong{Description:} @code{static} is a Java modifier 
(which may be used on JML ghost and model field declarations as well)
that indicates that the declaration in question is a member of the
class and not of each instance of the class.

@item @strong{Status:} Fully implemented.

@item @strong{Differences from JML or Java:} None.

@end itemize

@c ---------------------------------------------------------------------------
@node instance (JML),  , static-field, Field Annotation modifiers
@subsection instance (JML)
@itemize @bullet
@item @strong{Description:} @code{instance} is a JML modifier 
that indicates the opposite of @code{static}, that is, that the field
in question is a member of each instance of the object, not just of
the class.  Within a class declaration, field declarations are
non-static by default (and @code{instance} is not needed).  However,
within an interface, Java field declarations are @code{static} and
@code{final} by default.  Ghost and model field declarations are
@code{static} by default (but not @code{final}).  The @code{instance}
modifier may be applied to ghost or model field declarations in an
interface, making those fields non-static.  (JML allows the modifier
@code{instance} only on ghost and model field declarations, in either
classes or interfaces.)  As in Java, ghost and model declarations in a
public interface are implicitly public.

@item @strong{Status:} Implemented.

@item @strong{Differences from JML or Java:} 
[[[ Check that ill-formed JML uses are checked and forbidden by ESC/Java2]]]

@end itemize

@c ---------------------------------------------------------------------------
@node formal parameter modifiers, Annotation statements, Field Annotation modifiers, Status
@section Annotation modifiers for formal parameters

These modifiers may precede the type name of a formal parameter within
the declaration of the method or constructor.

@menu
* nonnull-formal::              
* nullable-formal::             
* final-formal::                
@end menu

@c ---------------------------------------------------------------------------
@node nonnull-formal, nullable-formal, formal parameter modifiers, formal parameter modifiers
@subsection non_null (JML)
@itemize @bullet
@item @strong{Description:} Modifying a formal parameter 
with a @code{non_null} modifier is equivalent to adding a precondition
stating that the parameter is not equal to @code{null} and requiring
that any assignment to that variable assign a non-null value.  It is
only legal for reference types, not for primitive types.  The
@code{non_null} condition is in addition to the composite specification
formed from the complete refinement sequence.  Hence it is equivalent to
adding a precondition requiring the parameter be @code{non_null} to the
desugared specification of the routine (as well as the conditions on
subsequent assignments within the body of the routine).

Note that parameters of superclass and subclass declarations of a
method each independently may have or not have @code{non_null}
declarations.  A method's implementation must satisfy the superclass
specification and independently satisfy the subclass specification.  A
more thorough discussion is given in @ref{Inheritance and non_null}.

@item @strong{Status:} The modifier is parsed, checked and supported by the
static checker.

@item @strong{Differences from JML or Java:} None known. 
      [[[FIXME - does JML detect problems with overriding methods?]]].  

@item @strong{Comment:} The original ESC/Java did not permit a 
subclass to modify a formal parameter as @code{non_null} in an
overriding declaration.  The declarations of the top-most declaration
were used for all overriding declarations.
@end itemize

@c ---------------------------------------------------------------------------
@c @author kiniry
@node nullable-formal, final-formal, nonnull-formal, formal parameter modifiers
@subsection nullable (JML)
@itemize @bullet
@item @strong{Description:} Modifying a formal parameter 
with a @code{nullable} modifier does not modify a method specification
in any way.  It is only legal for reference types, not for primitive
types.

Note that parameters of superclass and subclass declarations of a
method each independently may have or not have @code{nullable}
declarations.  A method's implementation must satisfy the superclass
specification and independently satisfy the subclass specification.  A
more thorough discussion is given in @ref{Inheritance and non_null}.

@item @strong{Status:} The modifier is parsed.  Typechecking implementation
      is underway.  This modifier is not yet used by the static checker.

@item @strong{Differences from JML or Java:} None known. 
      [[[FIXME - does JML detect problems with overriding methods?]]].

@item @strong{Comment:} The original ESC/Java did not support this 
annotation at all, as it did not exist in JML until late 2005.
@end itemize

@c ---------------------------------------------------------------------------
@node final-formal,  , nullable-formal, formal parameter modifiers
@subsection final (Java)
@itemize @bullet
@item @strong{Description:} This Java modifier indicates that a 
formal parameter may not be the target of an assignment in the body of
the routine.

@item @strong{Status:} Fully implemented.  This feature does not affect the
static checking; it simply produces a typechecking error if a final
parameter is the target of an assignment.

@item @strong{Differences from JML or Java:} None.
@end itemize

@c ---------------------------------------------------------------------------
@node Annotation statements, Local Modifiers, formal parameter modifiers, Status
@section Annotation statements within the body of a method or constructor
These annotation statements may be intermixed with the statements within the
body of a method or constructor.  They may also be used within model programs.

@menu
* assume::                      
* assert::                      
* set::                         
* unreachable::                 
* henceby::                     
* loopinvariant::               
* decreases::                   
* ghost declarations::          
@end menu

@c ---------------------------------------------------------------------------
@node assume, assert, Annotation statements, Annotation statements
@subsection assume, assume_redundantly
@itemize @bullet
@item @strong{Description:} This annotation statement (inherited from the
original ESC/Java) states a predicate which is then assumed by the static
checker.  It is typically used to state a predicate at some point in the body
of a routine that the static checker is unable to establish.  Checking of the
remainder of the body can then proceed with this assumption.
@item @strong{Status:} Implemented.
@item @strong{Differences from JML or Java:} None.
@end itemize

@c ---------------------------------------------------------------------------
@node assert, set, assume, Annotation statements
@subsection assert, assert_redundantly
@itemize @bullet
@item @strong{Description:} This statement will generate a static 
checker warning if a program execution can be found in which the
associated predicate is false.  Note that this is different than the
Java assert statement, both in syntax and in semantics.  The
command-line options @code{-jmlAssertions} will cause Java assertions
to behave like JML assertions (@pxref{Java and JML assert
statements}).

@item @strong{Status:} Fully implemented.

@item @strong{Differences from JML or Java:} None.
@end itemize

@c ------------------------------ set ----------------------------------------
@menu
* set::                         
@end menu

@node set, unreachable, assert, Annotation statements
@c  node-name,  next,  previous,  up
@subsection set
@itemize @bullet
@item @strong{Description:} The JML set statement is used as 
a statement within the body of a routine to assign a value to a ghost
field or variable.  ESC/Java allowed only fields to be set.  ESC/Java2
allows in addition the declaration of local ghost variables and the
assignment of values to them using set statements.  Only assignments
(with =) are allowed and the right-hand-sides of the assignment
statements must be pure expressions.

@item @strong{Status:} Implemented.

@item @strong{Differences from JML or Java:} None.

[[[ What about using set statements containing statements other than assignments, such as x++; chekc on the purity requirement in JML ]]]
@end itemize

@c ---------------------------------------------------------------------------
@node unreachable, henceby, set, Annotation statements
@subsection unreachable
@itemize @bullet
@item @strong{Description:} This is a statement that asserts that the 
command-flow of the program will never reach this point.  If the
static checker suspects that there is a program execution that can do
so, it will issue a warning.  It is equivalent to an annotation
stating @code{assert false}.  There is no conditional unreachable
statement but the equivalent can be created using an assert statement.

@item @strong{Status:} Implemented.

@item @strong{Differences from JML or Java:} There is no unreachable annotation
in JML.
@end itemize

@c ---------------------------------------------------------------------------
@node henceby, loopinvariant, unreachable, Annotation statements
@subsection hence_by, hence_by_redundantly
@itemize @bullet
@item @strong{Description:} [[[ Comment needed - semantics unknown. ]]] This
keyword is followed by a predicate.
@item @strong{Status:} Parsed and type-checked.  Ignored by the static checker.
@item @strong{Differences from JML or Java:} None.
@end itemize

@c ---------------------------------------------------------------------------
@node loopinvariant, decreases, henceby, Annotation statements
@subsection loop_invariant, loop_invariant_redundantly, @*maintaining, maintaining_redundantly
@itemize @bullet
@item @strong{Description:} A @code{loop_invariant} pragma is followed by a 
predicate.  The pragma must appear immediately prior to a loop statement
(for, while, do, or Java labeled statement).  The predicate must hold at the
start of each loop iteration.  Details are given in the ESC/Java User's Manual.
Note that loops are checked only by unrolling them a few iterations.  The
number of iterations can be set by the @code{-loop} command-line option.
@item @strong{Status:} Implemented.
@item @strong{Differences from JML or Java:} None.
@end itemize

@c ---------------------------------------------------------------------------
@node decreases, ghost declarations, loopinvariant, Annotation statements
@subsection decreases, decreasing, decreases_redundantly, @*decreasing_redundantly
@itemize @bullet
@item @strong{Description:} This pragma specifies a quantity (type @code{int})
which must decrease but must always be non-negative at the start of
any loop iteration.  Note that loops are checked only by unrolling
them a few iterations.  The number of iterations can be set by the
@code{-loop} command-line option.
@item @strong{Status:} Implemented.
@item @strong{Differences from JML or Java:} None.
@end itemize

@c ---------------------------------------------------------------------------
@node ghost declarations,  , decreases, Annotation statements
@subsection ghost declarations
@itemize @bullet
@item @strong{Description:} JML and ESC/Java2 (but not ESC/Java) allow the 
declaration of local ghost variables within the body of a routine, just
as Java allows local declarations.  These can then be used in subsequent
annotation statements within the body, such as assert, assume, or set
statements.  Such declarations may also be declared @code{final},
@code{non_null}, or @code{nullable} and may have initializers.

@item @strong{Status:} Implemented.  
@item @strong{Differences from JML or Java:} None.
@end itemize

@c ---------------------------------------------------------------------------
@node Local Modifiers, JML functions (extensions to expressions), Annotation statements, Status
@section Modifiers that may be applied to local declarations

Declarations within the body of a method, constructor or
initialization code introduce local variables used only during the
execution of that body of code.  Privacy modifiers, @code{static}, and
@code{instance} are not applicable to these declarations.  JML defines
local ghost declarations as well (but not local model declarations).
The following modifiers are allowed.

@menu
* nonnull on local decls::      
* uninitialized-local::         
* final-local::                 
@end menu

@c ---------------------------------------------------------------------------
@node nonnull on local decls, nonnull on local decls, Local Modifiers, Local Modifiers
@subsection non_null (JML)

@itemize @bullet
@item @strong{Description:} A local declaration
of a variable of reference type within the body of a method or
constructor (including local ghost declarations) may be modified with
the JML annotation @strong{non_null}.  This requires that the initial
value and any subsequently assigned value for that variable must not
be null.  [[[ must have an initializer ???]]]

@item @strong{Status:} Fully implemented (in ESC/Java and ESC/Java2).
[[[ Failure to initialize is not detected. Or failure to initialize with null value.  Also ghost declarations. ]]]

@item @strong{Differences from JML or Java:} None.

@end itemize

@c ---------------------------------------------------------------------------
@node nonnull on local decls, uninitialized-local, nonnull on local decls, Local Modifiers
@subsection nullable (JML)

@itemize @bullet
@item @strong{Description:} A local declaration
of a variable of reference type within the body of a method or
constructor (including local ghost declarations) may be modified with
the JML annotation @code{nullable}.  This places no requirements on the
initial value and any subsequently assigned value for that variable.

@item @strong{Status:} The modifier is parsed.  Typechecking implementation
      is underway.  This modifier is not yet used by the static checker.

@item @strong{Differences from JML or Java:} None.

@end itemize

@c ---------------------------------------------------------------------------
@node uninitialized-local, final-local, nonnull on local decls, Local Modifiers
@subsection uninitialized (JML)
@itemize @bullet
@item @strong{Description:} This JML modifier may be applied to a 
local variable declaration within the body of a block of code.  It
indicates that although the variable has been initialized with an
initial value, it should be considered as uninitialized.  That is, a
warning will be issued if its value is used before having been
assigned a new value.

@item @strong{Status:} Implemented (as in ESC/Java).

@item @strong{Differences from JML or Java:} This modifier is not part of JML.
@end itemize


@c ---------------------------------------------------------------------------
@node final-local,  , uninitialized-local, Local Modifiers
@subsection final (Java)
@itemize @bullet
@item @strong{Description:} This Java modifier has the usual meaning that the
variable may not be altered (or even reassigned its same value) after
it has been declared and initialized.

@item @strong{Status:} Implemented.  

@item @strong{Differences from JML or Java:} ESC/Java2 does not detect 
invalid assignments to final variables that are not initialized in the
declaration.

@end itemize

@c ---------------------------------------------------------------------------
@node JML functions (extensions to expressions), store-ref expressions, Local Modifiers, Status
@section JML functions (extensions to expressions)

JML defines a number of new operators, functions, and other
constructions for use within expressions that are part of annotations.

@menu
* New operators in JML::        
* New JML expressions (functions and values)::  
* New JML types::               
* quantified expressions::      
* set comprehension::           
* notspecified::                
* privatedata::                 
* other ::                      
* Other Java operators and expression syntax::  
@end menu

@c ---------------------------------------------------------------------------
@node New operators in JML, New JML expressions (functions and values), JML functions (extensions to expressions), JML functions (extensions to expressions)
@subsection New operators in JML

JML adds to Java the operators described below.  The @code{==>} and
@code{<==} operators have the same precedence and they bind less tightly
than the Java logical or expression.  That is the expression @code{( p
|| q ==> r || s)} is equivalent to @code{( (p || q) ==> (r || s) )} .
The @code{<==>} and @code{<=!=>} operators have the same precedence
and bind less tightly than @code{==>} and @code{<==}. That is, the
expression @code{( p ==> q <==> r <== s)} is equivalent to
@code{((p==>q) <==> (r<==s))}.  The equivalence and inequivalence
operators bind more tightly than the conditional (@code{?:}) operator.

The subtype operator (@code{<:}) has lower precedence than the shift operator
@code{<<}, the same precedence as the comparison operators @code{<}, @code{>},
@code{<=}, and @code{>=}, and has higher precendence than the equality 
(@code{==}) and inequality (@code{!=}) operators.

@itemize @bullet

@cindex @code{<==>}
@item @code{<==>} : 
This operator (equivalence) takes two boolean arguments; it returns a
boolean value of @code{true} if the two arguments are both @code{true}
or both @code{false}, and @code{false} otherwise.  

@*@strong{Status:} Implemented.

@cindex @code{<=!=>}
@item @code{<=!=>} : 
This operator (inequivalence) takes two boolean arguments; it returns
a boolean value of @code{false} if the two arguments are both
@code{true} or both @code{false}, and @code{true} otherwise.  
@code{(A <==> B)} is equivalent to @code{!(A <=!=> B)}.  

@*@strong{Status:} Implemented.

@cindex @code{==>}
@item @code{==>} : 
This operator (implies) takes two boolean arguments and returns a
boolean value of @code{true} if the first is @code{false} or the
second is @code{true}, and returns @code{false} if the first is
@code{true} and the second is @code{false}.

@*@strong{Status:} Implemented.

@cindex @code{<==}
@item @code{<==} : 
This operator (reverse implication, or explies) takes two boolean
arguments and returns a boolean value of @code{true} if the second is
@code{false} or the first is @code{true}, and returns @code{false} if
the second is @code{true} and the first is @code{false}.  
@code{(A ==> B)} is equivalent to @code{(B <== A)}.

@*@strong{Status:} Implemented.

@cindex @code{<:}
@item @code{<:} : 
This operator takes two arguments of type @code{\TYPE} (or, equivalently, of
type @code{java.lang.Class}); it returns @code{true}
if the left-hand argument is the same type as or a subtype of the right-hand
argument. 

@*@strong{Status:} Implemented.

@cindex @code{<}
@cindex @code{<=}
@item @code{<} , @code{<=} : 
In addition to their usual meaning in Java (and corresponding meanings
in JML), the less-than and less-than-or-equal operators are used to
compare locks.  Any object that is listed as a monitor (in a
@code{monitors_for} clause) or is identified implicitly or explicitly
in a Java synchronization statement is a lock, in addition to its
declared use as an object.  In order to reason about deadlocks, the
user must define a partial order on locks and have the code acquire
the locks only in increasing order.  The partial order may be defined
using @code{axiom} clauses; the operators are used to compare locks by
this partial order.  They take two locks as arguments and return
@code{true} if the left-hand object is less than (or less than or
equal to, respectively) the right-hand object according to the partial
order axioms, and returns @code{false} otherwise.  The comparison is
independent of whether the locks have actually been acquired; the
@code{\lockset} expression supplies that information.  The ESC/Java
User's Manual provides additional information and examples about
Deadlock and Race detection.  

@*@strong{Status:} Implemented.

@end itemize

@c ---------------------------------------------------------------------------
@node New JML expressions (functions and values), New JML types, New operators in JML, JML functions (extensions to expressions)
@subsection New JML expressions (functions and values)

@itemize @bullet

@cindex @code{\result}
@item @code{\result} : This keyword denotes the result of a method 
that returns a value.  It may be used in an @code{ensures} clause (but
not a @code{signals} clause).  [[[ What about duration, working_space
clauses ]]] 

@*@strong{Status:} Implemented.

@cindex @code{\old}
@item @code{\old} : This pseudo-function takes one argument 
of any type and returns the value of its argument.  It is used to
indicate that the expression which is its argument must be evaluated
in the pre-state.  It is used in ensures and signals clauses to
distinguish pre- and post-state values.  It may also be used within
annotations in the body of a routine (e.g. assert, assume, set
statements).

@*@strong{Status: } Implemented.  JML does not allow \old in set
statements or local ghost variable initialization.

@cindex @code{\not_modified}
@item @code{\not_modified} : This function of an arbitrary number of
arguments returns a boolean value indicating whether all of the
arguments are unchanged between pre-state and the current state.  It
may be used in an ensures or signals clause and in annotations in the
body of a routine.  It is equivalent to boolean AND of @code{x ==
\old(x)} for each argument.  

@*@strong{Status:} Implemented (not part of the original ESC/Java).

@*@strong{Differences:} ESC/Java2 allows arbitrary (pure) expressions as
the arguments of @code{\not_modified}; JML only allows store locations.
[[[ Check that ESC/Java2 and JML actually allow this in routine
bodies.]]]

@cindex @code{\fresh}
@item @code{\fresh} : This function takes a single argument of 
any reference type and returns a @code{boolean}.  The operator may be
used in an expression that is evaluated in the post-state.  The result
is true if its argument is non-null and was not allocated in the
pre-state.  

@*@strong{Status:} Implemented.  [[[ Checks needed that
this is allowed in set and initialization statements and works
correctly - both in ESC/Java and JML.]]]

@cindex @code{\reach}
@item @code{\reach} : [[[ description, status, differences needed here ]]] - deprecated

@cindex @code{\duration}
@item @code{\duration} : This function returns a @code{long} value 
giving a maximum number of virtual machine cycles needed to execute
the method or constructor call which is the argument.  The argument is
not executed (and so need not be a pure expression).

@*@strong{Status:} Parsed.  No type checking is performed on the
argument nor is any static checking performed.  [[[ Why not allow any
expression as the argument. ]]]

@cindex @code{\space}
@item @code{\space} : This function returns a @code{long} value 
giving the number of bytes of heap space allocated to the object
referred to by its argument.  The argument must have reference type.

@*@strong{Status:} Parsed.  No type checking is performed on the
argument nor is any static checking performed.

@cindex @code{\working_space}
@item @code{\working_space} : This function returns a @code{long} 
value giving the number of bytes of heap space needed to execute the
method or constructor call that is the argument.  The argument is not
executed (and so need not be a pure expression).

@*@strong{Status:} Parsed.  No type checking is performed on the
argument nor is any static checking performed.  [[[ Why not allow an
arbitrary expression ]]]

@cindex @code{\nonnullelements}
@item @code{\nonnullelements} : This function returns a boolean and 
takes an argument of a reference array type.  The result is true if
the argument is not null and no element of the array is null.

@*@strong{Status:} Implemented.

@cindex @code{\typeof}
@item @code{\typeof} : This function returns a value of type 
@code{\TYPE} and takes 
one argument of any type.  The result is the dynamic type of the 
argument.  The result of \typeof applied to a null expression is not equal to
nor a subtype of the type of any reference or primitive type.

@*@strong{Status:} Implemented.

@*@strong{Differences:} JML allows arguments of primitive types; ESC/Java2 does
also, but the original ESC/Java did not. 

@cindex @code{\elemtype}
@item @code{\elemtype} : This function takes an argument of type 
@code{\TYPE} and
returns a value of type @code{\TYPE}.  If the argument is an array type then
the result is the (dynamic) most-specific type of the elements of the array;
if the argument is not an array type, the result is unspecified.

@*@strong{Status:} Implemented.  [[[ The results of applying \elemtype
to any non-array type all test equal.  This should perhaps not be so. 
Check what the behavior actually is. Perhaps should define the result.  ]]]

@cindex @code{\type}
@item @code{\type} : This is a syntactic construct used to 
denote type literals.  
It denotes the type constant (of value @code{\TYPE}) corresponding to the
type name given as the argument.

@*@strong{Status:} Implemented. 

@*@strong{Differences:} None.

@cindex @code{\is_initialized}
@item @code{\is_initialized} : This construct takes a type 
name as its argument.
It returns true just in the case that the type named has completed its static 
initialization.

@*@strong{Status:} Parsed and partly typechecked.  No static checking is
implemented.

@cindex @code{\invariant_for}
@item @code{\invariant_for} : This function takes one object of reference-type 
as its argument and returns a boolean.  The result is true just when
the object satisfies its class invariants.

@*@strong{Status:} Parsed and partly typechecked.  No static checking is
implemented.

@cindex @code{\lblneg}
@cindex @code{\lblpos}
@item @code{\lblneg}, @code{\lblpos} : 
These syntactic constructs have the unusual form
@*@center @code{(\lblpos Identifier Expression)}
@*The enclosing parentheses are required; the middle item is an unquoted 
identifier that has no relationship to any other identifiers elsewhere in the
program.  The result of the expression is the value of the expression that is
within the expression; this expression must be a boolean expression.  The 
effect of the operation is as follows.  If the static checker would issue a
warning that some condition does not hold, and the relevant expression contains
a lblneg or a lblpos construct, and the expression within the construct 
evaluates to false (for lblneg) or true (for lblpos), then the identifier
in the construct is listed as a label encountered in the counterexample
context.  This may be useful to the user in identifying which portion of
an expression is causing some condition to hold or not to hold.

@cindex @code{\lockset}
@item @code{\lockset} : This value has type @code{\LockSet}.  
The value is the set of objects whose
locks are held by the current thread. 

@*@strong{Status:} This feature is fully implemented by ESC/Java2 
(as inherited from ESC/Java).

@cindex \lockset membership
@item membership in a \lockset : A @code{\lockset} contains objects.  
Membership in a @code{\lockset} is tested using this syntax, for some
object expression @code{o} : @code{\lockset[o]} .  This expression
returns a boolean, which is true if the object is in the lockset.

@*@strong{Status:} This feature is fully implemented by ESC/Java2 (as
inherited from ESC/Java). It is not part of JML, but should be.
[[[ There should be a way to get the lockset of a thread other than the
current thread. ]]]

@cindex @code{\max}
@item @code{\max} : This function takes an argument of type @code{\LockSet}.  
It returns an object of type @code{java.lang.Object}.  The result is one of the
elements of the argument; the function satisfies the following for any 
@code{\LockSet} @code{s} and Object @code{o}: @code{s[o] ==> (o <= \max(s))}.

@*@strong{Status:} This feature is fully implemented by ESC/Java2 
(as inherited from ESC/Java).

@item Operators for overflow checking : These are under development 
in JML and are not yet implemented in ESC/Java2.


@cindex informal predicate
@cindex (*
@cindex *)
@item @emph{informal predicate} : An informal predicate consists of text 
enclosed within the delimiters @code{(*} and @code{*)}.  Informal
predicates are interpreted as boolean expressions that are always true
(independent of what the text may say!), and they may only be used in
contexts where a boolean expression is allowed.  

@*@strong{Status:}
This feature is fully implemented in ESC/Java2 (as well as ESC/Java).

@end itemize

@c ---------------------------------------------------------------------------
@node New JML types, quantified expressions, New JML expressions (functions and values), JML functions (extensions to expressions)
@subsection New JML types

JML adds some new types that may be used as type names in declarations of
variables within annotations.

@itemize @bullet

@cindex @code{\TYPE}
@item @code{\TYPE} : This is a JML type name used to denote the 
type of type designations.  For example, @code{\typeof} and
@code{\type} produce results of type @code{\TYPE}, and the @code{<:}
operator takes arguments of type @code{\TYPE}.  Values of type
@code{\TYPE} can also be compared using the @code{==} or @code{!=}
operators.

@*@strong{Status:} This is fully implemented.  [[[ In JML \TYPE and
java.lang.Class are now equivalent.  This is not yet the case in
ESC/Java2. ]]]

@cindex @code{\bigint}
@item @code{\bigint} : This is a new type name used in JML to 
denote an integral type equivalent to the mathematical integers.  That
is, it has infinite range and no underflow or overflow as a result of
a fixed bit depth.

@*@strong{Status:} The type name is parsed but is equivalent to @code{long}.

@cindex @code{\real}
@item @code{\real} : This is a new type name used in JML to denote a type 
equivalent to the mathematical real numbers.  That is, it has infinite range 
and precision and no
underflow, overflow, or rounding error as do @code{float} and @code{double}.

@*@strong{Status:} The type name is parsed but is equivalent to @code{double}.

@cindex @code{\LockSet}
@item @code{\LockSet} : This type may not be named (there is no 
token @code{\LockSet}).  However the type is implicitly used as the
type of the JML token @code{\lockset}, as the type of the argument of
@code{\max}, and in the LockSet membership operation.

@end itemize

@cindex quantified expressions
@cindex @code{\forall}
@cindex @code{\exists}
@cindex @code{\num_of}
@cindex @code{\max}
@cindex @code{\min}
@cindex @code{\sum}
@cindex @code{\product}

@c ---------------------------------------------------------------------------
@node quantified expressions, set comprehension, New JML types, JML functions (extensions to expressions)
@subsection quantified expressions - \forall, \exists, \num_of, \max, \min, \sum, \product

As described in the JML documentation, quantified expressions take the form
@*@center @code{( @emph{quantifier-keyword} @emph{type} @emph{idlist} ; @emph{range-expr} ; @emph{expr} )}
@*or
@*@center @code{( @emph{quantifier-keyword} @emph{type} @emph{idlist} ; ; @emph{expr} )}
@*or
@*@center @code{( @emph{quantifier-keyword} @emph{type} @emph{idlist} ; @emph{expr} )}
@*The @emph{range-expr} is a boolean expression; its default value is @code{true}.
The @emph{idlist} is a comma-separated list of identifiers; these are
the bound variables of the quantification.  No side-effects are
permitted in the predicate or expression.

@*@strong{Status:} 
@itemize @bullet
@item @code{\forall}, @code{\exists}: Fully implemented and 
used in static checking.
@item @code{\num_of}, @code{\max}, @code{\min}, @code{\sum}, @code{\product}:
 Parsed and typechecked but not used in static checking. 
@end itemize
@noindent
@strong{Comment:} The keyword @code{\max} is used both as a quantifier and as
a function.  The parser is able to distinguish the two usages.

@c ---------------------------------------------------------------------------
@cindex set comprehension
@node set comprehension, notspecified, quantified expressions, JML functions (extensions to expressions)
@subsection Set comprehension

JML has a syntax for expressions whose value is a set.  An example is
@*@center @code{new JMLObjectSet @{ Integer i | o.has(i) && i.intValue() > 0 @}}

@noindent
No side-effects are permitted in the predicate.

@*@strong{Status: }ESC/Java2 parses and typechecks set comprehension
expressions, with the following omissions:
@itemize @bullet
@item Set comprehension in class-level specifications is not handled.
@item Expressions containing set comprehension are not used in static checking
@item No restrictions on the type of the set are imposed
@item The JML restrictions on the form of the predicate are not checked
@item ESC/Java2 should check and forbid Java or JML modifiers in the bound variable declaration
@end itemize

@c ---------------------------------------------------------------------------
@node notspecified, privatedata, set comprehension, JML functions (extensions to expressions)
@subsection \not_specified
This may be used, within the guidelines of the JML grammar, as the
predicate or store-ref expression in an annotation clause.  JML allows
tools to provide their own behavior for @code{\not_specified}.
Escjava2 treats such clauses as if they were not present, making them
equivalent to the default for that clause type.

@*@strong{Status: } Fully implemented.

@c ---------------------------------------------------------------------------
@node privatedata, other , notspecified, JML functions (extensions to expressions)
@subsection \private_data
[[[ description, status, differences needed here ]]]

@c ---------------------------------------------------------------------------
@node other , Other Java operators and expression syntax, privatedata, JML functions (extensions to expressions)
@subsection \other 
[[[ description, status, differences needed here ]]]

@c ---------------------------------------------------------------------------
@node Other Java operators and expression syntax,  , other , JML functions (extensions to expressions)
@subsection Other Java operators and expression syntax
Java operators and expression syntax are all completely parsed and are
typechecked with varying degrees of rigor.  Most features are interpreted and
can be reasoned about by the static checker.  Some that are only partially
handled by the static checker are these:
@itemize @bullet
@item new instance expressions - These are completely handled in program code.
In specification expressions, these are interpreted according to their
specifications by a procedure that inlines the specifications, but only
to a limited depth of rewriting. [[[ Check this ??? ]]]
@item new array expressions - These are handled adequately in both program
code and in annotations, except for reasoning about the values of array
elements when initializers are provided.
@item .class expression [[[ ?? ]]]
@item anonymous classes
@end itemize
[[[ CLarify the above. ]]]

@c ---------------------------------------------------------------------------
@node store-ref expressions, Statements within model programs, JML functions (extensions to expressions), Status
@section store-ref expressions

[[[ This whole section needs thorough correction and review ]]]

Some annotations require a list of @emph{store-ref expressions}, which are 
expressions whose value is a set of references to fields of classes or objects;
in particular, the value has type @code{org.jmlspecs.models.JMLObjectSet}.
For example, the @code{modifies} clause designates a set 
(that is, a @code{JMLObjectSet} of @emph{store-refs} that
are allowed to be assigned to within a method.  This section describes the 
syntactic features that designate such sets.  [[[ Not sure this is right in the
wake of data groups and in/maps clauses ]]]



@menu
* field store-refs::            
* wild-card field store-refs::  
* array element store-refs::    
* array range store-refs::      
* all array elements store-refs::  
* static wild-card store-refs::  
* nothing ::                    
* everything ::                 
@end menu

@c ---------------------------------------------------------------------------
@node field store-refs, wild-card field store-refs, store-ref expressions, store-ref expressions
@subsection [ @emph{ident} | @code{super} | @code{this} ] @code{.} [ @emph{ident} | @code{this} ]
This designates a field of an object.  [[[ Describe the function of the this suffix]]]

@*@strong{Status: } Implemented within modifies clauses.

@node wild-card field store-refs, array element store-refs, field store-refs, store-ref expressions
@subsection [ @emph{ident} | @code{super} | @code{this} ] @code{.*}  
This designates all static and instance fields, of any privacy level, including
those inherited from superclasses and interfaces, of the given object.

@*@strong{Status: } Not implemented.

@node array element store-refs, array range store-refs, wild-card field store-refs, store-ref expressions
@subsection [ @emph{ident} | @code{super} | @code{this} ] @code{[@emph{expr}]}  
This designates an element of the given array object.   [[[ Describe the function of the this and super prefix ]]]

@*@strong{Status: } Implemented within modifies clauses.


@node array range store-refs, all array elements store-refs, array element store-refs, store-ref expressions
@subsection [ @emph{ident} | @code{super} | @code{this} ] @code{[@emph{expr}..@emph{expr2}]}  
This designates a range of elements of the given array object.

@*@strong{Status: } Not implemented.

@node all array elements store-refs, static wild-card store-refs, array range store-refs, store-ref expressions
@subsection [ @emph{ident} | @code{super} | @code{this} ] @code{[*]}  
This designates all the elements of the given array object.

@*@strong{Status:} Not implemented.

@c ---------------------------------------------------------------------------
@node static wild-card store-refs, nothing , all array elements store-refs, store-ref expressions
@subsection @emph{classname}.* 
This designates all static fields, of any privacy level, including
those in superclasses and interfaces, and including ghost and model fields,
of the given class.

@*@strong{Status:} Not implemented.

@c ---------------------------------------------------------------------------
@cindex \nothing
@node nothing , everything , static wild-card store-refs, store-ref expressions
@subsection \nothing 
This designates an empty set of store-refs.  It may be used with the 
@code{modifies}, @code{accessible}, and @code{callable} clauses.
If @code{\nothing} appears in a sequence of other store-refs, it is ignored,
since a sequence of store-refs is essentially a union.

@*@strong{Status:} Fully implemented.

@c ---------------------------------------------------------------------------
@cindex \everything
@node everything ,  , nothing , store-ref expressions
@subsection \everything 
This designates a universal set - the set of references to all object
and class fields for every object and class allocated in the current
state of the program.  It may be used with the @code{modifies},
@code{accessible}, and @code{callable} clauses.  

@*@strong{Status:}
Fully parsed - refer to the clause descriptions for specific behavior.

@c ---------------------------------------------------------------------------
@cindex model program statements
@node Statements within model programs, Other issues, store-ref expressions, Status
@section Statements within model programs
A model program consists of imperative programming statements and
control structures, much like a typical Java program.  However, a
model program allows some non-deterministic (and non-Java) statements
as well.  These are described in this section.

[[[ Need enumeration and discussion of these. ]]]

@c ---------------------------------------------------------------------------
@node Other issues,  , Statements within model programs, Status
@section Other issues
[[[ descriptions needed here ]]]

[[[ Use of JMLDataGroups in modifies clauses; what syntactic structures use stsore-refs? ]]]

@menu
* nowarn annotations-JML::      
* Java and JML assert statements::  
* Methods and constructors without bodies in Java files::  
* Methods and constructors in annotation expressions::  
* Original also specifications::  
* anonymous classes::           
* block-level class declarations::  
* field-method-constructor keywords::  
* TYPE Equivalence::            
* exceptions in annotation expressions::  
* Specifications and inheritance::  
@end menu

@c ---------------------------------------------------------------------------
@subsection universe type system

JML has recently introduced a universe type system for alias control.  This
includes type modifiers \readonly, \rep, \peer.  These have not yet been
implemented in Esc/Java2, either in the parser or in the semantics.

@c ---------------------------------------------------------------------------
@subsection infinite-precision arithmetic

JML defines primitive data types @code{\bigint} and @code{\real} 
which denote infinite
precision integers and reals, for use in specifications.  
These type names are parsed, but the underlying semantics and the Simplify
prover do not handle the finite-ness of numeric representations.

@c ---------------------------------------------------------------------------
@node nowarn annotations-JML, Java and JML assert statements, Other issues, Other issues
@subsection nowarn annotations
ESC/Java2 allows an annotation to suppress warnings otherwise produced
by the static checker.  These are discussed in @ref{Nowarn annotations
and warnings}.  JML parses but ignores these annotations.


@menu
* Java and JML assert statements::  
* Specifications and inheritance::  
@end menu

@c --------------------- Java and JML assert statements
@node Java and JML assert statements, Methods and constructors without bodies in Java files, nowarn annotations-JML, Other issues
@subsection Java and JML assert statements

JML has an assert statement of the form
@*@center @code{//@@ assert }@emph{predicate}@code{;}
@*The static checker will evaluate the predicate in the appropriate
context.  If it cannot establish that the predicate is always true, an
ESC/Java warning will be issued.

Java 1.4 also has an assert statement with the syntax
@*@center @code{assert }@emph{predicate}@code{: }@emph{value}@code{;}
@*If the predicate is not true, then a @code{java.lang.AssertionError}
is created, with the given @emph{value} as its argument, and the
exception is thrown.

In versions of Java before 1.4, @code{assert} was a legitimate
identifier name; in Java 1.4 it is a keyword and may not be used as an
identifier.  To achieve backwards compatibility, Java compilers have a
@code{-source} command line option; ESC/Java2 behaves in a way similar
to typical Java compilers:

@itemize @bullet
@item specifying 
@code{-source 1.4} causes ESC/Java2 to interpret @code{assert} in Java
statements as a keyword;
@item 
omitting the @code{-source} option or specifying an argument other
than @code{1.4} causes ESC/Java2 to treat @code{assert} in Java
statements as an identifier and to issue errors on encountering uses
of the word as a keyword (i.e. to interpret assert in Java 1.3 mode).
@end itemize

There are three options for how ESC/Java2 should treat Java
@code{assert} statements (when @code{-source 1.4} is specified).
ESC/Java2 provides command-line options to achieve each of these
behaviors.
@enumerate A
@item Parse but ignore them.
@item Treat them as Java does, namely, as equivalent to 
@*@center @code{if ( ! }@emph{predicate}@code{) throw new java.lang.AssertionError(}@emph{value}@code{);}
@item Treat them as a JML assert statement, namely, as equivalent to
@*@center @code{//@@ assert }@emph{predicate}@code{;}
@end enumerate
@noindent
The command line options for these three cases are
@enumerate A
@item @code{-source 1.4}
@item @code{-javaAssertions} or @code{-eajava}
@item @code{-jmlAssertions} or @code{-eajml}
@end enumerate
@noindent


Note that there are, internally, three independent conditions:
@itemize @bullet
@item The version of Java being recognized.  This is controlled by the @code{-source} option.
@item Whether Java assert statements are enabled (given that Java 1.4 source is
being processed).  Java has them disabled by 
default.  This is controlled by the options @code{-disableassertions}, 
@code{-enableassertions}, @code{-da}, @code{-ea}.  The use, as in Java, of
package names with these assertions or of enabling or disabling system
assertions is not implemented in ESC/Java2.
@item Whether to treat Java 1.4 assert statements in Java mode or JML mode (given
that Java assertions are enabled).  This is controlled by the
@code{-javaAssertions} and @code{-jmlAssertions} options.  @code{-javaAssertions}
is the default; both options also effectively do @code{-source 1.4 -ea}.
@end itemize


Here are some examples of use:
@itemize @bullet
@item  
@example
        public void m() @{
                assert false : "Message";
        @} 
@end example
@noindent 
Java behavior: ESC/Java2 will issue an Unexpected Exception warning
@*JML behavior: ESC/Java2 will issue an Assert warning

@item  
@example
        public void m() @{
                assert false : "Message"; //@@ nowarn;
        @} 
@end example
@noindent 
Java behavior: ESC/Java2 will issue an Unexpected Exception warning
@*JML behavior: ESC/Java2 will not issue any warning 
(suppressed by the nowarn annotation)

@item  
@example
        public void m() @{
                assert true : "Message";
        @} 
@end example
@noindent
Java behavior: No warnings - no exception ever thrown
@*JML behavior: No warnings - predicate is always true

@item  
@example
        //@@ exsures (java.lang.AssertionError e) true;
        public void m() @{
                assert false : "Message";
        @} 
@end example
@noindent
Java behavior: ESC/Java2 will issue an Unexpected Exception warning
@*JML behavior: ESC/Java2 will issue an Assert warning
@* [[[ There may be a bug here - ESC/Java complains about types in an
exsures clause that are not in the throws list of the declaration, but
ESC/Java2 does not.]]]

@item  
@example
        //@@ exsures (java.lang.AssertionError e) true;
        public void m() throws AssertionError @{
                assert false : "Message"; 
        @} 
@end example
@noindent
Java behavior: No warnings - the exsures clause allows the exception.
@*JML behavior: Assert error.


@item  
@example
        //@@ exsures (java.lang.AssertionError e) false;
        public void m() throws AssertionError @{
                assert false : "Message"; 
        @} 
@end example
@noindent
Java behavior: Postcondition warning - the exsures clause disallows the exception.
@*JML behavior: Assert error.


@end itemize

@c ----------------------------------------------------------------------------
@node Methods and constructors without bodies in Java files, Methods and constructors in annotation expressions, Java and JML assert statements, Other issues
@subsection Methods and constructors without bodies in Java files

Java requires non-abstract, non-native methods and constructors to
have a defined body.  Some tools, such as javadoc, allow the bodies to
be stubbed with a semicolon in place of the usual block statement.
ESC/Java2 also allows method and constructor bodies within .java files
to be represented simply by a semicolon.  This allows classes to be
documented and specified before the implementation is completed.  JML
tools (except jmldoc) and ESC/Java require bodies to be present.

@c ----------------------------------------------------------------------------
@node Methods and constructors in annotation expressions, Original also specifications, Methods and constructors without bodies in Java files, Other issues
@subsection Methods and constructors in annotation expressions

JML allows the use of pure methods and constructors in annotation expressions; 
the original ESC/Java did not.  ESC/Java2 follows JML.  
[[[ Need a discussion of the implementation of this. ]]]

@c ----------------------------------------------------------------------------
@node Original also specifications, anonymous classes, Methods and constructors in annotation expressions, Other issues
@subsection  Original ESC/Java also_ specifications

The original ESC/Java utilized the keywords @code{also_requires},
@code{also_ensures}, @code{also_exsures}, and @code{also_modifies} to
add annotations to subclasses.  These annotations were simply
textually conjoined with the annotations from a superclass or
interface.  The syntax and semantics in JML are different and
ESC/Java2 has changed to match JML.  These keywords are now deprecated
and are translated into the corresponding keyword without
@code{also_}.  However, the semantics of annotations in the presence
of inheritance is now somewhat different and is described by the
desugaring process (@pxref{Desugaring}).  ESC/Java2 issues warnings if
the original keywords are used and users are encouraged to change
them.

@c ----------------------------------------------------------------------------
@node anonymous classes, block-level class declarations, Original also specifications, Other issues
@subsection  anonymous classes

Java allows anonymous classes (named classes with some method
overrides).  An anonymous class is a subclass of the named class and
is nested within the class in which it is defined (but is not a member
of the enclosing class).  One can add specifications to the anonymous
class body and the members within it.  However, since there are no
quantities declared with the static type of the anonymous type, those
specifications are not used in checking any uses of the routines of
the anonymous class.  ESC/Java2 does recognize that the anonymous
class is a subclass and not the same class as its superclass.

@*@strong{Status:} There is no static checking of the implementation of
any of the methods of an anonymous class.

@c ----------------------------------------------------------------------------
@node block-level class declarations, field-method-constructor keywords, anonymous classes, Other issues
@subsection block-level class declarations

Java allows classes to be declared as local classes within a 
block statement.  These constructs are parsed and type-checked.  However,
@itemize @bullet
@item Although such a class (and its routines) may have annotations,
the body of the implementation of these routines are not checked against the
specifications.
@item  Any
specifications are used when the methods of the class are called.
@end itemize
[[[ what about model classes ??? ]]]

@c ----------------------------------------------------------------------------
@node field-method-constructor keywords, TYPE Equivalence, block-level class declarations, Other issues
@subsection  @code{field}, @code{method} and @code{constructor} keywords

JML is designed to work with any Java code.  In particular that code may use
JML keywords as variables and type names.  This can create a problem in parsing
annotations.  For example, if @code{helper} has been declared a class, then an
 annotation that begins with
@center @code{//@@ helper model ...}
@noindent
@*could be interpreted as the beginning of a declaration with type
@code{helper} and identifier @code{model} or as the beginning of a model
method declaration with JML modifier helper.  Though in some cases
sufficient lookahead could distinguish these different uses, JML has
defined the keywords @code{field}, @code{method}, and @code{constructor}
to help disambiguate such situations.  These are used in ghost field and
model field, method, and constructor declarations.  [[[ Are they
applicable to non-model decls in JML???]]]  [[[ Are they needed with
model type declarations or model programs???]]]  They have the effect
that any identifiers appearing after these keywords in a JML annotation
are not interpreted as JML keywords (except for @code{non_null} and
@code{nullable} in formal parameters as described below).  For example,
in
@center @code{//@@ public model non_null helper method requires ensures() @{@};}
@noindent
@*@code{model}, @code{non_null}, @code{nullable}, @code{helper}, and
@code{method} are JML keywords, but @code{requires} is expected to be a
Java type name and @code{ensures} is interpreted as an identifier, the
name of the method being declared.

The two exceptions to this rule are that @code{non_null} and
@code{nullable} are needed as a JML modifier within the formal parameter
declarations.  A parser is capable of distinguishing these cases,
however.  Thus in
@*@center @code{//@@ public model requires ensures(non_null Object o, non_null oo);}
@noindent
@*the first occurrence of @code{non_null} is a JML modifier, but the
second is expected to be a Java type name.  [[[ ESC/Java treats
non_null specially in this case, but the JML tools do not.  For JML
you cannot use @code{non_null} here and need to write explicit
pre/post-conditions instead.]]]  @*@noindent @code{Status: } Fully
implemented.

@c ----------------------------------------------------------------------------
@node TYPE Equivalence, exceptions in annotation expressions, field-method-constructor keywords, Other issues
@subsection Equivalence of @code{\TYPE} and @code{java.lang.Class}

In Java, the types of classes can be treated as first class values of
type @code{java.lang.Class}.  In JML the type @code{\TYPE} has been
defined as the type of type values.  The following table shows the
relationships between Java and JML syntax and quantities.  In the
following @code{T} is a type name, such as @code{int} or
@code{java.lang.String}, @code{t} is an expression of @code{\TYPE}
type, and @code{e} is an expression of any type.

@c [[[ It would be better if we could have rules (lines) in this table,
@c or at least spacing ]]]
@c [[[ is the subtype relationship line a correct equivalent for primitive 
@c types??? ]]]
@multitable @columnfractions .45 .20 .35
@item
	@tab JML
	@tab Java
@item Type names denoting the type of type values
	@tab \TYPE
	@tab java.lang.Class
@item Expression that is a type literal
corresponding to a given type name
	@tab @code{\type(T)}
	@tab @code{T.class}
@item Expression whose value is the type value corresponding 
to the name in a String
	@tab
	@tab @code{Class.forName(s)}
@item Expression whose value is the type value corresponding 
to the dynamic type of an expression 
	@tab @code{\typeof(e)}
	@tab @code{e.getClass()}
@item subtype relationship between two type values 
	@tab @code{t1 <: t2}
	@tab @code{t2.isAssignableFrom(t1)}
@item Expression has type or is subtype of type name
	@tab @code{\typeof(t) <: \type(T)}
	@tab @code{t instanceof T}
@item A type value corresponding to the element type of an array type
	@tab @code{\elemtype(t)}
	@tab @code{t.getComponentType()}
@end multitable

In JML and ESC/Java2, @code{\TYPE} and @code{java.lang.Class} have
been made equivalent; thus the corresponding quantities in each row
may be used interchangeably (in annotations). The one exception in
ESC/Java2 is that methods of @code{Class} (or @code{Object}) may not
be invoked on a value of type @code{\TYPE}.

The location where the equivalence is particularly needed is in
writing the specifications for a method such as
@code{java.lang.Object.getClass()}, which is inherited by every
reference type in Java.  The natural specification (in
java.lang.Object) is
@example
//@@ ensures \result == \typeof(this);
java.lang.Class getClass();
@end example
@noindent
which can only be written if the value on the left-hand side
of the ensures predicate, which has
type @code{java.lang.Class},
can be compared to the value on the right-hand side, which 
has type @code{\TYPE}.

@c ----------------------------------------------------------------------------
@node exceptions in annotation expressions, Specifications and inheritance, TYPE Equivalence, Other issues
@subsection exceptions in annotation expressions
[[[Discuss the behavior of logical and short-circuit operators in the
presence of undefined expressions (or expressions that throw
exceptions).]]]

@c ----------------------- Specifications and inheritance
@node Specifications and inheritance,  , exceptions in annotation expressions, Other issues
@subsection Specifications and inheritance
[[[ Talk about behavioral inheritance ]]]

@menu
* Desugaring in the presence of inheritance::  
* Defaults and inheritance::    
* Inheritance and non_null::    
@end menu

@c ----------------------------------------------------------------------------
@node Desugaring in the presence of inheritance, Defaults and inheritance, Specifications and inheritance, Specifications and inheritance
@subsubsection Desugaring in the presence of inheritance
ESC/Java has some limitations and some unsoundness in handling the
inheritance of specifications.  If a superclass stated a precondition
(with a requires clause), then a subclass could not state an
additional precondition.  If a superinterface stated a precondition,
an implementing class was permitted to state a precondition using the
@code{also_requires} keyword, but the discussion in the ESC/Java
User's Manual acknowledged this to be an unsound construct.

ESC/Java2 has corrected this problem by using the syntax and
desugaring approach outlined by JML.  JML allows subclasses to have
additional @code{requires} clauses, and does not utilize the
@code{also_requires} syntax.  Consider the following example (the
handling of superinterfaces is the same as the handling of super
classes):
@example
public interface Super @{
        //@@    requires P1;
        //@@    ensures Q1;
        public void m();
@}

public class D extends Super @{
        //@@ also
        //@@    requires P3;
        //@@    requires PP3;
        //@@    ensures Q3;
        public void m();
@}
@end example
@noindent
ESC/Java would combine the interface and subclass specifications as follows:
@example
        //@@ requires P1;
        //@@ requires P3;
        //@@ requires PP3;
        //@@ ensures Q1;
        //@@ ensures Q3;
@end example
@noindent
This does not satisfy behavior inheritance.  The desugaring provided
by ESC/Java2 is correct:
@example
        //@@ requires P1 || (P3 && PP3);
        //@@ ensures P1 ==> Q1;
        //@@ ensures (P3 && PP3) ==> Q3;
@end example

Here is a larger example:
@example
public class Super @{
        //@@    requires P1;
        //@@    ensures Q1;
        //@@ also
        //@@    requires P2;
        //@@    ensures Q2;
        public void m();
@}

public class D extends Super @{
        //@@ also
        //@@    requires P3;
        //@@    requires PP3;
        //@@    ensures Q3;
        //@@ also
        //@@    requires P4;
        //@@    ensures Q4;
        public void m();
@}
@end example
@noindent
The specifications in @code{Super} desugar (in ESC/Java2) to
@example
        //@@ requires P1 || P2;
        //@@ ensures P1 ==> Q1;
        //@@ ensures P2 ==> Q2;
@end example
@noindent
The specifications in @code{D} desugar to
@example
        //@@ requires (P3 && PP3) || P4;
        //@@ ensures  (P3 && PP3) ==> Q3;
        //@@ ensures  P4 ==> Q4;
@end example
@noindent
but they are then combined with the superclass specifications to
produce the composite specification:
@example
        //@@ requires P1 || P2 || (P3 && PP3) || P4;
        //@@ ensures  P1 ==> Q1;
        //@@ ensures  P2 ==> Q2;
        //@@ ensures  (P3 && PP3) ==> Q3;
        //@@ ensures  P4 ==> Q4;
@end example

With this approach the unsoundness of @code{requires} noted in section
C.0.4 of the ESC/Java User's Manual is corrected.  However, the
behavior of some specifications will change, since specifications of
an overriding method are no longer simply textually conjoined with the
specifications of an overridden method.  For example in ESC/Java, the
specification of @code{m()} in this code
@example
public class Super @{
        //@@ requires i > 0;
        public int m(int i) @{...@}
@}
public class D @{
        //@@ ensures \result > 0;
        public int m(int i) @{...@}
@}
@end example
@noindent
was interpreted as
@example
        //@@ requires i > 0;
        //@@ ensures \result > 0;
@end example
@noindent
whereas in ESC/Java2 it is
@example
        //@@ requires i > 0 || true;
        //@@ ensures i > 0 ==> true;
        //@@ ensures true ==> \result > 0;
@end example
@noindent
which is equivalent to
@example
        //@@ requires true;
        //@@ ensures \result > 0;
@end example

@c ----------------------------------------------------------------------------
@cindex clause defaults
@cindex defaults
@cindex inheritance of specifications
@node Defaults and inheritance, Inheritance and non_null, Desugaring in the presence of inheritance, Specifications and inheritance
@subsubsection Defaults and inheritance

The defaults for missing clauses were described in 
@ref{specifications}. The effect of
the default for @code{requires} is demonstrated in these examples.

Given
@example
class Super @{
        //@@ requires P;
        //@@ ensures Q;
        public void m();
@}

class Derived extends Super @{
        // no spec given - default is 'requires false'
        public void m();
@}
@end example
@noindent the two classes behave as if they had these specifications
@example
class Super @{
        //@@ requires P;
        //@@ ensures P ==> Q;
        public void m();
@}

class Derived extends Super @{
        //@@ also
        //@@ requires P;
        //@@ ensures P ==> Q;
        public void m();
@}
@end example


Given
@example
class Super @{
        // no spec given - default is 'requires true'
        public void m();
@}

class Derived extends Super @{
        //@@ also
        //@@ requires P;
        //@@ ensures Q;
        public void m();
@}
@end example
@noindent the two classes behave as if they had these specifications
@example
class Super @{
        //@@ requires true;
        public void m();
@}

class Derived extends Super @{
        //@@ also
        //@@ requires true;
        //@@ ensures P ==> Q;
        public void m();
@}
@end example

Finally, given
@example
class Super @{
        // no spec given - default is 'requires true'
        public void m();
@}

class Derived extends Super @{
        // no spec given - default is 'requires false'
        public void m();
@}
@end example
@noindent the two classes behave as if they had these specifications
@example
class Super @{
        //@@ requires true;
        public void m();
@}

class Derived extends Super @{
        //@@ also
        //@@ requires true;
        public void m();
@}
@end example

[[[ What does jmlrac do with this issue?]]]

@c ----------------------------------------------------------------------------
@node Inheritance and non_null,  , Defaults and inheritance, Specifications and inheritance
@subsubsection Inheritance and non_null

@c @todo kiniry Rewrite this section for nullable.

The syntactic rules and semantic meaning of @code{non_null} on formal
parameters in the presence of inheritance differ between ESC/Java and
ESC/Java2.

The annotation @code{nullable} did not exist at all in JML until late
2005, thus it was not supported at all in ESC/Java.

A @code{non_null} annotation on a formal parameter is equivalent to 
(a) a requirement that the parameter not be assigned a null value in the
body of the implementation of the routine, and
(b) an additional precondition in each of the specification cases of
the method's (or constructor's) specifications.
Item (b) means that
@example
... specifications ...
public void m(/*@@ non_null */ Object o, Object oo)
@end example
@noindent
is equivalent to
@example
//@@ requires o != null;
//@@ @{|
     ... specifications ...
//@@ |@}
@end example
@noindent
Similarly a @code{non_null} annotation on the result is equivalent to an
additional post-condition:
@example
... specifications ...
public /*@@ non_null*/ Object m()
@end example
@noindent
is equivalent to
@example
//@@ ensures o != null;
//@@ @{|
     ... specifications ...
//@@ |@}
@end example
@noindent
[ This syntax is not legal JML since an ensures may not appear outside
of the nested specifications, but the intent is evident: the ensures
clause is distributed to each specification case. ]

Confusing situations can arise if formal parameters in a overridden
and overiding declaration differ in @code{non_null} annotations.

@itemize @bullet
@item Case 1: superclass has @code{non_null}, subclass has a specification,
      but no @code{non_null}

@example
class Super @{
    public void nonnull(/*@@ non_null */ Object o);
        
    public void m(/*@@ non_null */ Object o) @{
        nonnull(o);           // Line A - OK
        o = null;             // Line B - FAILS
    @}
@}
class Derived extends Super @{
    //@@ also
    //@@ requires true; 
    public void m(Object o) @{
        nonnull(o)            // Line C - FAILS
        o = null;             // Line D - OK
    @}
 
    public void mm() @{
        Object o;
        m(o);                 // Line E - OK
        (new S()).m(o);       // Line F - FAILS
    @}
@}
@end example
In this case, ESC/Java has @code{Derived.m} inherit the @code{non_null}
specification from the overridden method.  Hence ESC/Java reports
errors for lines B, D, E and F, with A and C being OK.  In ESC/Java2,
however, @code{Derived.m} has its own specification and does not
inherit the @code{non_null} specification.  It must still satisfy the parent
spec (which in this case simply has a trivial postcondition).  So
Lines B and F are errors and A is not.  However, the combined spec for
@code{Derived.m} is (ignoring other clause types)
@example
        requires o != null;
        ensures true;
        also
        requires true;
        ensures true;
@end example
which is equivalent to @code{requires true;}.  Thus lines D and E are OK, and C
will provoke an error.

If the precondition of @code{Derived.m} were @code{requires false;},
then the combined spec would be
@example
        requires o != null;
        ensures true;
        also
        requires false;
@end example
@noindent
which is equivalent to @code{requires o != null;}.  Then E would fail,
and C and D would be OK.  In otherwords, it would be the same as Case
2 below.


 
@item Case 2: superclass has @code{non_null}, subclass has no specification
       and no @code{non_null}

@example
class Super @{
    public void nonnull(/*@@ non_null */ Object o);
        
    public void m(/*@@ non_null */ Object o) @{
        nonnull(o);           // Line A - OK
        o = null;             // Line B - FAILS
    @}
@}
class Derived extends Super @{

    public void m(Object o) @{
        nonnull(o); // Line C - OK - precondition limits values of o
        o = null;   // Line D - OK - no restriction on 
                    //               assignments in this body
    @}

    public void mm() @{
        Object o;
        m(o);                 // Line E - FAILS
        (new S()).m(o);       // Line F - FAILS
    @}
@}
@end example
In this case Derived.m has no specification.  Consequently it has a
default specification of @code{requires false;} and effectively
inherits the overridden method's specification, including the
@code{non_null}.  Lines B and F are still errors, and A is not,
because of the specification of Super.m; line E is an error, and C and
D are not.
 

@item Case 3: superclass has no @code{non_null}, but subclass does

@example
class Super @{
    public void nonnull(/*@@ non_null */ Object o);
        
    public void m(Object o) @{
        nonnull(o);           // Line A - FAILS
        o = null;             // Line B - OK
    @}
@}
class Derived extends Super @{

    public void m(/*@@ non_null */ Object o) @{
        nonnull(o);      // Line C - FAILS - annotation ignored
        o = null;        // Line D - OK - annotation ignored
    @}
 
    public void mm() @{
        Object o;
        m(o);                 // Line E - OK
        (new S()).m(o);       // Line F - OK
    @}
@}
@end example
@noindent In this case, it is the derived class that has the 
@code{non_null} specification, but not the superclass.  This is a
problematic case, since the body of the overriding method may be
called through the overridden signature, in which case the actual
argument may not be constrained to be non_null.  Hence the non_null
annotation on the overriding formal paramater can be misleading.
Therefore in ESC/Java2, a @code{non_null} annotation is ignored if there is
any overridden method that has that formal parameter declared without
a @code{non_null} argument.  A caution message is provided to warn the user
of this behavior.

Thus, ESC/Java2 will allow lines B and F since the superclass does
not limit the values of the parameter; similarly line A provokes an
error.  Although the parameter of @code{Derived.m} is declared
@code{non_null}, the @code{non_null} annotation is ignored.
Consequently, there is no limitation on the value of the formal
parameter (since it may have been called through the superclass's
signature), and hence line C fails; similarly, there is no limitation
on what may be assigned to the formal parameter variable, so line D is
ok.  Finally, line E is ok since there is no additional precondition
created by the ignored @code{non_null}.

Note that behavior equivalent to the @code{non_null} declaration on a
formal parameter can be obtained by adding appropriate explicit
preconditions requiring the formal parameter to be @code{non_null} in the
appropriate circumstances.  Furthermore, if it is actually desired to
have the formal parameter be @code{non_null} within the body, code such
as the following can be written.  Instead of
@example
        public void m(/*@@ non_null */ Object o) @{
                ...
        @}
@end example
@noindent write
@example
        public void m(Object oo) @{
                /*@@ non_null */ Object o = oo;
                ...
        @}
@end example
@end itemize  

Finally note that
@itemize @bullet
@item the original ESC/Java does not allow overriding methods to have
@code{non_null} parameters, whether or not the overridden method does;
@item there are no particular issues with respect to @code{non_null} 
on the result type; overriding and overridden methods may have any
combination of @code{non_null} annotations or lack thereof.
@end itemize  


[[[ What does jmlrac do with the inheritance of non_null? ]]]

@node features, Changes to static checking, Status, Top
@chapter ESC/Java2 features

This chapter describes some of the user-interface 
features and usage of ESC/Java2.
A description of how to run ESC/Java2 is provided in
@ref{Running ESCJava2}.

@c ------ section Error and warning messages --------
@menu
* Error and warning messages::  
* Nowarn annotations and warnings::  
* Command-line options::        
* Environment variables::       
@end menu

@node Error and warning messages, Nowarn annotations and warnings, features, features
@c  node-name,  next,  previous,  up
@section Error and warning messages

@cindex error messages
@cindex fatal errors
@cindex cautions
@cindex warnings
ESC/Java2 continues ESC/Java's use of four levels of error messages:
@itemize @bullet
@item  @strong{fatal} errors are problems (usually invalid syntax) 
that prevent ESC/Java from proceeding further in parsing and checking
files;
@item  @strong{errors} indicate illegally formed input files, 
though processing may continue to find other errors or even to attempt
static checking of the files (errors or checks subsequent to the first
problem may be erroneous as a result of earlier problems);
@item  @strong{cautions} indicate situations that are not illegal, but may be
misleading to the user - a common example is features that are parsed
but not checked (also some illegal JML constructs are reported using
cautions if ESC/Java2 can unambiguously correct them);
@item  @strong{warnings} indicate situations in which the static 
checking phase could not determine that annotation specifications were
satisfied, such as an inability to determine that an object reference
is non-Null when it is dereferenced.
@end itemize
The reporting of cautions and warnings can be controlled by
command-line options (@code{-noCautions}, @code{-nowarn},
@code{-warn}, @code{-nocheck}).

@c ------ Nowarn annotations and warnings --------
@node Nowarn annotations and warnings, Command-line options, Error and warning messages, features
@c  node-name,  next,  previous,  up
@section Nowarn annotations and warnings

@menu
* nowarn annotations::          
* nowarn warning types::        
@end menu

@c ----------------------------------------------------------------------------
@node nowarn annotations, nowarn warning types, Nowarn annotations and warnings, Nowarn annotations and warnings
@subsection nowarn annotations
@itemize @bullet
@item @strong{Description:} 
A nowarn annotation has the form 
@*@center @code{//@@ nowarn @emph{comma-separated-list-of-warning-types};}
@*or simply
@*@center @code{//@@ nowarn ;}
@*The annotation is associated with the line in the source file on
which it is located, rather than with a grammatical construct.  It is
used to suppress warnings from the static checker associated with a
construct on that line; the annotation will suppress the warning
either if it is on the line where the offending action took place or
if it is on the line of the associated declaration.  If there is no
list of warning types, then all warnings associated with this line are
suppressed.  The warnings of a given type can also be suppressed using
command-line options.  The nowarn annotations have no effect on errors
or cautions, since these are produced by parsing or semantic errors in
the source code itself.

@item @strong{Status:} Implemented.

@item @strong{Differences from JML or Java:} JML supports the parsing of these
annotations, but since JML does no static checking, it ignores them.
ESC/Java did not require a terminating semicolon, but JML does.
ESC/Java2 accepts nowarn annotations with or without a terminating
semicolon; it issues a caution if the semicolon is missing.  [[[ JML
should allow a nowarn without a list to be terminated by an end of
line. ]]]
@end itemize

@c ----------------------------------------------------------------------------
@node nowarn warning types,  , nowarn annotations, Nowarn annotations and warnings
@subsection nowarn warning types

The static checker used in ESC/Java2 (and in ESC/Java) produces
warnings (as opposed to errors or cautions) when it detects source
code that might violate the specifications.  These warnings are
categorized into types and can be suppressed or enabled by warning
type name, using either the @code{nowarn} annotation or the
command-line options @code{-nowarn}, which suppresses individual
warning types, or @code{-warn}, which enables individual warning
types, or @code{-nocheck}, which turns off all static checking.  The
following list of the warning types is excerpted (except where
additions are explicitly noted) and quoted from the "ESC/Java User's
Manual".

The additional warning pseudo-type name "All" may be used with the
@code{-nowarn} command-line option to turn off all warnings;
@code{-warn} may then be used to selectively turn on individual
warning types.  The "All" type may not be used with @code{-warn}.

@itemize @bullet
@item
@strong{ArrayStore} warns that the control may reach an assignment
@code{A[I] = E} when the value of
@code{E} is not assignment compatible with
the actual element type of @code{A}.

@item
@strong{Assert} warns that control may reach a pragma 
@code{assert E} when the value of @code{E} is false.

@item
@strong{Cast} warns that control may reach a cast @code{(T)E}
when the value of @code{E} cannot be cast to the type @code{E}.

@item
@strong{Constraint} warns that a method does not establish the
post-condition stated in a @code{constraint} clause [added in ESC/Java2].

@item
@strong{Deadlock} warns that control may reach a @code{synchronized}
statement that would acquire a lock in violation of the locking order,
or that a @code{synchronized} method may start by acquiring a lock
in violation of the locking order.

@item
@strong{Exception} warns that a routine may terminate abruptly by
throwing an exception that is not an instance of any type listed explicitly
in the routine's throws clause.

@item
@strong{IndexNegative} warns that control may reach an array access
@code{A[I]}
when the value of the index
@code{I} is negative.

@item
@strong{IndexTooBig} warns that control may reach an array access
@code{A[I]}
when @code{A.length <= I}.

@item
@strong{Initially} warns that a constructor does not establish the
post-condition stated in an @code{initially} clause [added in ESC/Java2].

@item
@strong{Invariant} warns that some object invariant may not hold
when control reaches a routine call, or that some object invariant may
not hold on exit from the current body.

@item
@strong{LoopInv} warns that some loop invariant may not hold when
it is supposed to.

@item
@strong{Modifies} warns that an assignment or method call violates the
assignable (modifies) clauses of a routine [added in ESC/Java2].

@item
@strong{OwnerNull} warns that a constructor may violate the implicit
postcondition @code{this.owner != null}.  [[[ Explain this ???]]]

@item
@strong{NegSize} warns of a possible attempt to allocate an array
of negative length.

@item
@strong{NonNull} warns of a possible attempt to assign the value
@code{null} to a variable whose declaration is modified by a
@code{non_null} pragma, or to call a routine with an actual parameter
value of @code{null} when the declaration of the corresponding formal
parameter is modified by a @code{non_null} pragma.

@item
@strong{NonNullInit} warns that a constructor may fail to establish a
non-null value for an instance field of the constructed object when
the declaration of that instance field is modified by a
@code{non_null} pragma.

@item
@strong{Null} warns of a possible attempt to dereference null, for
example, by field access @code{O.f}, an array access @code{O[i]}, a
method call @code{O.m(...)}, a synchronized statement
@code{synchronized (O) ...}, or a throw statement @code{throw O},
where @code{O} evaluates to @code{null}.

@item
@strong{Post} warns that a routine body may fail to establish some
normal postcondition (on terminating normally) or some exceptional
postcondition (when terminating by throwing an exception of a relevant
type).

@item
@strong{Pre} warns that control may reach a routine call when some
precondition of the routine does not hold.

@item
@strong{Race} warns of a possible attempt to access a monitored
field while not holding the requisite lock(s).

@item
@strong{RaceAllNull} warns of a possible attempt to access a monitored
field at a time when all of the objects designated as monitors for the
field are null.

@item
@strong{Reachable} warns that control may reach an @code{unreachable}
pragma.

@item
@strong{Uninit} warns that control may reach a read access to a
local variable before execution of any assignment to the variable other
than an initializer in a declaration modified by an @code{uninitialized}
pragma.

@item
@strong{Unreadable} warns that control may reach a read access of
a field or variable @code{x} when the expression in a @code{readable_if}
pragma modifying @code{x}'s declaration is false.
 [[[ readable_if has changed]]]

@item
@strong{ZeroDiv} warns of a possible attempt to apply the integer
division (@code{/}) or remainder (@code{%}) operator with zero as the
divisor.

@end itemize

@c ----------------------------------------------------------------------------
@node Command-line options, Environment variables, Nowarn annotations and warnings, features
@section Command-line options

ESC/Java2 has implemented a number of command-line options that are
not present in ESC/Java, as well as documenting some of those in
ESC/Java.  ESC/Java2 also kept many experimental (and undocumented)
options from ESC/Java.  The following is a partial list of
command-line options available in ESC/Java2; some of these have been
added to those available in ESC/Java or had their behavior altered.

Note that in ESC/Java all command-line options and their 
arguments must precede all file names. ESC/Java2 allows file names
and other input entries to be intermixed with options.

@itemize

@cindex -bootclasspath
@item @code{-bootclasspath} @emph{directory-path} : specifies 
the location of system binary files; this directory path is appended
to any specification for the classpath in finding class files; the
default is the platform-dependent classpath specified by Java
preferences (using the -v option will show the full classpath being
used)

@cindex -class
@item @code{-class} @emph{fully-qualified-class-name} :
the named class will be one of the input entries upon which the program acts

@cindex -classpath
@cindex classpath
@item @code{-classpath} @emph{directory-path} : specifies the 
directories in which
binary (.class) files for types are sought; the default is to use the value of
the CLASSPATH environment variable, or to use just the current directory if 
neither @code{-classpath} nor CLASSPATH is specified 
[[[ What about java property ]]]

@cindex -da
@item @code{-da} : synonym for @code{-disableassertions}

@cindex -dir
@item @code{-dir} @emph{directory} : providing a directory as an input entry
is equivalent to (but much shorted and more robust than)
listing all JML-relevant files within that directory

@cindex -disableassertions
@item @code{-disableassertions} : as in Java, causes parsing to 
read Java 1.4 source but ignores any Java assert statements

@cindex -ea
@item @code{-ea} : synonym for @code{-enableassertions}

@cindex -eajava
@item @code{-eajava} : synonym for @code{-javaAssertions}

@cindex -eajml
@item @code{-eajml} : synonym for @code{-jmlAssertions}

@cindex -enableassertions
@item @code{-enableassertions} : as in Java, causes parsing to 
read Java 1.4 source and to use Java assert statements

@cindex -f
@item @code{-f} @emph{filename} : the
text within the named file is inserted at that location in the command-line;
this option is typically used to insert standard sets of options or
input elements into the command-line.

@cindex -file
@item @code{-file} @emph{filename} : the
file given is one of the input elements upon which the program will act

@cindex -gui
@item @code{-gui} : this must be the first command-line argument;
it causes the GUI version of ESC/Java2 to start

@cindex -help
@item @code{-help} : causes the program to print information 
about command-line options and then to terminate

@cindex -javaAssertions
@item @code{-javaAssertions} : causes parsing to read Java 1.4 
source and to treat Java assert statements as Java does, as a throw of
a @code{java.lang.AssertionError} exception

@cindex -jmlAssertions
@item @code{-jmlAssertions} : causes parsing to read Java 1.4 
source and to treat Java assert statements like JML assert statements

@cindex -list
@item @code{-list} @emph{filename} : the given file must contain a sequence
of input entries, one per line; the option can be used to include a standard
set of files, directories, packages, or classes (see also @code{-f})

@cindex -loop
@item @code{-loop} @emph{n}[ | .0 | .5 ] : ESC/Java analyzes loops by
unrolling them.  The argument of the option specifies the number of times the
loop is unrolled.  The default is 1.5.  The precise meaning of the argument
(including the inclusion of the .5) is described in the ESC/Java User's Manual.

@cindex -neverBinary
@item @code{-neverBinary} : do not use any class files, even if there is no
java file for a type

@cindex -neverSource
@item @code{-neverSource} : do not use any java files, even if there is no
class file for a type

@cindex -noCautions
@cindex cautions
@item @code{-noCautions} : suppresses the reporting of any cautions

@cindex -nocheck
@item @code{-nocheck} : will not execute the static checking phase, though does all
the parsing, typechecking and verification condition generation

@cindex -nowarn
@item @code{-nowarn} @emph{warning-type} : turns off the reporting of warnings of the given type; use a warning-type of `All' to turn off all warnings

@cindex -package
@item @code{-package} @emph{package-name} : includes all the source files in the given package in the list of source files being processed 
[[[ wihch suffixes ?]]]

@anchor{-parsePlus}
@cindex -parsePlus
@item @code{-parsePlus} : causes ESC/Java2 to process annotations following
the markers @code{//+@@} and @code{/*+@@} (@pxref{Format of annotations}).

@cindex -preferBinary
@item @code{-preferBinary} : if both java and class files exist on the source
and classpath for a type, then always use the class file

@cindex -preferRecent
@item @code{-preferRecent} : if both java and class files exist on the source
and classpath for a type, then always use the one with the most recent
modification time

@cindex -preferSource
@item @code{-preferSource} : if both java and class files exist on the source
and classpath for a type, then always use the java file


@cindex -quiet
@item @code{-quiet} : turns off any informational messages, 
leaving only reports of errors, warnings and cautions.

@cindex -simplify
@item @code{-simplify} @emph{filename} : used to specify the 
Simplify executable that should be used by ESC/Java2.  The executable
chosen must be the appropriate one for the platform on which you are
running.

@cindex -source
@cindex 1.3
@cindex 1.4
@cindex assert
@item @code{-source} @emph{version} : interprets the source code 
according to the definition of Java for the given version.  The only
implemented effect of this option is the interpretation of
@code{assert} as a keyword if the version is @code{1.4} and as a
normal identifier if the version is not @code{1.4}.  The default is
version @code{1.3}.  In the absence of other options, enabling Java
1.4 will cause Java assertions to be treated as exceptions (the
@code{-javaAssertions} mode).  @xref{Java and JML assert statements}.

@cindex -sourcepath
@cindex sourcepath
@item @code{-sourcepath} @emph{directory-path} : specifies the 
directories in which
source and specification files for types are sought; the default is to use the 
classpath 

@cindex -specs
@item @code{-specs} @emph{directory-path} : specifies a directory path of 
specification files.  ESC/Java2 will not work well without a 
set of specifications.  The jar file constituting a release contains a
current version of the JML specifications; if ESC/Java2 is run from that
jar file, those specification will be the default value of this option.

@cindex -v
@cindex verbose
@item @code{-v} : verbose output describing the steps of 
processing (ESC/Java2 has added more output to that produced by
ESC/Java)

@cindex -warn
@item @code{-warn} @emph{warning-type} : turns on the reporting of 
warnings of the given type

@item [[[FIXME - check for others to be documented; group the above by type]]]

@end itemize

@node Environment variables,  , Command-line options, features
@section Environment variables affecting ESC/Java2

There are several environment variables which alter the behavior of
ESC/Java2 or Simplify, which is called by ESC/Java2.  These are
described in this section.

[[[ THESE NEED A LOT OF CLEANUP !!!!! Finish comments ]]]
@itemize @bullet

@item @code{ESCTOOLS_RELEASE}
@item @code{ESCTOOLS_ROOT}
@item @code{SIMPLIFY} - the name of the Simplify executable 
appropriate to the platform on which ESC/Java2 is running.  Current
options are Simplify-1.5.4.linux, Simplify-1.5.4.macosx,
Simplify-1.5.4.solaris, and Simplify-1.5.4.exe (for Windows).  [[[
Only the first two have had any testing. ]]]


@item @code{CLASSPATH}

@item @code{BOOTCLASSPATH}

@item @code{ESC_SPECS} - sets the default value for @code{-specs}

@item @code{ESCJ_VERBOSE} - normally not set.  
When set to some value, then more verbose output is obtained.  This is
simply output describing the environment variables used in invoking
the tool.

@item @code{ESCJ_STDARGS} - the command-line options to be used 
(in addition to any additional ones on the command-line for escjava2).
(Default: -nowarn Deadlock)

@item @code{ESC_REMOTE_DEBUG} - normally not set.  When set to some 
value, then the value of @code{JAVA_VM_DEBUG_FLAGS} is included in the
options supplied to the virtual machine, intended to be used to invoke
the virtual machine in a debugging mode.

@item @code{JAVA} - the name of the executable of the Java 
virtual machine (default: java)

@item @code{JAVA_VM_FLAGS} - the set of options to be supplied 
to the Java virtual machine ( the default is an empty string)

@item @code{JAVA_VM_DEBUG_FLAGS} - a set of flags to be used 
when ESC_REMOTE_DEBUG is set, intended to be used to invoke the
virtual machine in a debugging mode (default is a set of options
appropriate for debugging on my machine!)
@end itemize

The following variables affect the running of the Simplify prover.
@itemize @bullet
@item @code{ESCJ_SIMPLIFY_ARGS} - the command-line arguments 
to use in running simplify (default: -noprune -noplunge)  [[[ No longer???]]]

@item @code{PROVER_KILL_TIME} - the maximum number of seconds 
to spend on any one proof attempt (default: 300)

@item @code{PROVER_CC_LIMIT} - the maximum number of static 
checker warnings to report for any given routine (default: 10)

@item ... and many others, undocumented, but all beginning with PROVER_  ...
@end itemize

The following variables are set automatically to match a standard
release.  For normal operation they should not be set.  They would be
set to another value only in debugging or other unusual circumstances.
However, if they are set in the environment to an arbitrary value,
they would cause a malfunction of the tool.  
@itemize @bullet
@item @code{ESC_CLASSPATH} - the classpath needed to run the ESC/Java2 tool 
(i.e. to find its class files). This is different than the classpath
needed to find the source and class files being checked; those
classpaths are set with the @code{-classpath} and @code{-sourcepath} 
command-line options.

@item @code{ESCJ_SIMPLIFY_DIR} - the directory in which to find the 
Simplify executable
@end itemize

[[[ Predicate abstraction uses some undocumented java properties. ]]]

@c ----------------------------------------------------------------------------
@node Changes to static checking, Incompatibilities, features, Top
@chapter Changes to static checking in ESC/Java2

Many of the changes from ESC/Java to ESC/Java2 are changes to the
parser so that ESC/Java2 will parse and typecheck all of current JML,
as well as being upgraded to handle Java 1.3 and 1.4.  However, there
are several ways in which the static checking has been modified.  They
are described in this chapter.

@menu
* Handling of specification inheritance::  
* nonnull::                     
* Translation of the Java assert statement::  
* Semantics of String::         
* TYPE and Class::              
* The initially clause::        
* The constraint clause::       
* Use of modifies clauses in checking routine bodies::  
* Defaults for modifies clauses::  
* modifies everything::         
* Checking of modifies::        
* typeof::                      
* Use of pure routines in annotations::  
* Model Fields::                
* not modified::                
@end menu

@c ----------------------------------------------------------------------------
@node Handling of specification inheritance, nonnull, Changes to static checking, Changes to static checking
@section Handling of specification inheritance

The semantics of the inheritance of specifications has changed from
ESC/Java to ESC/Java2; ESC/Java2 now matches the semantics of JML.
The implementation required changes in the way that translation of
specifications into guarded commands is performed.  The change in
semantics is described with examples in @ref{Specifications and
inheritance}.

@c ----------------------------------------------------------------------------
@node nonnull, Translation of the Java assert statement, Handling of specification inheritance, Changes to static checking
@section non_null

The semantics of @code{non_null} applied to formal parameters in the
presence of inheritance has changed from ESC/Java to ESC/Java2.  If an
overriding declaration declares a formal parameter @code{non_null} then
all overridden declarations must have that formal parameter declared
@code{non_null}.  This is described in more detail in @ref{Inheritance
and non_null}.

@c ----------------------------------------------------------------------------
@cindex assert
@node Translation of the Java assert statement, Semantics of String, nonnull, Changes to static checking
@section Translation of the Java 1.4 assert statement

The handling of the Java 1.4 assert statement is discussed in
@ref{Java and JML assert statements}.  The assert statement is
translated into equivalent Java or JML constructs and the static
checker is used without modification.

@c ----------------------------------------------------------------------------
@cindex String
@node Semantics of String, TYPE and Class, Translation of the Java assert statement, Changes to static checking
@section Semantics of String

Although java.lang.String is a reference type in Java, it has a number of 
built-in properties that were not modeled in Esc/Java, but have been added in
Esc/Java2.  These properties are the following:
@itemize @bullet
@item The built-in + and += String concatentation operators
@item Explicit String literals are interned
@item The intern method of the String class
@end itemize

@menu
* Concatenation operators::     
* Explicit String literals::    
* The intern method::           
@end menu

@node Concatenation operators, Explicit String literals, Semantics of String, Semantics of String
@subsection Concatentation operators

Note that the += operator is equivalent to an expression using the + operator, namely
x += y is equivalent to x = x + y.  

The key semantic property of the String concatenation property is that it 
produces a fresh (newly allocated) object.  This is important because within
a pure method a fresh object may be modified, just as a newly constructed
object may be modified.

@node Explicit String literals, The intern method, Concatenation operators, Semantics of String
@subsection Explicit String literals

The important semantic property of String literals in Java is that two 
syntactically identical String literals also compare equal as objects.  
Also, the concatenation of two String literals produces a String literal
(at compile time).  Thus,
@example
	String a,b,c;
	a = "sample";
	b = "sample";
	c = "sam" + "ple";
	boolean t = (a==b);        // This is true
	t = (a==c);                // This is also true
	b = new String("sample");
	t = (a==b);                // This is NOT true
@end example

The Simplify prover does not have any built-in knowledge of Strings.
Consequently, Esc/Java2 makes a note of all of the String literals in a 
module, replacing each one by a unique symbol, but using the same symbol
for syntactically identical literals.  The concatenation of String literals
is performed by the parser.

@node The intern method,  , Explicit String literals, Semantics of String
@subsection The intern method

The intern operation maps Strings that compare equal using the equals 
method to the same Object.   String literals are automatically interned.
Thus
@example
	boolean t;
	String a,b,c;
	a = "sample";
	b = new String("sample");
	c = b.intern();
	t = (a==b);                // This is NOT true
	t = (a==c);                // This IS true
@end example
Interning is not yet implemented in ESC/Java2.

@c ----------------------------------------------------------------------------
@node TYPE and Class, The initially clause, Semantics of String, Changes to static checking
@section The @code{\TYPE} and @code{java.lang.Class} types

In JML and ESC/Java2, uses of @code{\TYPE} values and @code{java.lang.Class}
values are interchangeable, with the exception, in ESC/Java2, that methods of
class @code{java.lang.Class} cannot be applied to a @code{\TYPE} value.

@c ----------------------------------------------------------------------------
@cindex initially
@node The initially clause, The constraint clause, TYPE and Class, Changes to static checking
@section The initially clause
JML defines an initially annotation that states a predicate which must be true
of an object after any constructor call.  This is implemented in ESC/Java2 by
adding these assertions as additional postconditions on each non-helper 
constructor,

@c ----------------------------------------------------------------------------
@cindex constraint
@node The constraint clause, Use of modifies clauses in checking routine bodies, The initially clause, Changes to static checking
@section The constraint clause
JML defines a constraint annotation that states a predicate which must be true
of an object after any method call.  This is implemented in ESC/Java2 by
adding constraints as additional postconditions on each non-helper method,

@c ----------------------------------------------------------------------------
@cindex modifies
@cindex \old
@node Use of modifies clauses in checking routine bodies, Defaults for modifies clauses, The constraint clause, Changes to static checking
@section Use of modifies clauses in checking routine bodies

[[[ Fix this - we now do check modifies clauses. ]]]



ESC/Java2 mitigates problems caused by errors in modifies clauses by
maintaining pre-state values for any variable mentioned in an
@code{\old} construct (in addition to those in modifies clauses).  As
a result, the static checking of the routine body proceeds correctly
despite any errors in the modifies clauses.

@c ----------------------------------------------------------------------------
@node Defaults for modifies clauses, modifies everything, Use of modifies clauses in checking routine bodies, Changes to static checking
@section Defaults for modifies clauses

ESC/Java had an implicit default for a missing modifies clause, namely
that nothing was modified (@code{modifies \nothing;} in JML).  JML
defines the default instead to be @code{modifies \everything;}.
ESC/Java2 has implemented this as the default.  The implicit use of
@code{modifies \nothing;} had the danger of missing or hiding many
errors in usage, since unexpected changes to variables caused by
calling a routine are a not unusual source of bugs.  However, some
outstanding issues are discussed in the following section.

There are three special cases of defaults for the modifies clause:
@itemize @bullet

@item Methods annotated as pure (including methods in pure classes) 
have a default modifies clause of @code{modifies \nothing;}.

@item Constructors annotated as pure (including constructors in 
pure classes) have a defaults modifies clause of @code{modifies
this.*;}.  It may have non-default modifies clauses, but these may not
allow more fields to be modified than are contained in @code{this.*}.

@item A default constructor (that is not declared) has a default 
modifies clause that allows the same fields to be modified as does its
superclass constructor.
@end itemize

@c ----------------------------------------------------------------------------
@node modifies everything, Checking of modifies, Defaults for modifies clauses, Changes to static checking
@section modifies \everything

The use of @code{\nothing}, @code{\everything}, and @code{\not_specified} in
a modifies clause are now implemented.  @code{\not_specified} is equivalent to
@code{\everything}, and @code{\everything} is the default.
However there are two issues outstanding.
@itemize @bullet
@item With this default, any method that has no annotations is 
assumed to have the behavior @code{modifies \everything;}.  There is
very little reasoning that can be performed as a result.  Thus any use
of the ESC/Java2 tool will require having specification files for
system classes and for many of the other classes in the user's body of
code.
@item The logic to reason about routine bodies that contain 
calls of methods that are specified with @code{modifies \everything;}
has not yet been defined or implemented.  A caution is issued in these
cases.  But to avoid breaking tests, this caution is not yet turned
on.
@end itemize

[[[ This needs updating when 'modifies everything' is implemented. ]]]

@c ----------------------------------------------------------------------------
@node Checking of modifies, typeof, modifies everything, Changes to static checking
@section Checking of modifies

[[[ Needs description ]]]

@node typeof, Use of pure routines in annotations, Checking of modifies, Changes to static checking
@section \typeof

In ESC/Java, the @code{\typeof} operator applied only to arguments of
reference type.  In ESC/Java2, the arguments may also be primitive types 
and the static checker correctly equates the value with the corresponding
type literal of the form @code{\type(T)}, where @code{T} is a primitive
type name. [[[ This does not work completely yet. ]]]

@c ----------------------------------------------------------------------------
@node Use of pure routines in annotations, Model Fields, typeof, Changes to static checking
@section Use of pure routines in annotations

[[[ This is now allowed - needs description.]]]

@c ----------------------------------------------------------------------------
@node Model Fields, not modified, Use of pure routines in annotations, Changes to static checking
@section Checking of model fields

[[[ Describe the static checking of model fields ]]]

@c ----------------------------------------------------------------------------
@node not modified,  , Model Fields, Changes to static checking
@section \not_modified

The @code{\not_modified} feature of JML is implemented in ESC/Java2 by
replacing it with the predicate @code{ x == \old(x) } for each argument 
@code{x}.


@c ----------------------------------------------------------------------------

@node Incompatibilities, Modifier Summary, Changes to static checking, Top
@chapter Incompatibilities

@menu
* Major features of Java not implemented::  
* Major features of JML not implemented::  
* Limitations of static checking::  
* Incompatibilities-escjava::   
* Non-JML features::            
* JML features needing clarification::  
* Extensions::                  
@end menu

@c ----------------------------------------------------------------------------
@node Major features of Java not implemented, Major features of JML not implemented, Incompatibilities, Incompatibilities
@section Major features of Java not implemented in ESC/Java2

@menu
* Java 1.5::                    
* anonymous and block-level classes::  
* serialization::               
* most multi-threading considerations::  
* Java generics::               
@end menu

@c ----------------------------------------------------------------------------
@node Java 1.5, anonymous and block-level classes, Major features of Java not implemented, Major features of Java not implemented
@cindex Java 1.5
@subsection Java 1.5

ESC/Java2 does not implement any of the new features in Java 1.5.

@c ----------------------------------------------------------------------------
@node anonymous and block-level classes, serialization, Java 1.5, Major features of Java not implemented
@subsection anonymous and block-level classes

These are supported, but the bodies of methods are not checked.
See @ref{anonymous classes} and @ref{block-level class declarations}.

@c ----------------------------------------------------------------------------
@node serialization, most multi-threading considerations, anonymous and block-level classes, Major features of Java not implemented
@subsection serialization
[[[ discussion needed ]]]

@c ----------------------------------------------------------------------------
@node most multi-threading considerations, Java generics, serialization, Major features of Java not implemented
@subsection most multi-threading considerations
[[[ discussion needed ]]]

@c ----------------------------------------------------------------------------
@node Java generics,  , most multi-threading considerations, Major features of Java not implemented
@subsection Java generics

Support for generic typing in Java (or any other features of Java 1.5) is 
not implemented in ESC/Java2.

@c ----------------------------------------------------------------------------
@node Major features of JML not implemented, Limitations of static checking, Major features of Java not implemented, Incompatibilities
@section Major features of JML not implemented in ESC/Java2

@menu
* codecontract-notimp::         
* some aspects of store-ref expressions::  
* implies that and for example behavior::  
* splitting::                   
@end menu

@c ----------------------------------------------------------------------------
@node codecontract-notimp, some aspects of store-ref expressions, Major features of JML not implemented, Major features of JML not implemented
@subsection code_contract clauses
[[[ discussion needed ]]]

@c ----------------------------------------------------------------------------
@node some aspects of store-ref expressions, implies that and for example behavior, codecontract-notimp, Major features of JML not implemented
@subsection some aspects of store-ref expressions
[[[ discussion needed ]]]

@c ----------------------------------------------------------------------------
@cindex implies_that
@cindex for_example
@node implies that and for example behavior, splitting, some aspects of store-ref expressions, Major features of JML not implemented
@subsection implies_that and for_example behavior
These sections of a routine's specification provide specifications
that are implied by the regular specifications.  They are parsed and
typechecked, but no use of them is made in static checking; they are
not used as an aid to reasoning, nor is it checked that they follow
from the other specifications.

@c ----------------------------------------------------------------------------
@node splitting,  , implies that and for example behavior, Major features of JML not implemented
@subsection splitting of annotations across comments
JML technically does not permit annotations to be split across comments,
though there is no definition of an unsplittable unit of an annotation.
In practice, the JML tools allow some splitting and ESC/Java2 allows some
splitting but they are not consistent.  (See @ref{Format of annotations}).
When in doubt, use a multi-line comment.

@c ----------------------------------------------------------------------------
@node Limitations of static checking, Incompatibilities-escjava, Major features of JML not implemented, Incompatibilities
@section Limitations of static checking

[[[ There are lots - find out by experiment ]]]

@c ----------------------------------------------------------------------------
@node Incompatibilities-escjava, Non-JML features, Limitations of static checking, Incompatibilities
@section Incompatibilities with ESC/Java
This section describes ESC/Java features that are not present or
behave differently in ESC/Java2; the many additions to ESC/Java
provided by ESC/Java2 are not discussed.

@menu
* Error messages and warnings::  
* also::                        
* inheritance of specifications::  
* non null on formal parameters and results of routines::  
* monitored by::                
* readable if::                 
* old style initially::         
* semicolon termination::       
* Routine bodies in spec files::  
@end menu

@c ----------------------------------------------------------------------------
@node Error messages and warnings, also, Incompatibilities-escjava, Incompatibilities-escjava
@subsection Error messages and warnings
ESC/Java2 has added error messages to conform with current JML semantics.  
Some old ESC/Java errors and warnings are no longer appropriate and
have been removed.  The overall organization of error messages and warnings
is unchanged (@pxref{Error and warning messages}).

@c ----------------------------------------------------------------------------
@node also, inheritance of specifications, Error messages and warnings, Incompatibilities-escjava
@subsection also
The keywords @code{also_requires}, @code{also_ensures}, @code{also_exsures},
and @code{also_modifies} are no longer supported.  Use @code{also} and note
the change in semantics as described in @ref{Original also specifications}.

@c ----------------------------------------------------------------------------
@node inheritance of specifications, non null on formal parameters and results of routines, also, Incompatibilities-escjava
@subsection inheritance of specifications
The combining of specifications of overridden and overriding methods to 
create a composite specification has been revised to match the semantics
specified for JML, as described in @ref{Specifications and inheritance}.

@node non null on formal parameters and results of routines, monitored by, inheritance of specifications, Incompatibilities-escjava
@subsection non_null on formal parameters and results of routines
The rules and meaning of @code{non_null} in the presence of inheritance
is altered as described in @ref{Inheritance and non_null}.

@c ----------------------------------------------------------------------------
@node monitored by, readable if, non null on formal parameters and results of routines, Incompatibilities-escjava
@subsection monitored_by
ESC/Java2 agrees with ESC/Java in the implementation of @code{monitored_by}.
However, this keyword is deprecated in JML in favor of @code{monitors_for}.
It may at some time be deprecated in ESC/Java2 as well.
[[[ Check this. ]]]

@c ----------------------------------------------------------------------------
@node readable if, old style initially, monitored by, Incompatibilities-escjava
@subsection readable_if
[[[ Discussion needed ]]]

@c ----------------------------------------------------------------------------
@node old style initially, semicolon termination, readable if, Incompatibilities-escjava
@subsection initially (old style)
ESC/Java1 had a field declaration annotation that was a modifier of the field
declaration itself.  JML has replaced that with a class level declaration
(similar to the invariant) clause that states an assertion that must be 
true of objects immediately after construction.  The old form is 
deprecated in JML but supported still in ESC/Java2.

@c ----------------------------------------------------------------------------
@node semicolon termination, Routine bodies in spec files, old style initially, Incompatibilities-escjava
@subsection semicolon termination
The original ESC/Java did not allow, and later tolerated, termination of
clauses by semicolons.  JML requires this.  ESC/Java2 issues a caution if
a required semicolon is not present (@pxref{Terminating semicolons}).

@c ----------------------------------------------------------------------------
@node Routine bodies in spec files,  , semicolon termination, Incompatibilities-escjava
@subsection Routine bodies in spec files
The original ESC/Java allowed routines declared in specification files to have
bodies, which were then checked.  ESC/Java2 allows bodies for Java 
declarations only in .java files.  Model methods, model constructors, and
routines in model classes may have bodies in at most one specification file.
[[[ Check the behavior of JML. ]]]

@c ----------------------------------------------------------------------------
@node Non-JML features, JML features needing clarification, Incompatibilities-escjava, Incompatibilities
@section Non-JML features in ESC/Java2

There are some syntactic constructs accepted by ESC/Java and continue to be 
accepted by ESC/Java2 (or are additions in ESC/Java2) that are not part of JML.

[[[ discussion needed - have not checked how some of these are used in ESC/Java, so
they may not be relevant to the discussion here.]]]

@menu
* annotation comments::         
* order of clauses::            
* splitting of annotations::    
* helper::                      
* typeof applied to primitive types::  
* unreachable-nonJML::          
* notmodified::                 
* specifications of default constructor::  
* loop predicate::              
* skolem constant::             
* still deferred::              
* writable deferred::           
* writable if - nonJML::        
* readable if - nonJML::        
* monitored by - nonJML::       
* dttfsa::                      
* uninitialized::               
* placement of annotations::    
* semicolon termination - nonJML::  
* need for the field::          
* omission of method bodies::   
* Errors and cautions::         
* membership in lockset::       
@end menu

@c ----------------------------------------------------------------------------
@node annotation comments, order of clauses, Non-JML features, Non-JML features
@subsection annotation comments beginning with @code{//-@@} or @code{/*-@@}
ESC/Java2 allows annotation comments to begin with either
@code{//-@@} or @code{/*-@@} to allow for experimental or old ESC/Java
constructs that are not part of JML.

@node order of clauses, splitting of annotations, annotation comments, Non-JML features
@subsection order of clauses
[[[ comment needed ]]]

@node splitting of annotations, helper, order of clauses, Non-JML features
@subsection splitting of annotations
[[[ comment needed ]]]

@node helper, typeof applied to primitive types, splitting of annotations, Non-JML features
@subsection helper annotations
JML and ESC/Java2 differ in which sorts of routines are allowed to be
@code{helper} routines.

@node typeof applied to primitive types, unreachable-nonJML, helper, Non-JML features
@subsection \typeof applied to primitive types
[[[ Is this in JML ? ]]]

@node unreachable-nonJML, notmodified, typeof applied to primitive types, Non-JML features
@subsection  unreachable
There is no @code{unreachable} annotation in JML.

@node notmodified, specifications of default constructor, unreachable-nonJML, Non-JML features
@subsection \not_modified
ESC/Java2 allows arbitrary pure expressions as arguments to 
@code{\not_modified}; JML
only allows store references.

@node specifications of default constructor, loop predicate, notmodified, Non-JML features
@subsection specifications of default constructor
[[[ needs description ]]]

@node loop predicate, skolem constant, specifications of default constructor, Non-JML features
@subsection  loop_predicate
[[[ discussion needed ]]]

@node skolem constant, still deferred, loop predicate, Non-JML features
@subsection  skolem_constant
[[[ discussion needed ]]]

@node still deferred, writable deferred, skolem constant, Non-JML features
@subsection  still_deferred
[[[ discussion needed ]]]

@node writable deferred, writable if - nonJML, still deferred, Non-JML features
@subsection  writable_deferred
[[[ discussion needed ]]]

@node writable if - nonJML, readable if - nonJML, writable deferred, Non-JML features
@subsection  writable_if
[[[ discussion needed ]]]

@node readable if - nonJML, monitored by - nonJML, writable if - nonJML, Non-JML features
@subsection  readable_if
[[[ discussion needed ]]]

@node monitored by - nonJML, dttfsa, readable if - nonJML, Non-JML features
@subsection  monitored_by
ESC/Java2 still supports the @code{monitored_by} field annotation, as in 
ESC/Java, although this form has been deprecated in JML.

@node dttfsa, uninitialized, monitored by - nonJML, Non-JML features
@subsection  dttfsa
[[[ discussion needed ]]]

@node uninitialized, placement of annotations, dttfsa, Non-JML features
@subsection  uninitialized
ESC/Java2 and ESC/Java include the @code{uninitialized} annotation.  This is not 
present in JML.

@node placement of annotations, semicolon termination - nonJML, uninitialized, Non-JML features
@subsection  placement of annotations

ESC/Java2 maintains some of ESC/Java's features with regard to
alternate placement of annotations.  The customary location for
annotations is just prior to the declaration to which they apply (with
the exception of the @code{in} and @code{maps} assertions for field
declarations).  ESC/Java2 allows in addition the following.

@itemize @bullet

@item Annotations may be placed just prior to a routine's body - either 
just before the opening @{ or the ; marking an absent body.
@*@strong{Example:}
@example
	public void m() //@@ pure ensures true;
	@{@}
@end example

@item Annotations on field declarations may be placed between the initializer
for the field and the terminating semicolon.  This syntax also applies to
local variable declarations within routine bodies.
@*@strong{Example:}
@example
	public Object o = new Object() /*@@ non_null */;
@end example

@item Annotations on formal parameters may be placed between the identifier
and the following comma or right parenthesis.
@*@strong{Example:}
@example
	public void m(Object o /*@@ non_null*/, Object oo /*@@ non_null */);
@end example

@end itemize

JML does not recognize this syntax, with the exception of specification
clauses (but not modifiers such as @code{pure}, @code{non_null}, or
@code{nullable}) placed just prior to the routine body.  Consequently
using this style of annotation writing is discouraged in ESC/Java2.  [[[
Should we generate a caution?]]]

@node semicolon termination - nonJML, need for the field, placement of annotations, Non-JML features
@subsection semicolon termination
JML requires annotations to be terminated with semicolons.  
ESC/Java2 will warn about missing semicolons, but does not require them.

@node need for the field, omission of method bodies, semicolon termination - nonJML, Non-JML features
@subsection need for the field, method, constructor keywords
[[[ ESC/Java2 parses @code{non_null} and @code{nullable} in method declarations ]]]

@node omission of method bodies, Errors and cautions, need for the field, Non-JML features
@subsection omission of method bodies
ESC/Java2 does not require bodies of methods and constructors to be present, even in
.java files.  The JML checker does require such bodies in .java files, although not
in specification files with other suffixes.

@node Errors and cautions, membership in lockset, omission of method bodies, Non-JML features
@subsection Errors and cautions
Some JML errors are reported as cautions by ESC/Java2.  This enables as much 
checking to be performed as possible in cases in which the correction to the error
seems obvious.

@node membership in lockset,  , Errors and cautions, Non-JML features
@subsection membership in lockset
The features associated with locks and the sets of locks associated with an
object were part of the original ESC/Java and only recently added to JML.
JML needs documentation of these features (\lockset, \max, and membership
in a lockset); JML does not yet include the membership in a lockset operation.

@c ----------------------------------------------------------------------------
@node JML features needing clarification, Extensions, Non-JML features, Incompatibilities
@section JML features needing clarification

[[[ Need discussion of these ]]]

@menu
* model programs::              
* callable-clarification::      
* when-clarification::          
* initializer-clarification::   
* desugaring of forall::        
* weakly::                      
* henceby issues::              
* use of result in resources clauses::  
* instance fields::             
* splitting annotations::       
* typeof-clarification::        
@end menu

@node model programs, callable-clarification, JML features needing clarification, JML features needing clarification
@subsection model programs

@node callable-clarification, when-clarification, model programs, JML features needing clarification
@subsection callable, accessible

@node when-clarification, initializer-clarification, callable-clarification, JML features needing clarification
@subsection when, measured_by

@node initializer-clarification, desugaring of forall, when-clarification, JML features needing clarification
@subsection initializer, static_initializer

@node desugaring of forall, weakly, initializer-clarification, JML features needing clarification
@subsection desugaring of forall

@node weakly, henceby issues, desugaring of forall, JML features needing clarification
@subsection weakly

@node henceby issues, use of result in resources clauses, weakly, JML features needing clarification
@subsection hence_by

@node use of result in resources clauses, instance fields, henceby issues, JML features needing clarification
@subsection use of \result in duration and working_space clauses

@node instance fields, splitting annotations, use of result in resources clauses, JML features needing clarification
@subsection instance fields and this in constructor preconditions

@node splitting annotations, typeof-clarification, instance fields, JML features needing clarification
@subsection rules about splitting annotations across comments

@node typeof-clarification,  , splitting annotations, JML features needing clarification
@subsection \typeof applied to primitive types

@c ----------------------------------------------------------------------------
@node Extensions,  , JML features needing clarification, Incompatibilities
@section Desired extensions

This is a list of some discussed but not resolved potential
extensions to current JML.
@itemize @bullet
@item Changing the order of suffixes so that either jml or spec comes before 
java.

@item Allow modifies clauses outside of @{| |@} pairs; the clause would be
distributed across the nested specifications just like requires is.

@item Allow specifications on statements within a body of a routine.

@item Definite definition of \elemtype applied to a non-array.

@end itemize

@c --------- chapter Modifier Summary -----------
@node Modifier Summary, Bibliography, Incompatibilities, Top
@c  node-name,  next,  previous,  up
@appendix Modifier Summary
This table summarizes which Java and JML modifiers may be used in 
various grammatical contexts.

@multitable @columnfractions .5 .05 .2 .05 .22

@item Grammatical construct @tab @tab Java modifiers @tab @tab JML modifiers

@item All modifiers
@tab
@tab @code{public protected private abstract static final synchronized transient volatile native strictfp}
@tab
@tab @code{spec_public spec_protected model ghost pure instance helper non_null nullable non_null_by_default nullable_by_default}

@item

@item Class declaration
@tab
@tab @code{public final abstract strictfp}
@tab
@tab @code{pure model}

@item

@item Interface declaration
@tab
@tab @code{public strictfp}
@tab
@tab @code{pure model}

@item

@item Nested Class declaration
@tab
@tab @code{public protected private static final abstract strictfp}
@tab
@tab @code{spec_public spec_protected model pure}

@item

@item Nested interface declaration
@tab
@tab @code{public protected private static strictfp}
@tab
@tab @code{spec_public spec_protected model pure}

@item

@item Local Class (and local model class) declaration
@tab
@tab @code{final abstract strictfp}
@tab
@tab @code{pure model}

@item

@item Type specification (e.g. invariant)
@tab
@tab @code{public protected private static}
@tab
@tab -

@item

@item Field declaration
@tab
@tab @code{public protected private final volatile transient static}
@tab
@tab @code{spec_public spec_protected non_null nullable instance monitored}

@item

@item Ghost Field declaration
@tab
@tab @code{public protected private static final}
@tab
@tab @code{non_null nullable instance monitored}

@item

@item Model Field declaration
@tab
@tab @code{public protected private static}
@tab
@tab @code{non_null nullable instance}

@item

@item Method declaration
@tab
@tab @code{public protected private abstract final static synchronized native strictfp}
@tab
@tab @code{spec_public spec_protected pure non_null nullable helper }

@item


@item Constructor declaration
@tab
@tab @code{public protected private}
@tab
@tab @code{spec_public spec_protected helper pure}

@item

@item Model method
@tab
@tab @code{public protected private abstract static final synchronized strictfp}
@tab
@tab @code{pure non_null nullable helper}

@item

@item Model constructor
@tab
@tab @code{public protected private}
@tab
@tab @code{pure helper}

@item

@item Java Initialization block 
@tab
@tab @code{static} ???
@tab
@tab ???

@item JML initializer and static_initializer annotation 
@tab
@tab ???
@tab
@tab ???

@item

@item Formal parameter 
@tab
@tab @code{final}
@tab
@tab @code{non_null nullable}

@item

@item Local variable and local ghost variable declaration
@tab
@tab @code{final}
@tab
@tab @code{ghost non_null nullable uninitialized}

@end multitable

Note that within interfaces, fields are implicitly public, static and final.
Ghost and model fields are implicitly public and static, though they may be
declared instance (i.e. not static).
@c ----------------------------------------------------------------
@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@node Bibliography, Concept Index, Modifier Summary, Top
@unnumbered Bibliography

@table @asis

@item [Flanagan-etal02]
C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, R. Stata,
``Extended Static Checking for Java''. 
Proceedings of the ACM SIGPLAN 2002 Conference on Programming
Language Design and Implementation.  June, 2002.

@item [LeavensBakerRuby02]
G. T. Leavens, A. L. Baker, C. Ruby.
``Preliminary Design of JML: A Behavioral Interface Specification Language
for Java''.  Iowa State University, Department of Computer Science, TR 98-06t.
December, 2002.
Available from @url{ftp://ftp.cs.iastate.edu/pub/techreports/TR98-06/TR.ps.gz}.

@item [Leavens-etal03]
G. T. Leavens, E. Poll, C. Clifton, Y. Cheon, C. Ruby, D. R. Cok, J. Kiniry.
JML Reference Manual.  Available from @url{http://www.jmlspecs.org}.
@end table



@node  Concept Index,  , Bibliography, Top
@c node-name, next, previous, up
@unnumbered Concept Index

[[[ The index needs a lot of work. ]]]

@printindex cp

@bye
