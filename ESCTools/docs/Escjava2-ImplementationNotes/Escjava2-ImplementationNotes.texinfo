\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename Escjava2-ImplementationNotes.info
@settitle ESC/Java2 Implementation Notes
@c @setchapternewpage odd
@c %**end of header

@c FIXME - all the node lines need fixing
@c FIXME - indexing needs major work

@comment ----- title and copyright pages
@titlepage
@title ESC/Java2 Implementation Notes
@subtitle VERY MUCH A PRELIMINARY, INCOMPLETE DRAFT

@author by David R. Cok

@sp 1


@center July 2003


@sp 2

@b{Keywords:}  Behavioral interface specification, Java,
JML, Escjava, ESC/Java, model-based specification, assertion,
precondition, postcondition, frame.

@b{2000 CR Categories:}
D.2.1 [@i{Software Engineering}]
        Requirements/Specifications --- languages, tools, theory,
        Larch, Eiffel, JML, ESC/Java;
D.2.4 [@i{Software Engineering}]
        Software/Program Verification --- assertion checkers, class invariants,
        formal methods, programming by contract;
D.2.7 [@i{Software Engineering}]
        Distribution and Maintenance --- documentation;
F.3.1 [@i{Logics and Meanings of Programs}]
        Specifying and Verifying and Reasoning about Programs ---
                assertions, invariants, logics of programs,
                pre- and post-conditions, specification techniques.

@sp 1

Copyright @copyright{} 2003 David R. Cok


@sp 2

@center cok@@frontiernet.net
@end titlepage

@contents

@synindex vr cp
@synindex fn cp
@synindex ky cp
@synindex tp cp

@c node  Top, Introduction, (dir), (dir)

@comment FIXME - the menu goes here


@c ------ chapter Introduction --------
@c node Introduction, Acknowledgements, Top, Top
@c  node-name,  next,  previous,  up
@chapter Introduction

@c ------ section Motivation and Background --------
@c node Motivation and Background, Acknowledgements, Top, Top
@c  node-name,  next,  previous,  up
@section Motivation and Background


ESC/Java2 extends the pioneering work on ESC/Java by a group at the Systems
 Research Center at DEC, later Compaq, now HP [@url{www.research.compaq.com}]. 
Esc/java parses 
JML-like annotations in a Java program and warns, in a modular way, about
annotations that may not be justified given the Java source of given
classes and the specifications of other classes.  The tool works accurately 
enough and
fast enough that is has been found to be a useful tool.
Its usefulness is diminished by limitations in the kind of annotations that it can 
parse and check and also in that its annotation language is similar to but 
is neither a subset nor a superset of JML.

The goal of the ESC/Java2 work is to extend the use of Esc/Java by
@enumerate a
@item updating the parser of Esc/Java so that it is consistent with the current definition of JML;
@item packaging the updated tool so that it is more easily available to a 
larger set of users,
 consistent with the source code license provisions of the Esc/Java source code;
@item and extending, where possible, the range of JML annotations that can be checked by Esc/Java.
@end enumerate

This document records the status of this implementation.  It is not intended to be a
tutorial or a reference guide.  Rather it records the status of the features of JML:
the status of their implementation in ESC/Java2,
the degree to which the annotation is
logically checked, and any differences between ESC/Java2 and JML.
@itemize @bullet
@item More detailed information on JML is available at the web site 
@url{www.jmlspecs.org}; the details of the JML definition are published in 
"Preliminary Design of JML" (Leavens, Baker, Ruby) and in 
"The JML Reference Manual" (Leavens, Poll, Clifton, Cheon, Ruby),
both available from the JML website.
@item Information on the original ESC/Java tool, 
nearly all of which still applies, is provided in "ESC/Java User's Manual", 
SRC Technical note 2000-002 (Leino, Nelson, Saxe), 
available at @url{gatekeeper.dec.com/pub/DEC/SRC/technical-notes/SRC-2000-002.html}.
@end itemize

@c ------ section Acknowledgements --------
@c node  Acknowledgements, ???, Top, Top
@c  node-name,  next,  previous,  up
@section Acknowledgements


To date, the work on ESC/Java2 has been carried out primarily by Joe Kiniry
(@url{www.kindsoftware.com}) and David Cok.  Patrice Chalin and colleagues 
have contributed particularly to the facilities for safe numeric reasoning. 
Gary Leavens has provided guidance on the current and future state of JML.  
K. Rustan M. Leino has provided advice with respect to the original ESC/Java.

The work of producing ESC/Java2 stands on the very much more considerable 
effort of 
the ESC/Java team (led by Leino at DEC SRC) in conceiving of and 
producing ESC/Java, Simplify and related tools in the first place. 

@c ------ section Dependencies and license restrictions --------
@c node  Dependencies and license restrictions, ???, Top, Top
@c  node-name,  next,  previous,  up
@section Dependencies and license restrictions


The ESC/Java2 tool relies on the following software packages that are separately 
available and may have their own license restrictions.
@itemize @bullet
@cindex ESC/Java
@cindex Simplify
@item The original source for ESC/Java, Simplify and related tools, available at 
@uref{www.research.compaq.com/downloads.html}.

@cindex Mocha
@item Part of the Mocha tool from UCBerkeley (optional), available at
@uref{www-cad.eecs.berkeley.edu/~mocha/download/j-mocha}.

@cindex JUnit
@item The testing framework JUnit version 3.8.1, available at 
@uref{www.junit.org}.

@cindex JML
@item ESC/Java2 does not depend on the JML tool set, but it is useful to use the
two in combination.  JML is available at @uref{www.jmlspecs.org}.
@end itemize

@c ---------Contacts ------------------
@section Contacts and information

Further information about JML and ESC/Java2 can be obtained from these sources.

@itemize @bullet
@item The JML web site:  @uref{www.jmlspecs.org}
@item The JML project on sourceforge: @uref{sourceforge.net/projects/jmlspecs}
@item The JML interest mailing list on sourceforge: @email{jmlspecs-interest@@lists.sourceforge.net}
@item The JML development mailing list on sourceforge: @email{jmlspecs-developers@@lists.sourceforge.net}
@item The ESC/Java2 mailing list on sourceforge: @email{jmlspecs-escjava@@lists.sourceforge.net}
@item The multijava website: @uref{www.multijava.org}
@item The multijava project on sourceforge: @uref{sourceforge.net/projects/multijava}
@end itemize

@c ------ chapter Status of JML features --------
@c node  Status of JML features, ???, Top, Top
@c  node-name,  next,  previous,  up
@chapter Status of JML features

@section Error checking
ESC/Java2 will parse correctly formatted JML files, with the exceptions 
described below.  
JML files must be correct Java source with correctly formatted annotations, which
appear to Java as comments.  Although ESC/Java2 does some error reporting 
during parsing,
it does not report all parsing errors in either Java or JML, 
nor does it necessarily 
terminate normally if the input is not legal Java/JML.  There are a number of tools 
supporting JML that can be used to check the well-formedness of the JML annotations
in a file; a Java compiler can be used to check the format of the Java source code.

The authors encourage any report of a legal Java/JML file that ESC/Java2 will not 
parse.  Furthermore, despite the caveat above, the authors do want ESC/Java2 to be a
useful tool; hence they are interested in examples of illegal Java/JML source code 
that cause abnormal termination and in examples in which the absence of error 
messages or the occurrence of an inappropriate error message is particularly
misleading to the user.

@cindex error messages
@cindex fatal errors
@cindex cautions
@cindex warnings
ESC/Java2 continues ESC/Java's use of four levels of error messages:
@itemize @bullet
@item  @strong{fatal} errors are problems (usually invalid syntax) that prevent 
Escjava from proceding further in parsing and checking files;
@item  @strong{errors} indicate illegally formed input files, though processing may
continue to find other errors or even to attempt static checking of the files 
(errors or checks subsequent to the first problem may be erroneous as a result of
earlier problems);
@item  @strong{cautions} indicate situations that are not illegal, but may be
misleading to the user - a common example is features that are parsed 
but not checked;
@item  @strong{warnings} indicate situations in which the static checking phase could
not determine that annotation specifications were maintained, such as an inability
to determine that an object reference is non-Null when it is dereferenced.
@end itemize


@cindex file names
@cindex suffixes
@section File naming
- suffixes, finding files in the file system

??? FIXME


@section Format of annotations

@cindex format of annotations
@cindex annotation markers
@cindex comments, annotation
@cindex @code{//@@}
@cindex @code{/*@@}
@cindex @code{/*+@@}
@cindex @code{*/}
@cindex @code{@@*/}
@cindex @code{@@+*/}
@itemize @bullet
@item @strong{Comment format:} JML annotations are included in a Java program as 
specially formatted comments.  
In particular, JML annotations recognized by ESC/Java2 are either
@itemize @bullet

@item single-line comments beginning with @code{//@@}, or

@item multi-line comments enclosed between @code{/*@@} and either 
@code{*/} or @code{@@*/} [ESC/Java2 allows multiple @@ symbols before
the closing @code{*/} - FIXME - doees JML?], or

@cindex @code{<esc>}
@cindex @code{<ESC>}
@cindex @code{<jml>}
@cindex @code{<JML>}

@item annotations embedded in a javadoc comment between any of the 
four pairs of markers
@code{<esc>} and @code{</esc>}, 
@code{<ESC>} and @code{</ESC>}, 
@code{<jml>} and @code{</jml>}, or
@code{<JML>} and @code{</JML>}.
The original ESC/Java only recognized the first pair.  These annotation pairs
may not be nested, but there may be multiple annotations in sequence.  ESC/Java2
and JML do not restrict where in the javadoc comment an annotation may occur.
However, javadoc requires the annotation to be
a part of the textual description and to preceed any tag descriptions that are
part of the comment.  The jmldoc tool allows multiple annotations to be intermixed
with the tag descriptions.  Neither ESC/Java2 or JML tools require the annotation
to be enclosed between @code{<pre>} and @code{</pre>} tags;
however, if you expect reasonable formatting in a javadoc produced HTML
page, you will likely wish to do so.  The jmldoc tool does not require 
@code{<pre>} and @code{</pre>} tags to produce good
formatting.

Status:



@end itemize
Note that JML recognizes additional annotations in these forms:
@itemize @bullet

@item single-line comments beginning with @code{//+@@} [FIXME - multiple @@s?] ;

@item multi-line comments enclosed between @code{/*+@@} and either 
@code{*/} or @code{@@*/} or @code{@@+*/}  [FIXME - multiple @@s?];

@end itemize
These latter forms are part of JML but not escjava to allow for syntax defined by
JML but not recognized by escjava.  It is hoped that the result of this work on
ESC/Java2 will diminish the need for the JML-only comments.  They may remain useful
as a way to retain JML annotations that are not processed (though they could be)
by ESC/Java2.

@item @strong{-parsePlus option:} The @code{-parsePlus} command-line option
instructs ESC/Java2 to parse all annotations recognized by JML.  This is used mainly
in testing to find and attempt to process the JML-only annotations, but may be
 useful in other circumstances.

@item @strong{Initial '@@' symbols in annotations:} Within a multi-line annotation,
 a sequence of '@@' symbols
that follow whitespace at the beginning of a line are treated as white space.
Within an annotation embedded in a Javadoc comment, a sequence of '*' symbols
(but not '@@' symbols)
that follow whitespace at the beginning of a line are treated as white space.

@item @strong{Splitting annotations across comments:} 
 JML will correctly parse and process
 annotations that are split across multiple comments (e.g. a multi-line annotation
 in which each line begins with @code{//@@}).  ESC/Java2 expects an annotation
 to be entirely contained within one single- or multi-line comment.  The latter
 behavior is 'correct' JML; however, the JML tools will correctly process and not
 warn about multi-comment annotations. To be specific, ESC/Java2 requires that any
 clause beginning with a keyword and ending with a semicolon must be contained 
 within one annotation comment; ESC/Java2 requires that model methods, model
 constructors and model programs be defined within one annotation comment;
 it also requires that modifiers 
 (e.g. @code{public}, @code{non_null}) be in the
 same comment as a JML annotation (e.g. @code{behavior} or model method) that it modifies.
  Thus, @code{requires} and @code{ensures} clauses must be within
 an annotation; individual modifiers such as @code{pure}, @code{normal_behavior},
 @code{also}, @code{@{|}
 or @code{implies_that} may be in annotations by themselves.
 [[[ FIXME - JML rules need to be clarified.]]]
 
@item @strong{Multiple annotations per comment:} It is legal JML to include multiple
annotations per comment; in fact it is common practice and good style to include
many related annotations within one multi-line comment.  

@item @strong{Terminating semicolons:} JML requires annotations to be terminated by
semicolons.  The original ESC/Java did not.  The absence of semicolons is illegal
JML, but is sometimes tolerated by ESC/Java2. ESC/Java2 will warn if a semicolon
is missing.

@end itemize



@section Compilation Unit annotations
Compilation Unit annotations are placed prior to the declaration of any type within 
a file.

@subsection refine statements
@itemize @bullet
@item @strong{Description:} A JML refine statement indicates that the containing 
compilation unit adds additional
specifications to those contained in the referenced file.  If present, it must
be located after any Java package statement and before any Java or model import 
statements.
It has the form
@*@center{@code{//@@ refine "}@emph{filename}@code{";}}
@*The given name must have the same name with a different suffix as the current file.
[see the discussion on suffixes...] [Location of refine statement in CU - FIXME] [FIXME - this has changed... define the refinement sequence]


@item @strong{Status:} The refine statement is implemented in ESC/Java2.

@item @strong{Differences from JML or Java:} ... describe differences.... FIXME - there is currently a difference in search order.

@end itemize

@subsection model import statements
@itemize @bullet
@item @strong{Description:}
A model import statement has the form
@*@center{@code{//@@ model }@emph{java-import-statement}@code{;}}
@*Note that simply including a Java import statement in an annotation is not legal JML
(in other words, omitting the @strong{model} keyword).
A model import statement may occur wherever a Java import statement may be placed.
A model import statement introduces types that are used only by annotations.
Annotations may also use types introduced by Java import statements.

@item @strong{Status:}  Model import statements are fully implemented.

@item @strong{Differences from JML or Java:}  This feature is implemented in 
ESC/Java2 as it is in JML.  However, both have the following problem.  The
model import statements are
 parsed by JML tools and by
ESC/Java2 as if they were Java import statements.  Thus they may introduce or resolve
an ambiguity in class name resolution of names used in the Java source code in a
compilation unit, or cause misinterpretation of a type name.  For example, in
@code{
import java.io.*;
//@@ model import myclasses.File;
public class C extends File @{@}
}
the use of @code{File} in the Java code will be silently 
altered by the presence of the 
model import statement.  Similarly, in
@code{
import java.io.*;
//@@ model import myclasses.*; // class myclasses.File exists
public class C extends File @{@}
}
the use of @code{File} in the Java code is made ambiguous by the model import
declaration.  These are as yet unresolved bugs.


@item @strong{Comment:} Though legal, there is no point to a statement of the form
@center{@code{/*@@ model @@*/ import }@emph{filename}@code{;}}
@* This is equivalent to simply using a Java import statement.
@end itemize



@section Type modifiers
These modifiers may appear (within an annotation) as one of the modifiers that
may be part of the definition of a class or interface, preceeding the 
@code{class} or @code{interface} keyword.
@subsection pure
@itemize @bullet
@item @strong{Description:} The @code{pure} modifier, when applied to a class or
interface, indicates that every method of the class or interface is @code{pure}.
Thus, no method may modify variables other than those declared within the body
of the routine.  Constructors may only modify the fields of the object.

@item @strong{Status:} Parsed and fully implemented.

@item @strong{Differences from JML or Java:} None.

@item @strong{Comment:} A method inherits purity from the methods it overrides;
that is, if an overridden method is pure, the overriding method will be pure,
whether or not it is declared pure.  This is not the case for classes or 
or interfaces.  A subclass may add non-pure methods, even if it has a pure
superclass.  Declaring a class pure is precisely equivalent to declaring all of its
methods and constructors pure. [FIXME - Verify with JML] 

@end itemize

@subsection Privacy modifiers
@itemize @bullet
@item @strong{Description:} description.... (including spec_public, spec_protected)

@item @strong{Status:} status.... FIXME

@item @strong{Differences from JML or Java:} bugs...

@end itemize

@subsection weakly

@itemize @bullet
@item @strong{Description:} This annotation is used to modify super classes and 
super interfaces in a class
or interface declaration.  An example of its syntax is this:
@center{@code{public class A extends B /*@@ weakly */ implements C /*@@ weakly */, D /*@@ weakly */ @{ ... @}}}

@item @strong{Status:} Parsed and ignored by ESC/Java2.

@item @strong{Differences from JML or Java:} Parsed but ignored by ESC/Java2.
  This 
feature is not present in ESC/Java.

@end itemize

@subsection other Java modifiers

@itemize @bullet
@item @strong{Description:} All the other usual Java modifiers permitted on a class
(final, static, ...???FIXME) 
are permitted (outside of annotations)
and have their usual meaning.

@item @strong{Status:} All parsed and implemented. - which are they? is this correct? FIXME

@item @strong{Differences from JML or Java:} None.

@end itemize



@section Annotations pertinent to a class or interface
These annotations may appear anywhere a type declaration 
within a class or interface may appear.  They define specification-only
ghost or model fields of the type and specifications that apply to
the whole object (not just to individual methods).

@subsection Ghost fields
@itemize @bullet
@item @strong{Description:} A ghost field is a field of the object that can hold a
value or reference to an object, but is used only in specifications.  Its
value is changed using the @code{set} annotation within the body of
a method or constructor.  A ghost field may have an initializer, just as a 
Java program field may, but the ghost field may be initialized in only one
compilation unit of a refinement sequence.  A ghost field may have modifiers that
a Java field declaration would have ( what are they?? FIXME) as well as the JML
modifiers @code{non_null} and @code{instance}.

An interface may also declare ghost fields; these fields may be 
referenced by annotations in the interface or its subtypes.
  Such ghost fields are by default static,
but may be modified by the JML modifier @code{instance}, in which case they are
a field of every object that implements the interface.


@item @strong{Status:} Ghost fields are completely supported.

@item @strong{Differences from JML or Java:} Check that that rule about at most one
initialization is actually checked/enforced/correct.  Check on the allegation that
ghsot fields have a different scope than regular fields (in the JML/ESC differences
document).  Check that ghost fields are inherited properly.  How about inherited 
from interfaces.  Verify the behavior of instance fields. CHeck on initializations
(FIXME) [Check that modifiers work.]

@end itemize

@subsection Model fields
@itemize @bullet
@item @strong{Description:} Model fields are declarations within an annotation
prefixed by the modifier @code{model}.  They do not represent actual 
specification fields as do @code{ghost} values.  Rather, their values are either
supplied by an expression in a @code{represents} clause or are constrained by
a boolean condition in a @code{represents} clause.  They are used to supply values
that @emph{model} the behavior of the class.

@item @strong{Status:} Model fields are parsed and used in typechecking.  However,
@code{represents} clauses are not implemented in the static checking within
ESC/Java2; consequently annotations containing model fields are not yet checked.

@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection Model methods
@itemize @bullet
@item @strong{Description:} Model methods are method declarations within an
annotation and prefixed with the modifier @code{model}.  They declare methods that
may be used in model programs and (if pure) in specifications.

@item @strong{Status:} Model methods are parsed and converted to regular Java 
methods within ESC/Java2.  However, the static checking mechanism of ESC/Java is
not able to handle method calls.

@item @strong{Differences from JML or Java:} Model methods are parsed and 
converted to regular Java 
methods within ESC/Java2.  Consequently, ESC/Java2 will not detect their (illegal) 
use within the implementation of a Java method.


@end itemize

@subsection Model constructors
@itemize @bullet
@item @strong{Description:} Model constructors are constructor
 declarations within an
annotation and prefixed with the modifier @code{model}.  They declare 
constructors that
may be used in model programs and (if pure) in specifications.

@item @strong{Status:} Model constructors are parsed and converted to regular Java 
constructors within ESC/Java2.  However, the static checking mechanism of ESC/Java is
not able to handle constructor calls.

@item @strong{Differences from JML or Java:} Model constructors are parsed and 
converted to regular Java 
methods within ESC/Java2.  Consequently, ESC/Java2 will not detect their (illegal) 
use within the implementation of a Java method.

@end itemize

@subsection model class and model interface
@itemize @bullet
@item @strong{Description:} description....

@item @strong{Status:} status....

@item @strong{Differences from JML or Java:} bugs...

@end itemize


@subsection initializer
@itemize @bullet
@item @strong{Description:} Java allows initializer blocks within a type 
declaration.  These are blocks of code contained simply within a pair of
curly braces.  The code is executed when a new object is being created, prior
to any constructor being run.  It is executed in turn (per the order of
declarations in the source file) as the fields of the objects are being initialized.
The JML @code{initializer} keyword is a JML declaration within a type declaration.
It may have specifications (e.g. @code{requires} and @code{ensures} clauses) 
associated with it; those specifications must hold of the object after
after initialization, but prior to any constructors being executed.
The annotations may be associated with the block of Java code directly in source
files that contain such code; in specification files without code, the
@code{initializer} keyword is a stand-in for the block of code itself.

@item @strong{Status:} Not yet parsed or implemented in static checking.

@item @strong{Differences from JML or Java:} None.

@item @strong{Comment:} FIXME - How is a initializer associated with a particular
block of Java code?  Or is there just one JML initializer allowed, and it 
expresses the condition after all the field and initializing code is run?  
The corresponding question applies for static initializers.

@end itemize

@subsection static_initializer
@itemize @bullet
@item @strong{Description:} Java allows static initializer blocks within a type 
declaration.  These are blocks of code contained simply within a pair of
curly braces and having the 
modifier @code{static}.
  The code is executed when the class is loaded, prior
to any object of the class being instantiated.  
It is executed in turn (per the order of static
declarations in the source file) as the static fields of the 
class are being initialized.
The JML @code{static_initializer} keyword is a JML declaration within a type declaration.
It may have specifications (e.g. @code{requires} and @code{ensures} clauses) 
associated with it; those specifications must hold of the class after
after loading, but prior to the instantiation of any objects.
The annotations may be associated with the block of Java code directly in source
files that contain such code; in specification files without code, the
@code{static_initializer} keyword is a stand-in for the block of code itself.

@item @strong{Status:} Not yet parased or implemented in the static checker.

@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection Java method, constructor and field declarations
@itemize @bullet
@item @strong{Description:} These declarations are identical to those defined by
Java.
@item @strong{Status:} Parsed and typechecked fully.  Java fields may be used in
annotations.  Pure methods and constructors
may also be used in annotations, but the static checker
is not yet able to handle annotations containing method and constructor calls.

@item @strong{Differences from JML or Java:} None
@end itemize

@subsection inner or nested Java class or interface
@itemize @bullet
@item @strong{Description:} Java allows declarations of classes and interfaces
within a class or interface.  These are called nested classes or interfaces if
they are @code{static} and inner classes or interfaces if they are not @code{static}.

@item @strong{Status:} Such classes and interfaces are parsed and used in 
typechecking.  However, ESC/Java2 does not check their specifications or recognize
their use in annotations.

@item @strong{Differences from JML or Java:} None

@end itemize

@section Annotation clauses for a class or interface
These clauses provide a specification of the behavior of the class and of objects
of the class.  They may be specified in any order, within an annotation comment,
anywhere an element of a type declaration may appear.

@subsection invariant, invariant_redundantly
@itemize @bullet
@item @strong{Description:} An @code{invariant} clause specifies a boolean 
condition that must hold before and after any call of a (non-helper) method or
constructor of the containing type.

@item @strong{Status:} Fully implemented.

@item @strong{Differences from JML or Java:} None

@end itemize

@subsection constraint, constraint_redundantly
@itemize @bullet
@item @strong{Description:} A @code{constraint} clauses specifies a relation that
must hold between the pre- and post-conditions of any (non-helper) method or
constructor of the containing type.

@item @strong{Status:} Parsed, but not implemented in the static checker.

@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection represents, represents_redundantly
@itemize @bullet
@item @strong{Description:} A @code{represents} clause designates how a model field
is related to the concrete fields of the implementation.

@item @strong{Status:} Parsed, but not utilized by the static checker.

@item @strong{Differences from JML or Java:} None.

@end itemize
@subsection depends, depends_redundantly
@itemize @bullet
@item @strong{Description:} The @strong{depends} clause is obsolete; it is replaced by
@strong{in} and @strong{maps},

@item @strong{Status:} Depends clauses are parsed and ignored.


@end itemize

@subsection axiom
@itemize @bullet
@item @strong{Description:} An @code{axiom} is used to specify a mathematical
property, independent of the implementation of classes or objects.

@item @strong{Status:} This feature was part of ESC/Java, but needs verification 
that it is functional in ESC/Java2.  Fully parsed and typechecked.

@item @strong{Differences from JML or Java:} None.


@end itemize

@subsection initially, initially_redundantly
@itemize @bullet
@item @strong{Description:} This clause specifies a condition that must hold in
the post-state of any constructor (including the default constructor). [[[ FIXME - 
is this a sensible JML definition?  Different constructors have different arguments
and hence different ways to express the post-state.  If this clause expresses the
condition after all initialization, before constructors, how is it different from
the initializer ??? ]]]

@item @strong{Status:} Parsed and typechecked, but not implemented in the static
checker.

@item @strong{Differences from JML or Java:} None.


@end itemize

@subsection readable
@itemize @bullet
@item @strong{Description:} description.... FIXME

@item @strong{Status:} Not implemented.

@item @strong{Differences from JML or Java:} bugs...


@end itemize

@subsection monitors_for
@itemize @bullet
@item @strong{Description:} description....  FIXME

@item @strong{Status:} Not implemented.

@item @strong{Differences from JML or Java:} bugs...


@end itemize

@subsection in, in_redundantly
@itemize @bullet
@item @strong{Description:} description.... FIXME

@item @strong{Status:} Parsed and ignored.

@item @strong{Differences from JML or Java:} bugs...


@end itemize

@subsection maps
@itemize @bullet
@item @strong{Description:} description.... FIXME

@item @strong{Status:} Parsed and ignored.

@item @strong{Differences from JML or Java:} bugs...


@end itemize
@section Modifiers for any element of a type declaration (fields, methods, constructors, types)

@subsection Java privacy modifiers (public, private, protected)
@itemize @bullet
@item @strong{Description:} Java privacy modifiers are fully implemented.  They 
may be applied as well to any class specification clauses (e.g. @code{invariant}).
JML imposes the requirement that the variables and methods used within a 
specification clause must be at least as accessible as the clause itself.  Other
than this checking for access, the privacy modifiers do not affect the operation
of the ESC/Java2 checker.  All specifications are checked, whatever their access 
level.

@item @strong{Status:} Fully implemented.  [[[FIXME - verify that all appropriate errors are issued. ]]]

@item @strong{Differences from JML or Java:} None.

@subsection JML privacy modifiers (spec_public, spec_protected)
@itemize @bullet
@item @strong{Description:} These JML modifiers may be applied to a Java declaration
to indicate the privacy level when the field or method is used in a specification.

@item @strong{Status:} Implemented.  Note that @code{spec_public}, but not
@code{spec_protected} was present in ESC/Java

@item @strong{Differences from JML or Java:} Verify that these work 
and appropriate error messages are issued. 
used in annotations. [[ FIXME ]]


@end itemize

@subsection static and instance
@itemize @bullet
@item @strong{Description:} @code{static} is a Java modifier (which may be used on
JML annotations as well) that indicates the declaration in question applies only
to the class and not to each instance of the class.  @code{instance} is a JML
modifier that indicates the opposite - the declaration in question applies to each
instance of an object of the class.  This is particularly needed in interface
declarations in which the default for JML annotations, just like for Java 
declarations, is that the declaration in question is @code{static}.  

@item @strong{Status:} Not implemented.

@item @strong{Differences from JML or Java:} Using instance causes core dump.


@end itemize


@subsection other Java modifiers (FIXME - which ???)
@itemize @bullet
@item @strong{Description:} description....

@item @strong{Status:} status....

@item @strong{Differences from JML or Java:} bugs...


@end itemize


@section Annotations for a method or constructor
Specifications of the behavior of an individual
 method or constructor typically appear within
an annotation comment, just prior to the declaration of the method or constructor.
The specifications consist of zero or more lightweight or heavyweight behavior 
sections, an optional subclassing contract, an optional @code{implies_that}
section, and an optional @code{for_example} section.

@subsection Lightweight and heavyweight specifications
@item @strong{Description:} Lightweight specifications are simply a series of specification clauses and
correspond to the specification style of ESC/Java. 
Heavyweight specifications are introduced with a @code{behavior},
@code{normal_behavior}, or @code{exceptional_behavior} keyword.  Heavyweight
specifications allow nesting and have different defaults than do lightweight
specifications.

@item @strong{Status:} The lightweight and heavyweight specification forms,
including nesting using @code{@{|} and @code{|@}} and combination with @code{also},
 are 
fully parsed and implemented (though not all clause types, as described below, 
are fully implemented or handled by the static checker).

@item @strong{Differences from JML or Java:} None, except that ESC/Java2 does not
constrain the order of clauses as rigidly as do JML tools.

@item @strong{Comment:} The ESC/Java2 (and ESC/Java) static checker accepts a set
of specification clauses in lightweight form.  In order to handle the nested 
heavyweight form or the combination of specifications using @code{also}, either
within on source file or across a refinement sequence, ESC/Java2 @emph{desugars}
the more complicated syntax into simpler forms.  For this purpose ESC/Java2 largely
follows the desugaring as outlined in [FIXME - provided ref], but it does not need
to desugar all clause types down to one instance of that clause type.  That paper
provides more details on the desugaring process, which is simply outlined here.

The desugaring process first eliminates nesting by replicating and distsributing 
the requires clauses across the nested groups of clauses.  [[[ FIXME -- comment on
forall and old]]]  Also, each lightweight specification, @code{normal_behavior} and 
@code{exceptional_behavior} keyword is desugared into a @code{behavior} specification without defaults.  Specifications from corresponding methods in the
refinement sequence are also combined, connected by @code{also}.
That produces a series of clauses groups, connected by @code{also}, and
each consisting one group of clauses.  ESC/Java2 will accept a single clause group.
However, if we do too much reorganizing of the clauses, we will lose the location
inforemation that is helpful to the user when warning messages are printed. 
Therefore if at this point there is only one clause group, no further changes are
made.  Otherwise, for each clause group a composite precondition predicate is 
formed by taking the conjunction of the predicates in each of the @code{requires}
clauses in that clause group, and making that conjunction the argument of an 
@code{\old} function:
@center{@emph{pre-predicate} = @code{\old(} @emph{p1} @code{&&} @emph{p2} ... @code{)} }.  
Each clause within the clause group is altered by
constraining its action using that conjunction.  Calling that combined predicate
@emph{pre-predicate}, we transform each clause as follows:
@itemize bullet
@item @code{ensures} @emph{pred}@code{;} becomes @code{ensures} @emph{pre-predicate} &code{==>} @emph{pred}@code{;}
@item @code{diverges} @emph{pred}@code{;} becomes @code{diverges} @emph{pre-predicate} &code{==>} @emph{pred}@code{;}
@item @code{modifies} @emph{list}@code{;} where @emph{list} consists of a sequence of elements of the form @emph{item} or @emph{item} @code{if} @emph{pred} becomes a set of separate clauses @code{modifies} @emph{item} @code{if} @emph{pre-predicate} @code{;}  or @code{modifies} @emph{item} @code{if} @emph{pre-predicate} @code{&&} @emph{pred}@code{;}
@item signals -- FIXME complete
@item when -- FIXME complete
@item -- FIXME also the other clauses.
@end itemize
The requires clauses are desugared by replacing all of the requires clauses in all
of the clause groups with a single requires clause whose predicate is the 
disjunction of the conjuctions formed for each clause group, without the enclosing
@code{\\old}.

[[[ FIXME - describe the defaults for missing clause types ]]]

@subsection also

@item @strong{Description:} JML allows multiple specifications for a single method;
these are separated and connected by the @code{also} keyword.  Furthermore, if
the method has additional specifications in an earlier source file in the refinement
sequence or attached to an overridden method in a super class or interface, then
the specification must begin with @code{also} to indicate that there are some
previous specifications of which the reader should be aware.

@item @strong{Status:} The use of @code{also} is completely implemented, with
desugaring occuring as described above.

@item @strong{Differences from JML or Java:} None.

@item @strong{Comment:} This syntax for combining specifications is different than
and not backwards compatible with the syntax used in ESC/Java.  That tools did not
allow combining multiple specifications using @code{also} and did not support
refinement sequences.  Where there was inheritance of specification clauses from a
super class, the keywords @code{also_requires}, @code{also_ensures}, 
@code{also_modifies}, and @code{also_exsures} were required.  These keywords are
not supported in ESC/Java2 and such specifications will need to be rewritten using
the new @code{also} syntax.
[[[ FIXME - this needs to be verified and some helpful error messages supplied.]]]
@end itemize

@subsection model_program

@itemize bullet
@item @strong{Description:} Model programs are an alternate way to provide 
specifications for a method.  Rather than stating logical conditions the pre- and
post-conditions must satisfy, the behavior is specified by a @emph{model program},
which specifies the behavior using typical imperative programming constructs.
However, a model program allows some non-deterministic (and non-executable) 
constructs as well.  Note that there are a number of JML constructs which are only
used within model programs.

@item @strong{Status:} Model programs are parsed and ignored.  They are permitted
as part of a heavyweight specification, as defined by JML.  Any constructs unique
to model programs are simply skipped over by the parser.

@item @strong{Differences from JML or Java:} None.

@item @strong{Comment:} [[[ FIXME - when model programs are supported more fully,
we will need to include descriptions of its unique statement types: 
abrupt_behavior, continues, choose, choose_if, breaks, returns, or ]]]
@end itemize


@subsection subclassing_contract
@itemize bullet
@item @strong{Description:} A subclassing contract is a separate part of a method's
specification containing its own clause types.  It may contain only
@code{measured_by}, @code{callable}, and @code{accessible} clauses.

@item @strong{Status:} Fully parsed and typechecked.  No desugaring is needed as
there are no associated preconditions or nesting.
  The static checker does not do any
reasoning with the clauses of the subclassing contract.

@item @strong{Differences from JML or Java:} None.  The semantics of these clauses
in JML is not well-defined.

@end itemize

@subsection implies_that
@itemize @bullet
@item @strong{Description:} The @code{implies_that} keyword introduces groups of
specifications that are logical consequences of the usual behavior and lightweight
specifications.  They could be used as specifications to be checked in the same
way that the other specifications are.  Alternatively, it could be verified that
they are logical consequences of
 the other specifications and then the results used to provide 
additional useful statements of behavior that help with proofs involving use of
the method or constructor to which the @code{implies_that} specs is associated.

@item @strong{Status:} The specifications in an @code{implies_that} section are
parsed and typechecked, but not used within any static checking.

@item @strong{Differences from JML or Java:} None.

@end itemize


@subsection for_example specification
@itemize @bullet
@item @strong{Description:} The @code{For_example} keyword introduces groups of
specifications that are useful and instructional examples for the reader of
the specifications.  Hence they must be logical consequences of the 
other
specifications.
@item @strong{Status:} The specifications in a @code{for_example} section are
parsed and typechecked, including the @code{example}, @code{normal_example},
and @code{exceptional_example} keywords.
However, they are not used within any static checking, nor is it 
verified that they follow from the other specifications.

@item @strong{Differences from JML or Java:} None.


@end itemize

@subsection Annotations that follow the method or constructor declaration
@itemize @bullet
@item @strong{Description:} ESC/Java allowed specifications to be placed between
a method or constructor declaration and either the semicolon that terminated the
declaration or the opening left brace that began its body.

@item @strong{Status:} This form is not typical JML style, but is fully supported
by ESC/Java2.

@item @strong{Differences from JML or Java:} None.


@end itemize



@section Annotation clauses for a method or constructor

In this section we describe the clause types that may be part of specifications,
including @code{implies_that} and @code{for_example} sections, but not
@code{subclassing_contract} sections.  Note that some clauses have alternate 
keywords reflecting different personal preferences or different usages between
ESC/Java and other JML tools.  These alternates are complete synonyms.



@subsection forall
@itemize @bullet
@item @strong{Description:} description....FIXME

@item @strong{Status:} Not implemented.

@item @strong{Differences from JML or Java:} bugs...


@end itemize

@subsection old
@itemize @bullet
@item @strong{Description:} description....FIXME

@item @strong{Status:} Not implemented.

@item @strong{Differences from JML or Java:} bugs...


@end itemize


@subsection requires, requires_redundantly, pre, pre_redundantly
@itemize @bullet

@item @strong{Description:} A requires clause begins a sequence of specification clauses 
(the other method/constructor clauses described in this section).  The remaining 
clauses must hold whenever the requires clause (or the conjunction of multiple
requires clauses) holds.

@item @strong{Status:} The requires clause is implemented and is utilized by ESC/Java2
in generating verification conditions.
@item @strong{Differences from JML or Java:} ESC/Java2 will warn about the use of
instance variables in the precondition of a constructor (since those variables do
not yet exist prior to allocation); JML does not.
@end itemize

@subsection ensures, ensures_redundantly, post, post_redundantly
@itemize @bullet
@item @strong{Description:} An ensures clause states a condition that must hold in
the post-state of a method or constructor whenever the associated preconditions
hold in the pre-state and the method or constructor exits normally.

@item @strong{Status:} Implemented and used by the static checker.
@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection signals, exsures, signals_redundantly, exsures_redundantly
@itemize @bullet
@item @strong{Description:} A signals clause states a condition that must hold in
the post-state of a method or constructor whenever the associated preconditions
hold in the pre-state and the method or constructor exits with an exception of
(or a subclass of) the designated type.

@item @strong{Status:} Implemented and used by the static checker.  [[[ FIXME - check on desugaring]]]

@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection modifies, modifiable, assignable, modifies_redundantly, modifiable_redundantly, assignable_redundantly
@itemize @bullet
@item @strong{Description:} The modifies clause indicates which memory locations
may be modified by the associated routine when the routine is called in a pre-state
that satisfies the associated preconditions.  In JML a modifies clause may also
have its own conditional predicate that further constrains when the associated 
memory locations may be modified.

@item @strong{Status:} Implemented and used by the static checker.  However, 
ESC/Java2 ignores the conditional predicate of a modifies clause.  Furthermore
ESC/Java2 (like ESC/Java) does not check at all that the modifies clause is valid
for the routine for which it is a specification.  It does use the modifies clause
when reasoning about other routines that use the the routine in question.  
For example, given 

@example
int i;
int k;

//@@ modifies i;
void m() @{ i = 9; @}

//@@ modifies k;
void n() @{ i = 10; @}

void p() @{
        m();
        n();
@}
@end example

@noindent
ESC/Java2 does not complain that routine @code{n} actually does modify the field
@code{i}, even though it claims to modify only @code{k}.  Also, in reasoning about
method @code{p}, it will know that after the call to @code{m}, the field @code{i}
may have a value different from the value before the call of @code{m}; but because
@code{n} claims not to modify @code{i}, ESC/Java2 will presume that the value of
@code{i} after the call of @code{n} is the same as the value before the call.

@item @strong{Differences from JML or Java:} JML has recently implemented data 
groups using the @code{in} and @code{maps} annotations.  These are not yet 
handled by ESC/Java2.


@end itemize

@subsection diverges, diverges_redundantly
@itemize @bullet
@item @strong{Description:} This clause states a predicate that must hold 
(in the pre-state) if the
method never terminates (given that
the associated precondition holds in the pre-state).

@item @strong{Status:} Parsed and typechecked, but not used in any static checking.

@item @strong{Differences from JML or Java:} None.


@end itemize

@subsection when
@itemize @bullet
@item @strong{Description:} description.... FIXME

@item @strong{Status:} Parsed and typechecked, but not used in any static checking.
@item @strong{Differences from JML or Java:} None.

@end itemize

@subsection duration
@itemize @bullet
@item @strong{Description:} description....FIXME

@item @strong{Status:} Parsed and typechecked but not used in any static checking.
@item @strong{Differences from JML or Java:} None.


@end itemize

@subsection working_space
@itemize @bullet
@item @strong{Description:} description....FIXME

@item @strong{Status:} Parsed and typechecked, but not used in any static checking.

@item @strong{Differences from JML or Java:} None.


@end itemize

@subsection accessible
@itemize @bullet
@item @strong{Description:} description....

@item @strong{Status:} status.... FIXME - status unknown

@item @strong{Differences from JML or Java:} bugs...


@end itemize

@subsection Redundancy
@itemize @bullet
@item @strong{Description:} Many clauses have a redundant form, indicated by 
using a keyword with a @strong{_redundantly} suffix.
The intention of these clauses is to indicate specifications that are implied by
other, nonredundant, specifications.  The writer may choose to include the
redundant specifications in order to point out some non-obvious implications of other
specifications, either to facilitate understanding by the reader or to assist the
prover in verifying conclusions.

Note that the implies_that and for_example specifications are additional forms of
redundancy.

The handling of redundant clauses within ESC/Java2 is yet to be defined.

@item @strong{Status:} Currently in ESC/Java2 a command-line option selects 
between using redundant specifications in the same way as nonredundant 
specifications (the default) or ignoring them (when the option @code{-noredundancy}
is chosen).


@section Subclassing contract clauses for a method or constructor
These clause types (and only these) may be present in a subclassing contract 
section of a method's specification.

@subsection measured_by
@itemize @bullet
@item @strong{Description:} description.... FIXME

@item @strong{Status:} Parsed and ignored.

@item @strong{Differences from JML or Java:} bugs...


@end itemize

@subsection callable
@itemize @bullet
@item @strong{Description:} description.... FIXME

@item @strong{Status:} Parsed and ignored.

@item @strong{Differences from JML or Java:} bugs...

@end itemize


@subsection accessible
@itemize @bullet
@item @strong{Description:} description....  FIXME

@item @strong{Status:} Parsed and ignored.

@item @strong{Differences from JML or Java:} bugs...
@end itemize


@section Annotation modifiers for a method or constructor

Annotation modifiers can appear between the last specification clause or  
javadoc comment and the type designator or class name that is part of the method
or constructor.  JML modifiers and Java modifiers may appear in any order.  Though
less common and not the usual style, JML modifiers may also appear after the
method declaration and before the opening left brace of the body or the terminating
semicolon if there is no body.

Besides the modifiers listed here, methods and constructors may also have the
modifiers described in section [FIXME].

@subsection pure
@itemize @bullet
@item @strong{Description:} The @code{pure} modifier applied to a
method indicates that the method does not modify any memory location during
its execution; it may not even modify and then restore the original value.  It is
equivalent to having no modifies clauses at all in the specification,
 except perhaps 
@center{@code{modifies \nothing;}}
In the case of a constructor, the only fields that may be modified are the fields
of the object itself, which are initialized as a result of the action of the 
constructor.  In this case the @code{pure} modifier is equivalent to 
specifications of the form
@center{@code{modifies this.*;}}
Note that if a method is declared pure, then all overriding methods are also pure,
whether or not they have an explicit declaration to that effect.

@item @strong{Status:} Fully supported.

@item @strong{Differences from JML or Java:} None.

@end itemize


@subsection non_null
@itemize @bullet
@item @strong{Description:} Modifying a routine with the @code{non_null} modifier
is valid only for methods that return objects as return values (and not for 
constructors).  The modifier specifies that the return value is never null.  It is
equivalent to a specification of 
@center{@code{ensures \result != null; }}
added to each clause group of the method's specification (but not of a 
superclass's specification of that method).

Note that by inheritance of specifications, any overriding methods will also be
subject to the requirement that the return value be non-null, whether or not the
overriding method is declared @code{non_null}.

Note also that having a superclass declaration of a method without a non_null
modifier, but an overriding method with a non_null declaration
is legal but may lead to confusion.  The specification needs to be understood
by combining the two sets of specifications according to the usual desugaring;
the clause groups associated with the overriding method have
@code{ensures \result != null; }
implictly added to them, whereas the clause groups from the overridden method do
not.

@item @strong{Status:} Parsed and supported by the static checker.

@item @strong{Differences from JML or Java:} None.
@end itemize


@subsection helper
@itemize @bullet
@item @strong{Description:} This modifier indicates that the method or constructor
in question is used as an internal helper routine and that the method or constructor
is therefore not expected to satisfy any of the class-level invariants or
constraints, in either its pre-state or its post-state.  The method or constructor
is still expected to satisfy any specifications (e.g. ensures clauses) that are
explicitly associated with this method or constructor.

@item @strong{Status:} Parsed and supported by the static checker.

@item @strong{Differences from JML or Java:} JML only allows private methods and
constructors to be helpers.  ESC/Java2 also allows any constructors, 
final methods or methods of
final classes to be helpers.  (ESC/Java2's rule is that only routines that cannot
be overridden may be helpers.)
@end itemize


@subsection monitored
@itemize @bullet
@item @strong{Description:} FIXME
@item @strong{Status:} FIXME
@item @strong{Differences from JML or Java:} FIXME
@end itemize


@subsection initialized???
@itemize @bullet
@item @strong{Description:} FIXME
@item @strong{Status:} FIXME
@item @strong{Differences from JML or Java:} FIXME
@end itemize

@subsection Java modifiers (static, public, protected, private, native, synchronized...???)
@itemize @bullet
@item @strong{Description:} FIXME
@item @strong{Status:} FIXME
@item @strong{Differences from JML or Java:} FIXME
@end itemize


@subsection final
@itemize @bullet
@item @strong{Description:} This Java modifier indicates that a method may not be
overridden.
@item @strong{Status:} Fully implemented.  This feature does not affect the
static checking; it simply produces a typechecking error if a final method is
overridden.

@item @strong{Differences from JML or Java:} None.
@end itemize

@section Annotation modifiers for a field declaration

A field declaration may have some JML modifiers and it may be followed by the 
field assertions, which are introduced by the @code{in} and @code{maps}
keywords.   In addition to those
described in section [FIXME], the following modifiers are relevant.

@subsection maps, \into
@itemize @bullet
@item @strong{Description:} FIXME - Note that these *follow* the declaration.
@item @strong{Status:} Not implemented.
@item @strong{Differences from JML or Java:} FIXME
@end itemize


@subsection in
@itemize @bullet
@item @strong{Description:} FIXME - Note that these *follow* the declaration.
@item @strong{Status:} Not implemented.
@item @strong{Differences from JML or Java:} FIXME
@end itemize


@subsection non_null
@itemize @bullet
@item @strong{Description:} This modifier on a field declaration indicates that the
field in question never has a null value.  It is equivalent to a class invariant
of the form
@center{@code{invariant @emph{field} != null}}

@item @strong{Status:} Fully implemented and supported by the static checker.
@item @strong{Differences from JML or Java:} None.
@end itemize

@subsection monitored
@itemize @bullet
@item @strong{Description:} FIXME
@item @strong{Status:} FIXME
@item @strong{Differences from JML or Java:} FIXME
@end itemize

@subsection initialized???
@itemize @bullet
@item @strong{Description:} FIXME
@item @strong{Status:} FIXME
@item @strong{Differences from JML or Java:} FIXME
@end itemize

@subsection uninitialized
@itemize @bullet
@item @strong{Description:} FIXME - ESC/Java does not allow this on a field declaration, but should it?
@item @strong{Status:} FIXME
@item @strong{Differences from JML or Java:} FIXME
@end itemize

@subsection Java modifiers (static, public, protected, private, synchronized...???)
@itemize @bullet
@item @strong{Description:} FIXME
@item @strong{Status:} FIXME
@item @strong{Differences from JML or Java:} FIXME
@end itemize


@section Annotation modifiers for formal parameters

These modifiers may preceed (preferably) or follow 
the type name of a formal parameter within the 
declaration of the method or constructor.

@subsection non_null
@itemize @bullet
@item @strong{Description:} Modifying a formal parameter with a @code{non_null}
modifier is equivalent to adding a precondition stating that the parameter is not
equal to @code{null} and to requiring that any assignment to that variable 
assign a non-null value.  It is only legal for reference types, not for 
primitive types.  The annotation is equivalent to adding a precondition of
@center{@code{requires @emph{param} != null}}
to each of the routine's specification groups.  

(FIXME) FIX THIS: Since a subclass must satisfy the entire specification of its
super classes and super interfaces, if a parameter is not modified as
@code{non_null} in a method declaration (in a class or interface),
 it may not be modified as 
@code{non_null} in any overriding method declaration.  An overriding
declaration may declare a parameter as @code{non_null} only if all of the
overridden declarations of that method so declare the parameter; 
in this case, the modification
of the declaration in the subclass or interface
is redundant and not required, but may be useful for clarity.

@item @strong{Status:} The modifier is parsed, checked and supported by the
static checker.

@item @strong{Differences from JML or Java:} None known. [FIXME - does JML detect 
problems with overriding methods?]

@item @strong{Comment:} The original ESC/Java did not permit a subclass to modify a
formal parameter as @code{non_null} in an overriding declaration.  The 
declarations of the top-most declaration were used for all overriding declarations.
@end itemize

@subsection final
@itemize @bullet
@item @strong{Description:} This Java modifier indicates that a formal parameter
may not be the target of an assignment in the body of the routine.
@item @strong{Status:} Fully implemented.  This feature does not affect the
static checking; it simply produces a typechecking error if a final parameter is
the target of an assignment.  [[[ FIXME - this error is not yet generated. ]]]

@item @strong{Differences from JML or Java:} None.
@end itemize


@section Annotation statements within the body of a method or constructor

@subsection assume, assume_redundantly
@itemize @bullet
@item @strong{Description:} FIXME
@item @strong{Status:} FIXME
@item @strong{Differences from JML or Java:} FIXME
@end itemize


@subsection assert, assert_redundantly
@itemize @bullet
@item @strong{Description:} FIXME
@item @strong{Status:} FIXME
@item @strong{Differences from JML or Java:} FIXME
@end itemize


@subsection set
@itemize @bullet
@item @strong{Description:} FIXME
@item @strong{Status:} FIXME
@item @strong{Differences from JML or Java:} FIXME
@end itemize

@subsection unreachable
@itemize @bullet
@item @strong{Description:} FIXME
@item @strong{Status:} FIXME
@item @strong{Differences from JML or Java:} FIXME
@end itemize


@subsection hence_by
@itemize @bullet
@item @strong{Description:} FIXME
@item @strong{Status:} FIXME
@item @strong{Differences from JML or Java:} FIXME
@end itemize


@subsection loop_invariant, maintaining, loop_invariant_redundantly, maintaining_redundantly
@itemize @bullet
@item @strong{Description:} FIXME
@item @strong{Status:} FIXME
@item @strong{Differences from JML or Java:} FIXME
@end itemize

@subsection decreases, decreasing, decreases_redundantly, decreasing_redundantly
@itemize @bullet
@item @strong{Description:} FIXME
@item @strong{Status:} FIXME
@item @strong{Differences from JML or Java:} FIXME
@end itemize

@subsection ghost declarations
@itemize @bullet
@item @strong{Description:} FIXME
@item @strong{Status:} FIXME
@item @strong{Differences from JML or Java:} FIXME
@end itemize

@section Modifiers that may be applied to local declarations

Declarations within the body of a method, constructor or initialization code 
introduce local variables used only during the execution of that body of code.
Privacy modifiers, @code{static}, and @code{instance} are not applicable to these
declarations.  The following modifiers are allowed.

@subsection non_null

@itemize @bullet
@item @strong{Description:} A local declaration (including ghost and model declarations) 
of a variable of reference type
within the body of a method or 
constructor may be modified with the JML annotation @strong{non_null}.  This
requires that the initial value and any subsequently assigned value for that
variable must not be null.

@item @strong{Status:} Fully implemented (in ESC/Java and ESC/Java2).

@item @strong{Differences from JML or Java:} None.
[[[ FIXME - verify that this is relevant to model fields.]]]

@end itemize

@subsection uninitialized
@itemize @bullet
@item @strong{Description:} This JML modifier may be applied to a local variable
declaration within the body of a block of code.  It indicates that although the
variable has been initialized with an initial value, it should be considered as
uninitialized.  That is, a warning will be issued if its value is used before having
been assigned a new value.

@item @strong{Status:} Implemented (as in ESC/Java).

@item @strong{Differences from JML or Java:} This modifier is not part of JML.
@end itemize

@section Nowarn comments

@itemize @bullet
@item @strong{Description:} 
A nowarn annotation has the form
@center{@code{//@@ nowarn @emph{list-of-warning-types};}}
or simply
@center{@code{//@@ nowarn ;}}
It is associated with the line in the source file on which it is located, rather 
than with a grammatical construct.  It is used to suppress warnings from the
static checker associated with a construct on that line.  If there is no list of
warning types, then all warnings associated with this line are suppressed.  All
the warnings of a given type can also be suppressed using command-line options.
The nowarn annotations have no effect on errors or cautions, since these are
produced by parsing or semantic errors in the source code itself.

@item @strong{Status:} Needs verification (FIXME), but otherwise no change from ESC/Java.

@item @strong{Differences from JML or Java:} JML supports the parsing of these
annotations, but since JML does no static checking, it ignores them.  ESC/Java
did not require a terminating semicolon, but JML does.  ESC/Java2 accepts 
annotations with or without a terminating semicolon; it issues a caution if the
semicolon is missing.
@end itemize


@section JML functions (extensions to expressions)

JML defines a number of new operators, functions, and other constructions for use within expressions
that are part of annotations.

@subsection New operators in JML
[FIXME - describe precendence]

@itemize @bullet
@item @code{<==>} : 
This operator (equivalence) takes two boolean arguments; it returns a boolean value of 
@strong{true} if the two arguments are both @strong{true} or both @strong{false}, and 
@strong{false} otherwise.  
It is fully implemented.
@item @code{<=!=>} : 
This operator (inequivalent) takes two boolean arguments; it returns a boolean value of 
@strong{false} if the two arguments are both @strong{true} or both @strong{false}, and 
@strong{true} otherwise.  @code{(A <==> B)} is equivalent to 
@code{!(A <=!=&gt B)}.
It is fully implemented.
@item @code{==>} : 
This operator (implies) takes two boolean arguments and returns a boolean value of 
@strong{true} if the first is @strong{false} or the second is @strong{true},
and returns @strong{false} if the first is @strong{true} and the second is @strong{false}.  
It is fully implemented.

@cindex @code{<==}
@item @code{<==} : 
This operator (reverse implication, or explies) takes two boolean arguments and returns a boolean value of 
@strong{true} if the second is @strong{false} or the first is @strong{true},
and returns @strong{false} if the second is @strong{true} and the first is @strong{false}.  
@code{(A ==> B)} is equivalent to @code{(B <== A)}.
It is fully implemented.

@cindex @code{<:}
@item @code{<:} : 
This operator takes two arguments of type @strong{\TYPE}; it returns @strong{true}
if the left-hand argument is the same type as or a subtype of the right-hand
argument. 
It is fully implemented.

@cindex @code{<}
@cindex @code{<=}
@item @code{<} , @code{<=} : 
In addition to their usual meaning in Java (and corresponding meanings in JML), the
less-than and less-than-or-equal operators are used to compare locks.  Any object that is listed as a 
monitor (in a @strong{monitors_for} clause) or is identified implicitly or 
explicitly in a Java synchronization statement is a lock,
in addition to its declared use as an object.  In order to reason about deadlocks,
the user must define a partial order on locks and have the code acquire the locks
only in increasing order.  The partial order is defined using @strong{axiom} clauses;
the operators are used to compare locks by this partial order.  
They take two locks as arguments and return
@strong{true} if the left-hand object is less than (or less than or equal to) the right-hand object according to the partial order axioms,
and returns @strong{false} otherwise.
The comparison is independent of whether the locks have actually been acquired; 
the @strong{\lockset} expression supplies that information.  The ESC/Java reference
manual provides additional information and examples about Deadlock and Race detection.
These operators are fully implemented.
@end itemize


@subsection New JML expressions (functions and values)

@itemize @bullet

@cindex \result
@item \result - FIXME

@cindex \old
@item \old - FIXME

@item \not_modified - FIXME

@item \fresh - FIXME
@item \reach - FIXME
@item \duration - FIXME
@item \space - FIXME
@item \working_space - FIXME

@item \nonnullelements - FIXME
@item \typeof - FIXME
@item \elemtype - FIXME
@item \type - FIXME

@item \is_initialized - FIXME
@item \invariant_for - FIXME
@item \lblneg - FIXME
@item \lblpos - FIXME

@item \lockset : This value has type @code{\LockSet}.  The value is the set of objects whose
locks are held by the current thread. 
@*@strong{Status:} This feature is fully implemented by ESC/Java2 (inherited from ESC/Java).

@cindex @code{\max}
@item @code{\max} : This function takes an argument of type @code{\LockSet}.  
It returns an object of type @code{java.lang.Object}.  The result is one of the
elements of the argument; the function satisfies the following for any 
@code{\LockSet} @code{s} and Object @code{o} in @code{s}: @code{o <= \max(s)}.
@*@strong{Status:} This feature is fully implemented by ESC/Java2 (inherited from ESC/Java).


@item Operators for overflow checking : These are under development in JML and are
not yet implemented in ESC/Java2.


@item @emph{informal predicate} - FIXME

@end itemize

@subsection New JML types

JML adds some new types that may be used as type names in declarations of
variables within annotations.

@itemize @bullet
@item @code{\TYPE} : This is a JML type name used to denote the type of type designations.
For example, @code{\typeof} and @code{\type} produce results of type @strong{\TYPE}, 
and the @code{<=} operator takes arguments of type @code{\TYPE}.  Values of type
@code{\TYPE} can also be compared using the @code{==} operator.
@*@strong{Status:} This is fully implemented.  It is equivalent to using the
type @code{java.lang.Class}.  [[[ FIXME - cross comparisons are not implemented. ]]]

@item @code{\bigint} : This is a new type name used in JML to denote an integral type 
equivalent to the mathematical integers.  That is, it has infinite range and no
underflow or overflow as a result of a fixed bit depth.
@*@strong{Status:} The type name is parsed but is equivalent to @strong{long}.

@item @code{\real} : This is a new type name used in JML to denote a type 
equivalent to the mathematical real numbers.  That is, it has infinite range 
and precision and no
underflow, overflow, or rounding error as do @code{float} and @code{double}.
@*@strong{Status:} The type name is parsed but is equivalent to @code{double}.

@end itemize

@cindex quantified expressions
@cindex @code{\forall}
@cindex @code{\exists}
@cindex @code{\num_of}
@cindex @code{\max}
@cindex @code{\min}
@cindex @code{\sum}
@cindex @code{\product}
@subsection quantified expressions - \forall, \exists, \num_of, \max, \min, \sum, \product
As described in the JML documentation, quantified expressions take the form
@center{@code{( @emph{quantifier-keyword} @emph{type} @emph{idlist} ; @emph{range-expr} ; @emph{expr} )}}
or
@center{@code{( @emph{quantifier-keyword} @emph{type} @emph{idlist} ; ; @emph{expr} )}}
or
@center{@code{( @emph{quantifier-keyword} @emph{type} @emph{idlist} ; @emph{expr} )}}
The @emph{range-expr} is a boolean expression; its default value is @strong{true}.
The @emph{idlist} is a comma-separated list of identifiers; these are the bound
variables of the quantification.
@*@strong{Status:} 
@itemize @bullet
@item \forall, \exists: Fully implemented and used in static checking.
@item \num_of, \max, \min, \sum, \product: Parsed and ignored.  The expressions are translated to values of 0, and so may lead to unexpected results.
@end itemize
@noindent
@strong{Comment:} The keyword @code{\max} is used both as a quantifier and as
a function.  The parser is able to distinguish the two usages.

@subsection set comprehension
FIXME

@subsection store-ref expressions
Some annotations require a list of @emph{store-ref expressions}, which are 
expressions whose value is a set of references to fields of classes or objects;
in particular, the value has type @code{org.jmlspecs.models.JMLObjectSet}.
For example, the @code{modifies} clause designates a set 
(that is, a @code{JMLObjectSet} of @emph{store-refs} that
are allowed to be assigned to within a method.  This section describes the 
syntactic features that designate such sets.

@itemize bullet


@item [ @emph{ident} | @code{super} | @code{this} ] @code{.} [ @emph{ident} | @code{this} ]
@*This designates a field of an object.
@*@strong{Status: } Implemented within modifies clauses.

@item [ @emph{ident} | @code{super} | @code{this} ] @code{.*}  
@*This designates all static and instance fields, of any privacy level, including
those inherited from superclasses and interfaces, of the given object.
@*@strong{Status: } Not implemented.

@item [ @emph{ident} | @code{super} | @code{this} ] @code{[@emph{expr}]}  
@*This designates an element of the given array object.
@*@strong{Status: } Not implemented.

@item [ @emph{ident} | @code{super} | @code{this} ] @code{[@emph{expr}..@emph{expr2}]}  
@*This designates a range of elements of the given array object.
@*@strong{Status: } Not implemented.

@item [ @emph{ident} | @code{super} | @code{this} ] @code{[*]}  
@*This designates all the elements of the given array object.
@*@strong{Status: } Not implemented.

@item @emph{classname}.* 
@*This designates all static fields, of any privacy level, including
those in superclasses and interfaces, of the given class.
@*@strong{Status: } Not implemented.

@item \nothing 
@*This designates an empty set of spec-refs.
@*@strong{Status: } Not implemented.

@item \everything 
@*This designates a universal set - the set of references to all object and class
fields for every object and class allocated in the current state of the program.
@*@strong{Status: } Not implemented.

@end itemize

@subsection \not_specified
This may be used, within the guidelines of the JML grammar, as the predicate or
store-ref expression in a annotation clause.  It is equivalent to stating that there
is no specification of that clause type.
@*@strong{Status: } Not implemented.

@subsection \private_data
- FIXME - is this still used


@item \other 
- FIXME

@subsection the use of methods and constructors in annotation expressions
- FIXME

@subsection new instance expressions
- FIXME

@subsection new array expressions
- FIXME

@subsection Other Java operators and expression syntax
- FIXME


@section Other issues
FIXME - descriptions needed here

@subsection Java and JML assert statements
@subsection  ESC/Java2 allows methods and constructors in Java source without bodies
@subsection  redundant specifications
@subsection  Original Esc/java also_ specifications
@subsection  Desugaring of heavyweight specifications
@subsection  anonymous classes
@subsection  @code{field}, @code{method} and @code{constructor} keywords


@section Nowarn warning types

The static checker used in ESC/Java2 (and in ESC/Java) produces warnings (rather
than errors or cautions) when it detects source code that might violate the
specifications.  These warnings are categorized into types and can be suppressed
or enabled by warning type name (using either command-line options or the 
@code{nowarn} annotation).  This is a list of the warning types used.

@itemize bullet
@item FIXME - need warning types - check if these are in the ESC/Java documentation
@end itemize

@section Command-line options

ESC/Java2 has implemented a number of command-line options that are not present
in ESC/Java, as well as documenting some of those in ESC/Java.  ESC/Java2 also
kept many experimental (and undocumented) options from ESC/Java.  The following 
is a partial list of command-line options available in ESC/Java2.

@itemize
@item -help : causes the program to print information about command-line options
and then to terminate


@item FIXME - check for others to be documented

@end itemize

@c -----------------------------------------------------------------------------
@chapter Incompatibilities

@section Major features of JML not implemented in ESC/Java2
@itemize bullet
@item inner and nested classes and interfaces
@item anonymous classes
@item subclassing contracts: These are parsed but not checked
@item any handling of implies_that and for_example behavior:  These are parsed but not checked
@end itemize 

@section Incompatibilities with ESC/Java
@subsection Error messages and warnings
ESC/Java2 has added error messages to conform with current JML semantics.  
Some old ESC/Java errors and warnings are no longer appropriate and
have been removed.

FIXME - discussion needed

@subsection also
@subsection monitored_by
@subsection readable_if
@subsection non_null on formal parameters

@section Non-JML features in ESC/Java2

There are some syntactic constructs accepted by ESC/Java and continue to be 
accepted by ESC/Java2 that are not part of JML.

FIXME - discussion needed

@subsection  loop_predicate
@subsection  skolem_constant
@subsection  still_deferred
@subsection  writable_deferred
@subsection  writable_if
@subsection  readable_if
@subsection  dttfsa

@subsection logical operators
Discuss the behavior of logical and short-circuit operators in the presence of undefined expressions (or expressions that throw exceptions).




@c node  Concept Index,  , , Top
@c node-name, next, previous, up
@unnumbered Concept Index

@printindex cp

@bye

ISSUES:
- clause defaults
