escjava2_types : THEORY
  BEGIN
    S : TYPE+

    % Java base types.
    Boolean : TYPE+ FROM bool
    % Eventually we'll refine IntegralNumber to bounded, modular ints.
    % All of these numeric types inherit from the PVS type "number".
    IntegralNumber : TYPE+ FROM int
    % The same thing holds true for this bad-boy.
    FloatingPointNumber : TYPE+ FROM real
    BigIntNumber : TYPE+ FROM int
    RealNumber : TYPE+ FROM real
    % We would love to define these as supertypes of these component
    % types but we cannot because we are relying upon PVS prelude
    % types for their semantics.  Number is the supertype of all
    % Java integral types and JML numeric types.
    Number : TYPE+ = number
    BasicValue : TYPE+ = [Boolean + Number]
    Reference : TYPE+
    ArrayReference : TYPE+ FROM Reference
    JMLNumber : TYPE+ = [Number + BigIntNumber + RealNumber]

    % Sorts representing the various kinds of object fields in Java.
    Field : TYPE+
    BooleanField, NumberField, ReferenceField : TYPE+ FROM Field

    % These two PVS types represent the actual Java types.
    JavaType : TYPE+
    PrimitiveType, ReferenceType : TYPE+ FROM JavaType
    ArrayType : TYPE+ FROM ReferenceType
    JavaTypes_are_disjoint : AXIOM 
      FORALL(p : PrimitiveType, r : ReferenceType): p /= r

    Time : TYPE FROM int
    Lock : TYPE+
    % @review JoeK, CesareT: It is unclear if we need Object at
    % all; reconsider later.
    Object : TYPE+

  END escjava2_types

map_theory[Map : TYPE+, Index : TYPE+, Value : TYPE+] : THEORY
  BEGIN

    get : [ Map, Index -> Value ]
    set : [ Map, Index, Value -> Map ]

    get_and_set_definition : AXIOM
      FORALL(m : Map, i : Index, v : Value ) :
             get(set(m, i, v), i) = v

    set_only_changes_one_index : AXIOM
      FORALL(m : Map, i,j : Index, v : Value) :
             i /= j IMPLIES get(set(m, i, v), j) = get(m, j)

  END map_theory

escjava2_java_typesystem : THEORY
  BEGIN
    IMPORTING escjava2_types,
              orders[JavaType]

    % <: is <=
    % subtyping_is_a_partial_order : POSTULATE partial_order?(orders[JavaType].<=)
    % < is <
    % comparison_is_a_strict_total_order : POSTULATE strict_total_order?(orders[JavaType].<)

    % === ESCJ 8: Section 1.1

    % We will use '<=' in PVS for '<:' in the Simplify logic.  Thus,
    % <= is reflexive, transitive, and antisymmetric.

    T_java_lang_Object : ReferenceType

    % Primitive types are final.

    T_boolean, T_char, T_byte, T_short, T_int, T_long, T_float, T_double : PrimitiveType

    % primitive? is no longer necessarily because the existence of
    % PrimitiveType.

    % extends? is Java's "extends" and "implements" (direct subtype)
    extends? : ({R : PRED[[ReferenceType, ReferenceType]] | irreflexive?(R)})
    <= : ({R : PRED[[JavaType, JavaType]] | 
         reflexive?(R) AND transitive?(R) AND antisymmetric?(R)})

    subtype_includes_extends : AXIOM
      FORALL(t : ReferenceType, u : ReferenceType) :
        extends?(t, u) IMPLIES t <= u

    subtype_is_the_smallest_relation_that_contains_extends : AXIOM
      FORALL(t : ReferenceType, u : ReferenceType) :
        t <= u AND t /= u IMPLIES
        EXISTS(v : ReferenceType) : extends?(t, v) AND v <= u

    primative_types_are_final : AXIOM
      FORALL (t : JavaType, p : PrimitiveType): t <= p IMPLIES t = p
    primative_types_have_no_proper_supertypes : AXIOM
      FORALL (p : PrimitiveType, t : JavaType): p <= t IMPLIES p = t

    java_lang_Object_is_Top : AXIOM
      FORALL (t : ReferenceType): t <= T_java_lang_Object

    % === ESCJ 8: Section 1.2

    typeOf(r : Reference) : ReferenceType
    NULL : Reference

    isa?(r : Reference, t : ReferenceType) : bool =
      ((r = NULL) OR typeOf(r) = t)

    % === ESCJ 8: Section 1.3

    T_java_lang_Cloneable : ReferenceType

    elemtype : [ArrayType -> JavaType]
    array_constructor : [JavaType -> ArrayType]

    arrays_are_cloneable : AXIOM
      FORALL (t : JavaType): array_constructor(t) <= T_java_lang_Cloneable
    elemtype_definition : AXIOM
      FORALL (t : JavaType): elemtype(array_constructor(t)) = t
    array_subtyping : AXIOM
      FORALL (t0 : ArrayType, t1 : JavaType): t0 <= array_constructor(t1) IFF
                                              elemtype(t0) <= t1

    % === ESCJ 8: Section 2.1

    % The static type predicate.

    % Again, we would prefer to wrap this up in a single is(), but
    % because of the PVS type hierarchy (discussed above) we have to
    % overload instead.
    is : [ Boolean, JavaType -> bool ]
    is : [ Number, JavaType -> bool ]
    is : [ Reference, JavaType -> bool ]

    % cast is dealt with the same way.
    cast : [ Boolean, PrimitiveType -> Boolean ]
    cast : [ Number, PrimitiveType -> Number ]
    cast : [ Reference, ReferenceType -> Reference ]

    redundant_cast_removal_boolean : AXIOM
      FORALL (x : Boolean, t : JavaType): is(x, t) IMPLIES cast(x, t) = x
    redundant_cast_removal_number : AXIOM
      FORALL (x : Number, t : JavaType): is(x, t) IMPLIES cast(x, t) = x
    redundant_cast_removal_reference : AXIOM
      FORALL (x : Reference, t : JavaType): is(x, t) IMPLIES cast(x, t) = x

    % === ESCJ 8: Section 2.2

    % Not in ESCJ8, but should be

    refEQ(x, y : Reference): bool = x = y

    refNE(x, y : Reference): bool = x /= y

  END escjava2_java_typesystem

escjava2_java_boolean_ops : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem

    % === ESCJ 8: Section 5.2

    boolAnd (a, b : Boolean): bool = a AND b
    boolEq (a, b : Boolean): bool = a IFF b
    boolImplies (a, b : Boolean): bool = a IMPLIES b
    boolNE (a, b : Boolean): bool = a /= b
    boolNot (a : Boolean): bool = NOT a
    boolOr (a, b : Boolean): bool = a OR b

    % === ESCJ 8: Section 5.3

    % Java's ternary 'conditional' operator (? :)

    termConditional (b : Boolean, x, y : Boolean): Boolean =
      IF b THEN x ELSE y ENDIF
    termConditional (b : Boolean, x, y : Number): Number =
      IF b THEN x ELSE y ENDIF
    termConditional (b : Boolean, x, y : Reference): Reference =
      IF b THEN x ELSE y ENDIF

  END escjava2_java_boolean_ops

escjava2_java_integral_types : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem
    
    % === ESCJ 8: Section 2.2.1

    % Axioms to express the size of the basic types.
    range_of_char : AXIOM
      FORALL (x : Number): is(x, T_char) IFF 0 <= x AND x <= 65535
    range_of_byte : AXIOM
      FORALL (x : Number): is(x, T_byte) IFF -128 <= x AND x <= 127
    range_of_short : AXIOM
      FORALL (x : Number): is(x, T_short) IFF -32768 <= x AND x <= 32767
    range_of_int : AXIOM
      FORALL (x : Number): is(x, T_int) IFF -2^31 <= x AND x <= 2^31-1
%     range_of_long : AXIOM
%       FORALL (x : Number): is(x, T_long) IFF longFirst <= x AND x <= longLast
%     range_of_float : AXIOM
%       FORALL (x : Number): is(x, T_float) IFF longFirst <= x AND x <= longLast
%     range_of_double : AXIOM
%       FORALL (x : Number): is(x, T_double) IFF longFirst <= x AND x <= longLast

  END escjava2_java_integral_types

escjava2_java_integral_ops : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem

    % === ESCJ 8: Section 5.1

    % Define using modulo_arithmetic theory.
%   integralMod, integralDiv : [ IntegralNumber, IntegralNumber -> IntegralNumber ]

    integralMod(x, y : IntegralNumber): {v: mod(y) | EXISTS (r: mod(y)): v = x * y + r}

    integralDiv(x, y : IntegralNumber): {v: mod(y) | EXISTS (r: mod(y)): v = x * y + r}

    integralMod_def : LEMMA
      FORALL (a, b : IntegralNumber): a = (a / b) * b + (integralMod(a, b))

    integralEQ, integralGE, integralGT, integralLE, integralLT, integralNE :
      [ IntegralNumber, IntegralNumber -> Boolean ]
%     integralEQ_definition : AXIOM
%       FORALL (x, y : S): integralEQ(x, y) = bool_true IFF x = y
%     integralGE_definition : AXIOM
%       FORALL (x, y : S): integralGE(x, y) = bool_true IFF x >= y
%     integralGT_definition : AXIOM
%       FORALL (x, y : S): integralGT(x, y) = bool_true IFF x > y
%     integralLE_definition : AXIOM
%       FORALL (x, y : S): integralLE(x, y) = bool_true IFF x <= y
%     integralLT_definition : AXIOM
%       FORALL (x, y : S): integralLT(x, y) = bool_true IFF x < y
%     integralNE_definition : AXIOM
%       FORALL (x, y : S): integralNE(x, y) = bool_true IFF x /= y

    % === Axioms about properties of integral &, |, and /

    integralAnd, integralOr, integralXor, intShiftL, longShiftL :
      [ IntegralNumber, IntegralNumber -> IntegralNumber ]
%     integralAnd_definition1 : AXIOM
%       FORALL (x, y : S): (0 <= x OR 0 <= y) IMPLIES
%                          0 <= integralAnd(x, y)
%     integralAnd_definition2 : AXIOM
%       FORALL (x, y : S): 0 <= x IMPLIES
%                          integralAnd(x, y) <= x
%     integralAnd_definition3 : AXIOM
%       FORALL (x, y : S): 0 <= y IMPLIES
%                          integralAnd(x, y) <= y
%     integralOr_definition : AXIOM
%       FORALL (x, y : S): (0 <= x AND 0 <= y) IMPLIES
%                          x <= integralOr(x, y) AND y <= integralOr(x, y)
%     integralDiv_definition : AXIOM
%       FORALL (x, y : S): (0 <= x AND 0 <= y) IMPLIES
%                          0 <= integralDiv(x, y) AND integralDiv(x, y) <= x
%     integralXor_definition : AXIOM
%       FORALL (x, y : S): (0 <= x AND 0 <= y) IMPLIES
%                          0 <= integralXor(x, y)
%     intShiftL_definition : AXIOM
%       FORALL (n : S): (0 <= n AND n < 31) IMPLIES
%                       1 <= intShiftL(1, n)
%     longShiftL_definition : AXIOM
%       FORALL (n : S): (0 <= n AND n < 63) IMPLIES
%                       1 <= longShiftL(1, n)

  END escjava2_java_integral_ops

escjava2_java_floating_point : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem

    % === A few floating point axioms - DRCok

    floatingEQ, floatingGE, floatingGT, floatingLE, floatingLT, floatingNE :
      [ FloatingPointNumber, FloatingPointNumber -> Boolean ]
%     floatingADD, floatingMUL, floatingMOD : [ S, S -> S ]
%     floatingNEG : [ S -> S ]

    floatingMod(x, y : FloatingPointNumber): {v: mod(y) | EXISTS (r: mod(y)): v = x * y + r}

%     order_axiom : AXIOM
%       FORALL (d, dd : S):
%         (floatingLT(d, dd) = bool_true OR
%          floatingEQ(d, dd) = bool_true OR
%          floatingGT(d, dd) = bool_true) AND
%         floatingLE(d, dd) = bool_true IFF floatingEQ(d, dd) = bool_true OR floatingLT(d, dd) = bool_true AND
%         floatingGE(d, dd) = bool_true IFF floatingEQ(d, dd) = bool_true OR floatingGT(d, dd) = bool_true AND
%         floatingLT(d, dd) = bool_true IFF floatingGT(dd, d) = bool_true AND
%         floatingLE(d, dd) = bool_true IFF floatingGE(dd, d) = bool_true AND
%         NOT (floatingLT(d, dd) = bool_true IFF floatingGE(d, dd) = bool_true) AND
%         NOT (floatingGT(d, dd) = bool_true IFF floatingLE(d, dd) = bool_true)

%     floatingNE_definition : AXIOM
%       FORALL (d, dd : S): floatingEQ(d, dd) = bool_true IFF NOT floatingNE(d, dd) = bool_true

%     F_0_0 : S

%     floatingADD_definition : AXIOM
%       FORALL (d, dd : S): (floatingGT(d, floatingNEG(dd)) = bool_true) IMPLIES
%                           floatingGT(floatingADD(d, dd), F_0_0) = bool_true

    % currently commented out/incomplete in ESC/Java unsorted logic
    % floatingMUL_definition : AXIOM
    %   FORALL (d, dd : S): ...

%     floatingMOD_definition1 : AXIOM
%       FORALL (d, dd : S): (floatingNE(d, F_0_0) = bool_true) IMPLIES
%                           (floatingGE(d, F_0_0) = bool_true AND
%                            floatingGE(floatingMOD(d, dd), F_0_0) = bool_true AND
%                            floatingLE(d, F_0_0) = bool_true AND
%                            floatingLE(floatingMOD(d, dd), F_0_0) = bool_true)
%     floatingMOD_definition2 : AXIOM
%       FORALL (d, dd : S): (floatingGT(d, F_0_0) = bool_true) IMPLIES
%                           (floatingGT(floatingMOD(d, dd), floatingNEG(dd)) = bool_true AND
%                            floatingLT(floatingMOD(d, dd), dd) = bool_true)
%     floatingMOD_definition3 : AXIOM
%       FORALL (d, dd : S): (floatingLT(dd, F_0_0) = bool_true) IMPLIES
%                           floatingLT(floatingMOD(d, dd), floatingNEG(dd)) = bool_true
%     floatingMOD_definition4 : AXIOM
%       FORALL (d, dd : S): (floatingLT(dd, F_0_0) = bool_true) IMPLIES
%                           floatingGT(floatingMOD(d, dd), dd) = bool_true

  END escjava2_java_floating_point

escjava2_array_store : THEORY
  BEGIN

    % Mimics the 'elems' of SRC ESC/Java.
    ArrayStore : TYPE+
    % This is the syntactic, fully-resolved name of the Java array
    % being indexed.  In SRC ESC/Java, it is encoded in Translate as a
    % standard VariableAccess.
    ArrayName : TYPE+

  END escjava2_array_store

escjava2_java_field_representation : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem,
              escjava2_jml_semantics,
              escjava2_array_store,
              map_theory[BooleanField, Reference, Boolean],
              map_theory[NumberField, Reference, Number],
              map_theory[ReferenceField, Reference, Reference],
              map_theory[ArrayReference, IntegralNumber, Boolean],
              map_theory[ArrayReference, IntegralNumber, Number],
              map_theory[ArrayReference, IntegralNumber, Reference],
              map_theory[ArrayStore, ArrayName, ArrayReference]

%     S_to_real : [ S -> real ]
%     CONVERSION+ S_to_real

%     % === ESCJ 8: Section 2.4

%     % 'as' trick in use.
%     asField : [ S, S -> S ]
%     asField_definition : AXIOM
%       FORALL (f, t, x : S): is(select(asField(f, t), x), t)

%     % === ESCJ 8: Section 2.5

%     % 'as' trick in use.
%     asElems : [ S -> S ]
%     asElems_definition : AXIOM
%       FORALL (e, a, i : S): is(select(select(asElems(e), a), i),
%                                elemtype(typeof(a)))

    % === ESCJ 8: Section 3.0

    vAllocTime : [ Reference -> Time ]
    isAllocated (r : Reference, t : Time): bool = vAllocTime(r) < t

    % === ESCJ 8: Section 3.1

    fClosedTime : [ Field -> Time ]
    fClosedTime_definition : AXIOM
      FORALL (r : Reference, f : Field, t : Time): 
        (fClosedTime(f) < t AND isAllocated(r, t)) IMPLIES
        isAllocated(get(f, r), t)

    % === ESCJ 8: Section 3.2
    eClosedTime : [ ArrayStore -> Time ]
    % @review JoeK, CesareT - original theory seems to have a sort
    % error in the isAllocated() use.
    eClosedTime_definition : AXIOM
      FORALL (a : ArrayName, e : ArrayStore, i : IntegralNumber, t : Time):
        (eClosedTime(e) < t AND isAllocated(get(e, a), t)) IMPLIES
        isAllocated(get(get(e, a), i), t)        

    % === Axioms about classLiteral; not in ESCJ 8 (yet?):

%     classLiteral : [ S -> S ]
%     T_java_lang_Class : S
%     % TODO: review use of alloc
%     alloc : S

%     classLiteral_definition1 : AXIOM
%       FORALL (t : S): classLiteral(t) /= java_null AND
%                       is(classLiteral(t), T_java_lang_Class) AND
%                       isAllocated(classLiteral(t), alloc)

%     classLiteral_definition2 : AXIOM
%       FORALL (t : S): classLiteral(t) = t

  END escjava2_java_field_representation

escjava2_java_strings : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem,
              escjava2_jml_semantics

    T_java_lang_String : ReferenceType
    stringCat (x, y : Reference): Reference

    stringCat_definition : AXIOM
      FORALL (x, y : Reference): stringCat(x, y) /= NULL AND
                                 typeof(stringCat(x, y)) <= T_java_lang_String

  END escjava2_java_strings

escjava2_java_semantics : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem,
              escjava2_java_boolean_ops,
              escjava2_java_integral_types,
              escjava2_java_integral_ops,
              escjava2_java_floating_point,
              escjava2_java_field_representation,
              escjava2_java_strings

  END escjava2_java_semantics

escjava2_lock_semantics : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem,
              escjava2_jml_semantics,
              escjava2_java_field_representation,
              sets[Lock]

%     % === ESCJ 8: Section 4

%     max : [ LockSet -> LockSet ]

%     % null is in lockset (not in ESCJ 8)
%     null_is_in_lockset : AXIOM
%       FORALL (s : S): select(asLockSet(s), NULL) = bool_true

%     lockLE (x, y : S): bool = x <= y
%     lockLT (x, y : S): bool = x < y

%     % all locks in lockset are below max(lockset) (not in ESCJ 8)
%     all_locks_in_lockset_are_below_max_lockset : AXIOM
%       FORALL (s, mu : S): select(asLockSet(s), mu) = bool_true IMPLIES
%                           lockLE(mu, max(asLockSet(s)))

%     % null precedes all objects in locking order (not in ESCJ 8)
%     null_precedes_all_objects : AXIOM
%       FORALL (x : S): typeof(x) <= T_java_lang_Object IMPLIES
%                       lockLE(java_null, x)

  END escjava2_lock_semantics

escjava2_arrays : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem,
              escjava2_java_field_representation,
              escjava2_java_integral_types

%     % === ESCJ 8: Section 5.0

%     arrayLength : [ S -> S ]
%     arrayLength_definition : AXIOM
%       FORALL (a : S): 0 <= arrayLength(a) AND 
%                       is(arrayLength(a), T_int)

%     % elems will be eliminated in the new logic, at a cost of
%     % complexity in the translator of course, and instead separate
%     % maps will be introduced for each array.  This will make the
%     % logic cleaner and possibly help the prover be more efficient.
%     elems : S
%     arrayFresh : [ S, S, S, S, S, S, S -> bool ]
%     arrayMake : [ S, S, S, S, S -> S ]
%     arrayShapeOne : [ S -> S ]
%     arrayShapeMore : [ S, S -> S ]
%     arrayParent : [ S -> S ]
%     arrayPosition : [ S -> S ]

%     array_axiom1 : AXIOM
%       FORALL (a, a0, b0, e, n, s, T, v : S):
%         arrayFresh(a, a0, b0, e, arrayShapeMore(n, s), T, v) IFF
%         (a0 <= vAllocTime(a) AND
%          isAllocated(a, b0) AND
%          a /= java_null AND
%          typeof(a) = T AND
%          arrayLength(a) = n AND
%          FORALL (i : S):
%            arrayFresh(select(select(e, a), i), a0, b0, e, s, elemtype(T), v) AND
%            arrayParent(select(select(e, a), i)) = a AND
%            arrayPosition(select(select(e, a), i)) = i)

%     array_axiom2 : AXIOM
%       FORALL (a, a0, b0, e, n, T, v : S):
%         arrayFresh(a, a0, b0, e, arrayShapeOne(n), T, v) IFF
%         (a0 <= vAllocTime(a) AND
%          isAllocated(a, b0) AND
%          a /= java_null AND
%          typeof(a) = T AND
%          arrayLength(a) = n AND
%          FORALL (i : S):
%            select(select(e, a), i) = v)

%     array_axiom3 : AXIOM
%       FORALL (a0, b0, e, s, T, v : S):
%         arrayFresh(arrayMake(a0, b0, s, T, v), a0, b0, elems, s, T, v)

%     array_axiom4: AXIOM
%       FORALL (a0, b0, a1, b1, s1, s2, T1, T2, v : S):
%         (arrayMake(a0, b0, s1, T1, v) = arrayMake(a1, b1, s2, T2, v)) IMPLIES
%         (b0 = b1 AND T1 = T2 AND s1 = s2)

%     % === code to ensure that (isNewArray x) ==> x has no invariants

%     % arrayType represents the type from which all Java arrays inherit.
%     arrayType : S

%     % arrayType is distinct from all types with invariants (due to the
%     % generated type-distinctness axiom)
%     arrayType_distinct : AXIOM
%       arrayType = asChild(arrayType, T_java_lang_Object)

%     isNewArray : [ S -> S ]

%     arrayType_definition : AXIOM
%       FORALL (t : S): array_constructor(t) <= arrayType
%     arrayType_is_top : AXIOM
%       FORALL (s : S):
%         (bool_true = isNewArray(s)) IMPLIES
%         typeof(s) <= arrayType

%     % === Implementation of nonnullelements; not in ESCJ 8 (yet?):

%     nonnullelements (x, e : S): bool =
%       x /= java_null AND
%       FORALL (i : S):
%         (0 <= i AND i < arrayLength(x)) IMPLIES
%         select(select(e, x), i) /= java_null

  END escjava2_arrays

escjava2_jml_semantics : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem

    % === Define typeof for primitive types - DRCok
    typeof : [ Boolean -> PrimitiveType ]
    typeof : [ IntegralNumber -> PrimitiveType ]
    typeof : [ Reference -> ReferenceType ]
    % WRONG - not equivalent; need to review
%     typeof_definition : AXIOM
%       FORALL (x, y : S): primitive?(y) AND is(x, y) IFF typeof(x) = y

    typeof_char : AXIOM
      FORALL (x : IntegralNumber): is(x, T_char) IFF typeof(x) = T_char
    typeof_byte : AXIOM
      FORALL (x : IntegralNumber): is(x, T_byte) IFF typeof(x) = T_byte
    typeof_short : AXIOM
      FORALL (x : IntegralNumber): is(x, T_short) IFF typeof(x) = T_short
    typeof_int : AXIOM
      FORALL (x : IntegralNumber): is(x, T_int) IFF typeof(x) = T_int
    typeof_long : AXIOM
      FORALL (x : IntegralNumber): is(x, T_long) IFF typeof(x) = T_long
    typeof_float : AXIOM
      FORALL (x : IntegralNumber): is(x, T_float) IFF typeof(x) = T_float
    typeof_double : AXIOM
      FORALL (x : IntegralNumber): is(x, T_double) IFF typeof(x) = T_double

    % === ESCJ 8: Section 2.3

    typeof_reference_definition : AXIOM
      FORALL (r : Reference, t : ReferenceType): t <= T_java_lang_Object IMPLIES
                                                 is(r, t) IFF (r = NULL OR typeof(r) <= t)

  END escjava2_jml_semantics

escjava2_logic : THEORY
  BEGIN
    IMPORTING escjava2_java_semantics,
              escjava2_jml_semantics,
              escjava2_lock_semantics
  END escjava2_logic
