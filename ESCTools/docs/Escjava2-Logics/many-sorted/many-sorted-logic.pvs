escjava2_memory : THEORY
  BEGIN
    Memory : TYPE+	
    Time : TYPE FROM int
    ReferenceType, Reference : TYPE+
    Object : TYPE+
    BooleanField, DiscreteNumberField, ContinuousNumberField, ReferenceField : TYPE+

    HEAP : Memory

	memGet : [ Memory, Reference -> Object ]
	memSet : [ Memory, Reference, Object -> Memory ]

	vAllocTime : {R : [ Reference -> Time ] | injective?(R) }
    fClosedTime(field : ReferenceField) : Time
    eClosedTime(object : Object) : Time

    isAllocated(reference : Reference, time : Time) : bool
    arrayFresh(reference : Reference, memory : Memory, time : Time) : bool
	memory_operation : LEMMA
	  FORALL( r : Reference, obj : Object ) :
            memGet(memSet(HEAP, r,obj), r) = obj

	memory_operation2 : LEMMA
	  FORALL( r : Reference, q : Reference, obj : Object ) :
	    memGet(memSet(HEAP, r, obj), q) = memGet(HEAP, q)

	alloc_time : LEMMA
	  FORALL( r : Reference, t : Time ) :
  	    isAllocated(r,t) IFF vAllocTime(r) < t

	% maybe redunctant ?
	arrayFresh_operation : LEMMA 
	  FORALL( r : Reference, a : Time) :
	    arrayFresh(r, HEAP, a) IMPLIES
	      vAllocTime(r) = a AND isAllocated(r, a)					

   END escjava2_memory

escjava2_java_typesystem : THEORY
  BEGIN
    IMPORTING escjava2_memory

    Boolean : Type+ FROM bool
    DiscreteNumber : TYPE+ FROM int
    ContinuousNumber : TYPE+ FROM real
    BigIntNumber : TYPE+ FROM int
    RealNumber : TYPE+ FROM real
    JavaNumber : TYPE = [DiscreteNumber + ContinuousNumber]
    JMLNumber : TYPE = [JavaNumber + BigIntNumber + RealNumber]
    Number : TYPE = JMLNumber
    java_lang_Object : ReferenceType
	java_lang_Cloneable : ReferenceType

    java_lang_Boolean_TRUE : Boolean
    java_lang_Boolean_FALSE : Boolean

    NULL : Reference

    isBigInt?(number : Number) : bool
    isReal?(number : Number) : bool

    extends? : ({R : PRED[[ReferenceType, ReferenceType]] | irreflexive?(R)})
    subtype? : ({R : PRED[[ReferenceType, ReferenceType]] | 
      reflexive?(R) AND transitive?(R) AND antisymmetric?(R)})
    isa?(reference : Reference, referenceType : ReferenceType) : bool

    subtype_includes_extends : LEMMA
      FORALL(t : ReferenceType, u : ReferenceType) :
        extends?(t, u) IMPLIES subtype?(t, u)

    subtype_is_the_smallest_relation_that_contains_extends : LEMMA
      FORALL(t : ReferenceType, u : ReferenceType) :
        subtype?(t, u) AND NOT (t = u) IMPLIES
        EXISTS(v : ReferenceType) : extends?(t, v) AND subtype?(v, u)

    java_lang_Object_is_Top : LEMMA
      FORALL(t : ReferenceType) : subtype?(t, java_lang_Object)

    elementReferenceType(referenceType : ReferenceType) : ReferenceType

    typeOf(reference : Reference) : ReferenceType

    unique_dynamic_subtype : LEMMA
      FORALL(r : Reference, t : ReferenceType) : isa?(r, t) IFF ((r = NULL) OR typeOf(r) = t)

    % do we need a cotuple of (non-array) ReferenceType and ArrayReferenceType?
    % XXX
    instantiable(referenceType : ReferenceType) : bool =
      COND
        referenceType = java_lang_Object -> TRUE,
        ELSE -> FALSE
      ENDCOND

  END escjava2_java_typesystem

escjava2_java_numeric_types : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem, integers

    java_lang_Double_MAX_VALUE : DiscreteNumber % (2-2^-52)*2^1023
    java_lang_Double_MIN_VALUE : DiscreteNumber % 
    java_lang_Float_MAX_VALUE : DiscreteNumber % (2-2^-23)*2^127
    java_lang_Float_MIN_VALUE : DiscreteNumber % 
    java_lang_Long_MAX_VALUE : DiscreteNumber % 2^63-1
    java_lang_Long_MIN_VALUE : DiscreteNumber % -2^63
    java_lang_Integer_MAX_VALUE : DiscreteNumber % 2^31-1
    java_lang_Integer_MIN_VALUE : DiscreteNumber % -2^31
    java_lang_Short_MAX_VALUE : DiscreteNumber % 2^15-1
    java_lang_Short_MIN_VALUE : DiscreteNumber % -2^15
    java_lang_Byte_MAX_VALUE : DiscreteNumber % 2^32-1
    java_lang_Byte_MIN_VALUE : DiscreteNumber % 0
    java_lang_Char_MAX_VALUE : DiscreteNumber % 2^7-1
    java_lang_Char_MIN_VALUE : DiscreteNumber % -2^7

    rangeCheck(number : Number, lowerBound, upperBound : DiscreteNumber) : bool =
      CASES number OF
        IN_1(javaNumber) : 
          CASES javaNumber OF
            IN_1(discreteNumber) : lowerBound <= discreteNumber <= upperBound,
            IN_2(continuousNumber) : FALSE
          ENDCASES,
        IN_2(BigIntNumber) : FALSE,
        IN_3(RealNumber) : FALSE
      ENDCASES

    isChar? : [Number -> bool]
    isChar_def : LEMMA
      FORALL(number : Number) : isChar?(number) IFF 
        rangeCheck(number, java_lang_Char_MIN_VALUE, java_lang_Char_MAX_VALUE)
    isByte? : [Number -> bool]
    isByte_def : LEMMA
      FORALL(number : Number) : isByte?(number) IFF 
        rangeCheck(number, java_lang_Byte_MIN_VALUE, java_lang_Byte_MAX_VALUE)
    isShort? : [Number -> bool]
    isShort_def : LEMMA
      FORALL(number : Number) : isShort?(number) IFF 
        rangeCheck(number, java_lang_Short_MIN_VALUE, java_lang_Short_MAX_VALUE)
    isInt? : [Number -> bool]
    isInt_def : LEMMA
      FORALL(number : Number) : isInt?(number) IFF 
        rangeCheck(number, java_lang_Integer_MIN_VALUE, java_lang_Integer_MAX_VALUE)
    isLong? : [Number -> bool]
    isLong_def : LEMMA
      FORALL(number : Number) : isLong?(number) IFF 
        rangeCheck(number, java_lang_Long_MIN_VALUE, java_lang_Long_MAX_VALUE)
    isFloat? : [Number -> bool]
    isFloat_def : LEMMA
      FORALL(number : Number) : isFloat?(number) IFF 
        rangeCheck(number, java_lang_Float_MIN_VALUE, java_lang_Float_MAX_VALUE)
    isDouble? : [Number -> bool]
    isDouble_def : LEMMA
      FORALL(number : Number) : isDouble?(number) IFF 
        rangeCheck(number, java_lang_Double_MIN_VALUE, java_lang_Double_MAX_VALUE)

    % an approximation of Z if a theory of integers is not available
    % these definitions would require an explicit definition of + on DiscreteNumber
    % or would be defined using Peano arithmetic
    % we just use the integers PVS theory
    % 0, 1 : DiscreteNumber
    % isBigInt?(0) = TRUE
    % isBigInt?(1) = TRUE
    % successor : LEMMA
    %   FORALL(number : DiscreteNumber) : isBigInt?(number) IFF isBigInt?(number + 1)

  END escjava2_java_numeric_types

escjava2_java_casting : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem, escjava2_java_numeric_types

    % numeric downcasting (truncation)
    narrowDouble2Float(source : ContinuousNumber) : ContinuousNumber
    narrowDouble2Long : [ContinuousNumber -> DiscreteNumber]
    narrowDouble2Int : [ContinuousNumber -> DiscreteNumber]

    narrowFloat2Long : [ContinuousNumber -> DiscreteNumber]
    narrowFloat2Int : [ContinuousNumber -> DiscreteNumber]

    narrowLong2Int : [DiscreteNumber -> DiscreteNumber]
    narrowLong2Short : [DiscreteNumber -> DiscreteNumber]
    narrowLong2Byte : [DiscreteNumber -> DiscreteNumber]
    narrowLong2Char : [DiscreteNumber -> DiscreteNumber]

    narrowInt2Short : [DiscreteNumber -> DiscreteNumber]
    narrowInt2Byte : [DiscreteNumber -> DiscreteNumber]

    ConversionFunction : TYPE = [DiscreteNumber -> DiscreteNumber]
    castByte2Char : ConversionFunction
    castChar2Byte : ConversionFunction
  END escjava2_java_casting

escjava2_object_fields_base[fieldType : TYPE, valueType : TYPE] : THEORY
  BEGIN
    IMPORTING escjava2_memory, escjava2_java_typesystem
   
    select(field : fieldType, object : Object) : valueType
    store(field : fieldType, object : Object, value : valueType) : fieldType

	select_definition : LEMMA 
	  FORALL( f : fieldType, obj : Object, v : valueType ) :
	    select((store(f, obj, v), obj)) = v

  END escjava2_object_fields_base

escjava2_object_fields : THEORY
  BEGIN
    IMPORTING escjava2_memory, escjava2_java_typesystem,
              escjava2_object_fields_base[BooleanField, Boolean],
              escjava2_object_fields_base[DiscreteNumberField, DiscreteNumber],
              escjava2_object_fields_base[ContinuousNumberField, ContinuousNumber],
              escjava2_object_fields_base[ReferenceField, Reference]

 	referenceField_allocation : LEMMA
 	  FORALL( r : Reference, f : ReferenceField, t : Time ) :
	    fClosedTime(f) < t AND isAllocated(r,t) IMPLIES
	    isAllocated( select( f, memGet(HEAP,r)), t) 

  END escjava2_object_fields

escjava2_java_arrays_base[T : TYPE] : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem

    get(obj : Object, num : DiscreteNumber) : T
    set(obj : Object, num : DiscreteNumber, val : T) : Object

	get_definition : LEMMA
	  FORALL( obj : Object, val : Object, n : DiscreteNumber, val : T) :
	    get( (set (obj, n, val)),n) = val

	get_definition2 : LEMMA
	  FORALL( obj : Object, val : Object, n : DiscreteNumber, m :DiscreteNumber, val : T) :
	    get( (set (obj, n, val)),m) = get( obj, m)

  END escjava2_java_arrays_base

escjava2_java_arrays : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem,
    	      escjava2_java_arrays_base[DiscreteNumber],
    	      escjava2_java_arrays_base[ContinuousNumber],
    	      escjava2_java_arrays_base[Boolean],
    	      escjava2_java_arrays_base[Object]
    ArrayReferenceType : TYPE FROM ReferenceType

    % array type constructor
    arrayOf( n : DiscreteNumber, boolean : Boolean) : ArrayReferenceType
    arrayOf( n : DiscreteNumber, number : Number) : ArrayReferenceType
    arrayOf( n : DiscreteNumber, referenceType : ReferenceType) : ArrayReferenceType
    arrayOf( n : DiscreteNumber, arrayReferenceType : ArrayReferenceType) : ArrayReferenceType
    arrayLength(reference : Reference) : DiscreteNumber

	selectArray : [ Reference -> Object ] % substitute for elems

	% am I right ??? :O/
	arrayOf_operation : LEMMA
	  FORALL( n : DiscreteNumber, b : Boolean, ar : ArrayReferenceType, obj : Object, m : DiscreteNumber, b2 : Boolean ) :
	    arrayOf(n , b) = ar IMPLIES
	      EXISTS( r : Reference, t : Time) :
		arrayFresh(r, HEAP, t) AND get( set(selectArray(r), m, b2), m) = b2

    array_subtyping : LEMMA
      FORALL(t : ReferenceType, u : ReferenceType, n : DiscreteNumber, m : DiscreteNumber ) :
        subtype?(t, u) IMPLIES subtype?(arrayOf(n,t), arrayOf(m,u))

    left_inverses_of_Object_constructors : LEMMA
      FORALL(t : ReferenceType, n : DiscreteNumber ) : elementReferenceType(arrayOf(n, t)) = t

	% all arrays are subtype of cloneable
	array_of_boolean_subtype_cloneable : LEMMA
	  FORALL( m : DiscreteNumber, b : Boolean ) :
	    subtype?(arrayOf(m, b), java_lang_Cloneable) 

	array_of_Number_subtype_cloneable : LEMMA
	  FORALL( m : DiscreteNumber, n : Number ) :
	    subtype?(arrayOf(m, n), java_lang_Cloneable)

	array_of_ReferenceType_subtype_cloneable : LEMMA
	  FORALL( m : DiscreteNumber, r : ReferenceType ) :
	    subtype?(arrayOf(m, r), java_lang_Cloneable)

	array_of_arrayReferenceType_subtype_cloneable : LEMMA
	  FORALL( m : DiscreteNumber, a : ArrayReferenceType ) :
	    subtype?(arrayOf(m, a), java_lang_Cloneable)

  END escjava2_java_arrays

escjava2_java_operators : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem

    % arithmetic functions
    DiscreteArithmeticFunction : [DiscreteNumber, DiscreteNumber -> DiscreteNumber]
    ContinuousArithmeticFunction : [ContinuousNumber, ContinuousNumber -> ContinuousNumber]
    % +,-,etc. : ArithmeticFunction

    % boolean functions
    BooleanFunction :  [Boolean, Boolean -> Boolean]
    % ! : [Boolean -> Boolean]
    % &&, ||, etc. : BooleanFunction

    % Java typecast
    cast(reference : Reference, referenceType : ReferenceType) : Reference

    cast_definition : LEMMA
      FORALL(r : Reference, t : ReferenceType) : isa?(cast(r, t), t)

    upcast_has_no_effect : LEMMA
      FORALL(r : Reference, t : ReferenceType) : isa?(r, t) IMPLIES (cast(r, t) = r)
  END escjava2_java_operators

escjava2_jml_operators : THEORY
  BEGIN
    IMPORTING escjava2_java_typesystem, escjava2_java_arrays

  END escjava2_jml_operators

escjava2_object_logic : THEORY
  BEGIN
  END escjava2_object_logic

escjava2_locking : THEORY
BEGIN
 	  IMPORTING escjava2_java_typesystem
	    
	  lockMap : TYPE+

	  LS : lockMap
	  maxLockset : Reference

	  lockLock : [ lockMap, Reference -> lockMap ]
	  lockRelease : [ lockMap, Reference -> lockMap ]
	  lockSelect : [ lockMap, Reference -> bool ]

	  lockLess : { R : [ Reference , Reference -> bool ] | transitive?(R) }

	  lock_access_definition : LEMMA
	    FORALL( r : Reference ) : 
	      lockSelect( lockLock(LS, r), r ) = false

	  lock_access_definition2 : LEMMA
	    FORALL( r : Reference ) : 
	      lockSelect( lockRelease(lockLock(LS, r), r), r) = true

	  ls_has_a_maximum_element : LEMMA
	    FORALL( r : Reference ) : 
	      lockLess(r, maxLockset ) = true

	  null_belongs_to_ls : LEMMA
	    FORALL( r : Reference ) :
	      lockLess(NULL, r) = true

END escjava2_locking

