
<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (WinNT; I) [Netscape]">
   <TITLE>Astgen manual</TITLE>
</HEAD>
<BODY>

<H1>
ESCJ 24:&nbsp; Astgen Manual</H1>

<H3>
Compaq Confidential.</H3>

<H6>
Last modified: September 22, 1998</H6>

<HR>

<P>The <TT>astgen</TT> tool reads in a file containing annotated, partial
implementations of AST classes and writes full implementations for those
classes, putting each in its own source file. It also outputs two auxilliary
classes. Using the generator leads to a description of AST classes that
is more manageable than the full implementation would be because it is
in a single file and because it is smaller by a factor an order of magnitude.
Also, the generator allows one to easily change an AST hierarchy and the
code found inside of AST classes.

<P>The input to <TT>astgen</TT> looks very much like a set of Java class
declarations. These declarations are annotated with Java comments containing
pragmas understood by <TT>astgen</TT>. The input must use Java's lexical
language and must follow the following grammar:
<PRE>&nbsp;<I>PackageDeclaration_opt ImportDeclarations_opt EndHeader ClassDeclaration</I>*</PRE>
where the non-terminals other than <I>EndHeader</I> are defined in the
Java Language Specification. The <I>EndHeader</I> is a Java single-line
comment starting with <TT>//#</TT> followed by some space then followed
by the keyword <TT>EndHeader</TT> (case is significant to <TT>astgen</TT>).
If a <I>ClassDeclaration</I> in an <TT>astgen</TT> input file has a superclass,
the declaration of that superclass must appear earlier in the input file.

<P>Given such an input file, <TT>astgen</TT> does the following:
<UL>
<LI>
All text (including comments and whitespace) before the <TT>EndHeader</TT>
directive is read as the "generic header." It is meant to include a package
declaration and imports that apply to every AST class specified in the
input file.</LI>

<LI>
For each <TT>ClassDeclaration</TT> named <TT>C</TT>, a file named <TT>C.java</TT>
is created. The generic header is written to this file. Then, all text
of <TT>C</TT>, including whitespace and comments, is copied into this file.
(This text includes everthing up to and including the closing brace (<TT>}</TT>)
of <TT>C</TT>, plus any white space after that brace up to (and including)
the first new line.) Along the way, pragmas in <TT>C</TT> may be expanded,
as described below. Also, a number of "boilerplate" members are generated
into <TT>C</TT>.</LI>

<LI>
After all class declarations are processed, some auxilliary files are generated,
as described below.</LI>
</UL>

<H3>
Output</H3>
The tool outputs one <TT>.java</TT> file for each <TT>ClassDeclaration</TT>
in the input file. As discussed above, these per-class <TT>.java</TT> files
consist mostly of the generic header appended to the text of the class
declarations, plus some boilerplate methods generated automatically. "Child
fields" of an AST node are declared using pragmas (pragmas are described
in the next section). Child fields are public fields pointing to what should
be the children of an AST node. The child fields of a class declaration
play an important role in the generation of the boilerplate for the declaration.

<P>In addition to the per-class <TT>.java</TT> files, the tool outputs
a file called <TT>SubTagConstants.java</TT> and another called <TT>Visitor.java</TT>.
These files support the boilerplate code generated for the per-class <TT>.java</TT>
files.

<P>The bullet points below describe the boilerplate methods generated plus
the two support files for them.
<UL>
<LI>
<B>Object construction. </B>Classes generated by <TT>astgen</TT> are meant
to be instantiated via static "maker" methods rather than through constructors.
This convention allows one to intern certain AST nodes, for example, the
node representing the type <TT>int</TT>. To keep clients from directly
instantiating AST classes, <TT>astgen</TT> generates a protected constructor
that takes no arguments for non-abstract classes.</LI>


<P>For each non-abstract class <TT>C</TT>, <TT>astgen</TT> generates a
public, static method named <TT>make</TT>. The default implementation of
<TT>make</TT> returns a newly-allocated instance of <TT>C</TT>. (This default
can be overriden using pragmas.) The <TT>make</TT> method takes an argument
for each child field of <TT>C</TT>, including child fields inherited from
the superclass of <TT>C</TT>. The order of the argument list is as follows:
superclass child fields come before subclass child fields; within a class,
child-field arguments are ordered according by the order of the pragmas
defining the child fields.
<LI>
<B>Tags. </B>To support the use of <TT>switch</TT> statements to distinguish
different AST node types, <TT>astgen</TT> outputs an instance method <TT>getTag</TT>
in each non-abstract class and also outputs a constant field declaration
in <TT>SubTagConstants</TT>.</LI>


<P>In non-abstract class <TT>Name</TT>, the automatically-generated <TT>getTag</TT>
method returns the constant <TT>TagConstants.NAME</TT> (note the change
to all-caps). In <TT>SubTagConstants</TT>, a constant <TT>int</TT> field
named <TT>NAME</TT> is also generated. The intent is for the (user-written)
type <TT>TagConstants</TT> to extend the automatically-generated interface
<TT>SubTagConstants</TT>.

<P>The <TT>SubTagConstants</TT> interface is not public (ie, it has "package"
level protection). The generic header is also appended to the front of
<TT>SubTagConstants.java</TT>, which will put it into the same package
as the other classes generated for a given input file.
<LI>
<B>Visitors. </B>To support the use of visitors for traversing ASTs, the
code generator outputs an instance method <TT>accept</TT> and also outputs
an abstract class <TT>Visitor</TT> which is the superclass for all visitors.</LI>


<P>The <TT>accept</TT> method for class <TT>Name</TT> looks like the following:
<BLOCKQUOTE>
<PRE>&nbsp;public void accept(Visitor v) { v.visitName(this); }</PRE>
</BLOCKQUOTE>
An <TT>accept</TT> method is generated only for non-abstract classes.

<P>For every class <TT>Name</TT> (abstract and non-abstract), a <TT>visitName</TT>
method is generated in <TT>Visitor</TT>. This method takes an argument
of type <TT>Name</TT> and returns <TT>void</TT>. If <TT>Name</TT> has no
explicitly declared superclass, then <TT>visitName</TT> is an abstract
method. If there is a superclass named <TT>Name2</TT>, then an implementation
of <TT>visitName</TT> is given which looks like
<BLOCKQUOTE>
<PRE>&nbsp;public void visitName(Name o) { visitName2(o); }</PRE>
</BLOCKQUOTE>
The <TT>Visitor</TT> class is public. The generic header is also appended
to the front of <TT>Visitor.java</TT>, which will put it into the same
package as the other classes generated for a given input file.
<LI>
<B>Children. </B>To help in traversing an AST, two methods, <TT>childCount</TT>
and <TT>childAt</TT>, are generated into non-abstract classes for counting
and extracting the (direct) children of a node.</LI>


<P>As in the case of the maker methods, "children" here includes children
inherited from superclasses; also, the order of "children" is defined the
same as for makers. However, there are two twists. First, children that
are primitive types such as <TT>int</TT> are not counted by <TT>childCount</TT>
or returned by <TT>childAt</TT>. Also, the pragmas defining child fields
allow for the specification of child fields that are really sets of children;
we call these "vector children." The <TT>childCount</TT> method counts
each member of a vector child as a separate child; similarly, the numbering
of children for the purpose of defining indices given to <TT>childAt</TT>
also counts each member of a vector child as a separate child.
<LI>
<B>Invariant checking. </B>For all classes (abstract and non-abstract),
a method called <TT>check</TT> is generated for dynamically checking invariants
of a node. This method takes no arguments and returns <TT>void</TT>. This
method first calls <TT>super.check</TT>, then performs checks on each locally
defined child field whose type is not a primitive type. The default, per-field
checks are (a) to ensure that the field is not null and (b) to call the
<TT>check</TT> method on the object in the field. (These checks can be
change via pragmas; see below.) For vector children, the above checks are
done on each member of the vector.</LI>

<LI>
<B>Debug presentation. </B>For non-abstract classes, a <TT>toString</TT>
instance method is generated that returns a <TT>String</TT> representation
suitable for debugging output.</LI>
</UL>
The discussion above suggest that many of the above methods are generated
only in non-abstract classes. This is not exactly true. As mentioned earlier,
if a <TT>ClassDeclaration</TT> in the input to the tool has a superclass,
the declaration of that superclass must appear earlier in the input file.
This implies that every input file declares a set of "root" classes that
are superclasses of all the other, non-root classes declared in the file.
If a class is both abstract and one of these root classes, then the tool
generates into it abstract versions of the methods listed above (that is,
versions without implementations). This means that the methods defined
above can be called on <I>all</I> AST nodes, not just concrete ones.
<H3>
Pragmas</H3>
Inside a <TT>ClassDeclaration</TT>, between member declarations, <TT>astgen</TT>
recognizes a number of pragmas which either generate member declarations
or control the output of boilerplate members.

<P>The syntax of a pragma is a Java single-line comment on a line by itself.
Pragma comments are distinguished by starting with <TT>//#</TT>. Inside
class <TT>C</TT>, the following pragma defines the child fields of <TT>C</TT>:
<UL>
<LI>
"<TT>//#</TT> <I>Type</I> [<TT>*</TT>] <I>Identifier</I> {<TT>NullOk</TT>|<TT>NoCheck</TT>}*".</LI>

<BR>If the <TT>*</TT> is present, the pragma defines a vector child; otherwise,
it defines a regular child. The following pragmas:
<BLOCKQUOTE>
<PRE>//# Name1 id1
//# Name2* id2</PRE>
</BLOCKQUOTE>
would be translated into the following field declarations:
<BLOCKQUOTE>
<PRE>public Name1 id1;
public Name2Vec id2;</PRE>
</BLOCKQUOTE>
It is up to the <TT>astgen</TT> user to provide definitions of <TT>Name2Vec</TT>
and other <TT>???Vec</TT> types referenced by the output of <TT>astgen</TT>.

<P>The <TT>NullOK</TT> and <TT>NoCheck</TT> pragmas control the checking
done for the field by the <TT>check</TT> method. The first supresses the
check that a child field is not <TT>null</TT>; the second supresses the
call to the child's <TT>check</TT> method.</UL>
The following pragmas apply to a class as a whole rather than to individual
fields. They control non-field specific aspects of the generation of boilerplate
methods like <TT>make</TT> and <TT>check</TT>. The syntax of these pragma
is again a single line comment begining with <TT>//#</TT> and containing
a single keyword.
<LI>
"<TT>//#</TT> <TT>NoMaker</TT>".</LI>

<BR>Inside class <TT>C</TT>, this declaration suppresses the generation
of <TT>C</TT>'s <TT>make</TT> method, allowing a custom maker to be written
instead (or none at all).
<LI>
"<TT>//#</TT> <TT>ManualTag</TT>".</LI>

<BR>Inside class <TT>C</TT>, this declaration suppresses the generation
of <TT>C</TT>'s <TT>getTag</TT> method, allowing a custom one to be written
instead. In our Java front-end, we use this feature to allow us to return
different tags for <TT>BinaryExpr</TT> depending on the expression's operation.
<LI>
"<TT>//#</TT> <TT>PostMakeCall</TT>".</LI>

<BR>Inside class <TT>C</TT>, this declaration adds the following line to
the end of <TT>C</TT>'s automatically-generated <TT>make</TT> method:
<BLOCKQUOTE>
<PRE>&nbsp;postMake();</PRE>
</BLOCKQUOTE>
No implementation of <TT>postMake</TT> is generated. The intent is for
the user to write <TT>postMake</TT> themselves, giving them a hook to customize
the initialization of nodes after the child fields are filled in using
the arguments to <TT>make</TT>. In our Java front-end, we use this feature
to allow us, in the maker for <TT>CompilationUnit</TT>, to set the parent
pointer of the <TT>TypeDecl</TT> objects passed as arguments.
<LI>
"<TT>//#</TT> <TT>PostCheckCall</TT>".</LI>

<BR>Similar to <TT>PostMakeCall</TT>, this declaration adds the following
line to the end of automatically-generated <TT>check</TT> methods:
<BLOCKQUOTE>
<PRE>&nbsp;postCheck();</PRE>
</BLOCKQUOTE>
As with <TT>postMake</TT>, no implementation is generated for <TT>postCheck</TT>,
allowing the user to provide their own checking code. In our Java front-end,
we use this feature to ensure that a <TT>Name</TT> has at least one identifier
in it. In place of these class-wide pragmas, an alternative design would
have been for <TT>astgen</TT> to change the code it outputs based on whether
a <I>ClassDeclatation</I> contains certain methods. For example, instead
of the <TT>ManualTag</TT> pragma, <TT>astgen</TT> could generate a <TT>getTag</TT>
method only for classes that do not contain a manually-defined <TT>getTag</TT>
method. In the future, we may change to this design (such a change would
be backward compatible).
<! Server supplied footer starts here>

<p><font FACE="Verdana, arial, helvetica" SIZE="1"><a HREF="http://www.compaq.com/legal.html">Legal 
Statement</a> <a HREF="http://www.compaq.com/privacy.html">Privacy Statement</a></font>

</BODY>
</HTML>
