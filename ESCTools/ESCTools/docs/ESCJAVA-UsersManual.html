<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (X11; U; OSF1 V5.0 alpha) [Netscape]">
   <title>ESCJ 27:&nbsp; ESC/Java User's Manual</title>
</head>
<body bgcolor="#FFFFFF">

<hr>
<center>
<h2>
<b>SRC Technical Note</b></h2></center>

<center>
<h3>
<b>2000-002</b></h3></center>

<center>
<h3>
October 12, 2000</h3></center>

<center>
<hr></center>

<center>
<h2>
ESC/Java User's Manual</h2></center>

<center>
<h3>
K. Rustan M. Leino, Greg Nelson, and James B. Saxe</h3></center>

<center>
<hr>
<p><img SRC="http://research.compaq.com/SRC/pics/cpq-logo.gif" ALT="Compaq" height=40 width=150>
<br><b>Compaq Computer Corporation</b>
<br><b>Systems Research Center</b>
<br>130 Lytton Avenue
<br>Palo Alto, CA 94301
<br><a href="http://research.compaq.com/SRC/">http://research.compaq.com/SRC/</a></center>

<p>
<hr>Copyright &copy; 1999, 2000 Compaq Computer Corporation. All rights
reserved
<hr>
<br><a NAME="Limitation of liability:"></a>Limitation of liability:&nbsp;
This publication and the software it describes are provided ``as is'' without
warranty of any kind, express or implied, including, but not limited to,
the implied warranties of merchantability, fitness for a particular purpose,
or non-infringement.
<p>This publication could include technical inaccuracies or typographical
errors.&nbsp; Furthermore, the Compaq Extended Static Checker for Java
(ESC/Java) is currently under development.&nbsp; Compaq therefore expects
that changes will occur in the ESC/Java software and documentation, from
time to time.&nbsp; Compaq reserves the right to adopt such changes, or
to cause or recommend that ESC/Java users adopt such changes, upon such
notice as is practicable under the circumstances or without any notice,
in its discretion.
<p>The Compaq Extended Static Checker for Java (ESC/Java) is not a product
of Sun Microsystems, Inc.
<p>Compaq is a registered trademark of Compaq Computer Corporation.&nbsp;
Java is a trademark or registered trademark of Sun Microsystems, Inc.&nbsp;
UNIX is a registered trademark in the United States and other countries,
exclusively licensed through X/Open Company, Ltd.&nbsp; Windows is a registered
trademark of Microsoft Corporation.&nbsp; PostScript is a registered trademark
of Adobe Systems, Inc.&nbsp; All other trademarks or registered trademarks
mentioned herein are the property of their respective holders.
<br>
<hr WIDTH="100%">
<h2>
Abstract</h2>
The <i>Compaq Extended Static Checker for Java</i> (ESC/Java) is a programming
tool that attempts to find common run-time errors in Java programs by static
analysis of the program text.&nbsp; Users can control the amount and kinds
of checking that ESC/Java performs by annotating their programs with specially
formatted comments called&nbsp; <i>pragmas</i>.&nbsp; This manual is designed
to serve both as an introduction to ESC/Java and as a reference manual.
It starts by providing an overview of ESC/Java through an illustrative
example of its use and a summary of its features, and then goes on to document
all the pragmas supported by ESC/Java and all the kinds of warnings that
it generates.&nbsp; Appendices provide a brief sketch of ESC/Java's implementation,
information about obtaining ESC/Java, and some discussion of its limitations.
<hr WIDTH="100%">
<h2>
<a NAME="Preface"></a>Preface</h2>
The <i>Compaq Extended Static Checker for Java</i> (ESC/Java) is a programming
tool that attempts to find common run-time errors in Java programs by static
analysis of the program text.&nbsp; Users can control the amount and kinds
of checking that ESC/Java performs by annotating their program with specially
formatted comments called&nbsp; <i>pragmas</i>.&nbsp; This manual starts
by providing an overview of ESC/Java through an illustrative example of
its use and a summary of its features, and then goes on to document all
the pragmas supported by ESC/Java and all the kinds of warnings that it
generates.&nbsp; It also provides basic information about running ESC/Java.
<p>This manual documents Version 1.2.2 of ESC/Java, built on
October 12, 2000.&nbsp;
We sometimes speak of ``the current ESC/Java'--rather than just ``ESC/Java''--to
emphasize that particular features, bugs, or limitations under discussion
are artifacts of the Version 1.2.2 implementation and may be subject to
change in future versions.&nbsp; Of course there is no guarantee that all
such aspects of ESC/Java will in fact change (nor that other aspects will
remain unchanged) as the tool evolves.
<p>This manual is designed to serve both as an introduction to ESC/Java
and as a reference manual.&nbsp; First-time readers may prefer to skip
the portions marked ``<b>Fine point(s)</b>'' as well as some other parts
that we have indicated.&nbsp; On the other hand, the extended example in
<a href="#0  An illustrative example of using ESC/Java">section
0</a> should be particularly helpful to first-time readers.
<p>For a much abridged treatment of the information in this manual, see
the ``ESC/Java Quick Reference'' [<a href="#[SLS00]">SLS00</a>].&nbsp;
The Quick Reference lists most of the specification language features described
in sections 2 and 3 of this manual and all the warning types described
in section 4, giving very brief descriptions of each.&nbsp; While it necessarily
omits numerous examples, tips, motivating discussions, and technical details
found in the present manual, it will still be of interest both the new
reader seeking a whirlwind tour of ESC/Java's features and to the experienced
user seeking a quick reminder about some ESC/Java feature.
<p>Although ESC/Java contains a full Java program verifier, the goal of
ESC/Java is not to provide formally rigorous program verification.&nbsp;
Rather, it is to help programmers find some kinds of errors more quickly
than they might be found by other methods, such as testing or code reviews.&nbsp;
Consequently, ESC/Java embodies engineering trade-offs among a number of
factors including the frequency of missed errors, the frequency of false
alarms, the amount of time used by the tool, the effort required to learn
and use the annotation language, and the effort required to implement the
tool.&nbsp; In this manual we attempt to give a precise description of
the syntax, type-checking, and other linguistic rules of the annotation
language, as well as a clear though informal description of the meanings
of the various pragmas.&nbsp; While we discuss potential sources of missed
errors or false alarms at various places in the manual, including a summary
in <a href="#Appendix C:  Sources of unsoundness and incompleteness ESC/Java">appendix
C</a>, we do not attempt to characterize precisely the degree of (in)accuracy
of ESC/Java's checking
<p>In many places we cite sections of <i>The Java Specification Language</i>,
by James Gosling, Bill Joy, and Guy Steele [<i><a href="#[JLS]">JLS</a></i>].&nbsp;
For example, the notation ``[<i>JLS</i>, 19.2]'' refers to section 19.2
of <i>The Java Language Specification</i>.&nbsp; The list of <a href="#References">references</a>
at the end of this manual gives bibliographic information for this and
other works cited herein.
<p>A specification notation and set of tools related to ESC/Java is the
Java Modeling Language (JML) [<a href="#[LBR99]">LBR99</a>, <a href="#[LBR00]">LBR00</a>,
<a href="#[LLPRJ00]">LLPRJ00</a>].&nbsp;
Through a collaborative effort, we have attempted to make the JML specification
language and the ESC/Java annotation language as similar as practical,
with JML providing a superset of the features of ESC/Java.&nbsp; The goals
of the two languages are different, so differences in the notations remain.&nbsp;
However, many programs annotated with ESC/Java annotations should be amenable
to processing with other JML tools, and programmers who learn one language
should have little trouble picking up the other as well.
<hr WIDTH="100%">
<h2>
<a NAME="Acknowledgments"></a>Acknowledgments</h2>
ESC/Java was originally designed and implemented at the Compaq Systems
Research Center (SRC) by Cormac Flanagan, Mark Lillibridge, Raymie Stata,
and the authors.&nbsp; Todd Millstein implemented
ESC/Java's execution trace facility and helped with other aspects of ESC/Java.&nbsp;
Caroline Tice and Rajeev Joshi lent helping hands with miscellaneous aspects
of the implementation, including reducing ESC/Java's memory footprint
(Tice) and getting the build recipe for the Simplify theorem prover to work
on multiple platforms (Joshi).
<p>The ESC/Java project is a follow-on to an earlier extended static checking
project at SRC targeting the Modula-3 language [<a href="#[DLNS98]">DLNS98</a>],
and continues to use the Simplify theorem prover developed as part of that
project.
<p>The authors thank our colleagues who have offered comments on earlier
versions of this manual. Allan Heydon, David Jefferson, Mark Lillibridge,
Silvija Seres, and Caroline Tice have been particularly helpful in this
regard.&nbsp; Silvija Seres compiled the initial version of the ESC/Java
Quick Reference [<a href="#[SLS00]">SLS00</a>] from an earlier version
of this manual.&nbsp; We and the other implementers of ESC/Java have benefited
from the feedback of early users, including Sanjay Ghemawat, Steve Glassman,
Allan Heydon, David Jefferson, Marc Najork, Keith Randall, and Silvija
Seres.&nbsp; Gary Leavens played a major role in our attempt to remove
gratuitous incompatibilities between ESC/Java and JML, and helped us to
improve the ESC/Java annotation language in the process.
<hr WIDTH="100%">
<h2>
<a NAME="Contents"></a>Contents</h2>

<blockquote><font size=+1><a href="#Preface">Preface</a></font>
<p><font size=+1><a href="#Acknowledgments">Acknowledgments</a></font></blockquote>

<blockquote><font size=+1><a href="#Contents">Contents</a></font>
<p><font size=+1><a href="#0  An illustrative example of using ESC/Java">0&nbsp;
An illustrative example of using ESC/Java</a></font>
<blockquote><a href="#0.0  Scene 0:  We write a class declaration.">0.0&nbsp;
Scene 0:&nbsp; We write a class declaration.</a>
<br><a href="#0.1  Scene 1:  We run ESC/Java, and it warns of two potential n">0.1&nbsp;
Scene 1:&nbsp; We run ESC/Java, and it warns of two potential <tt>null</tt>
dereferences.</a>
<br><a href="#0.2  Scene 2:  We write a requires (precondition) pragma for">0.2&nbsp;
Scene 2:&nbsp; We write a <tt>requires</tt> (precondition) pragma for the
<tt>Bag</tt>&nbsp;
constructor.</a>
<br><a href="#0.3  Scene 3:  We add a non_null pragma for the field a.">0.3&nbsp;
Scene 3:&nbsp; We add a <tt>non_null</tt> pragma for the field <tt>a</tt>.</a>
<br><a href="#0.4  Scene 4:  We correct a bug in Bag.extractMin.">0.4&nbsp;
Scene 4:&nbsp; We correct a bug in <tt>Bag.extractMin</tt>.</a>
<br><a href="#0.5  Scene 5:  We take no action for a redundant warning.">0.5&nbsp;
Scene 5:&nbsp; We take no action for a redundant warning.</a>
<br><a href="#0.6  Scene 6:  We supply a precondition for Bag.extractMin.">0.6&nbsp;
Scene 6:&nbsp; We supply a precondition for <tt>Bag.extractMin</tt>.</a>
<br><a href="#0.7  Scene 7:  We run ESC/Java again and it still issues a warn">0.7&nbsp;
Scene 7:&nbsp; We run ESC/Java again and it still issues a warning.</a>
<br><a href="#0.8  Scene 8:  We supply an invariant pragma relating n to a.le">0.8&nbsp;
Scene 8:&nbsp; We supply an <tt>invariant</tt> pragma relating
<tt>n</tt>
to <tt>a.lenght</tt>. [<i>sic</i>]</a>
<br><a href="#0.9  Scene 9:  ESC/Java notices a typographical error.">0.9&nbsp;
Scene 9:&nbsp; ESC/Java notices a typographical error.</a>
<br><a href="#0.10  Scene 10:  Our efforts come to a happy conclusion.">0.10&nbsp;
Scene 10:&nbsp; Our efforts come to a happy conclusion.</a></blockquote>
<font size=+1><a href="#1  An overview of ESC/Java and of this manual">1&nbsp;
An overview of ESC/Java and of this manual</a></font>
<ul>
<li>
<a href="#ESC/Java is a checker for Java programs, optionally annotated w">ESC/Java
is a checker for Java programs, optionally annotated with user-supplied
<i>pragmas</i>.</a></li>

<ul>
<li>
<a href="#ESC/Java pragmas must occur within pragma-containing comments.">ESC/Java
pragmas must occur within <i>pragma-containing comments</i></a>.</li>

<li>
<a href="#ESC/Java pragmas can contain expressions that are similar to Ja">ESC/Java
pragmas can contain expressions that are similar to Java expressions.</a></li>

<li>
<a href="#ESC/Java pragmas record programmer design decisions.">ESC/Java
pragmas record programmer design decisions.</a></li>

<li>
<a href="#ESC/Java pragmas support modular checking.">ESC/Java's pragmas
support <i>modular</i> checking.</a></li>

<li>
<a href="#When Java sources are unavailable, users can supply pragmas in">When
Java sources are unavailable, users can supply pragmas in <tt>.spec</tt>
files.</a></li>
</ul>

<li>
<a href="#ESC/Java is checker for almost all of Java 1.2.">ESC/Java is
checker for (almost all of) Java 1.2.</a></li>

<li>
<a href="#ESC/Java has a command-line interface like the Java compiler's.">ESC/Java
has a command-line interface like the Java compiler's.</a></li>

<li>
<a href="#ESC/Java issues warning messages for potential run-time errors.">ESC/Java
issues <i>warning</i> messages for potential run-time errors.</a></li>

<ul>
<li>
<a href="#The current ESC/Java checks only method and constructor bodies.">The
current ESC/Java checks only method and constructor bodies.</a></li>

<li>
<a href="#ESC/Java treats exceptions thrown by the Java run-time system a">ESC/Java
treats exceptions thrown by the Java run-time system as run-time errors.</a></li>

<li>
<a href="#ESC/Java does not warn of potential errors in the evaluation of">ESC/Java
does not warn of potential errors in the evaluation of specification expressions.</a></li>

<li>
<a href="#ESC/Java warning messages may include execution traces.">ESC/Java
warning messages may include <i>execution traces</i>.</a></li>
</ul>

<li>
<a href="#ESC/Java issues error messages for badly formed programs.">ESC/Java
issues <i>error</i> messages for badly formed programs.</a></li>

<ul>
<li>
<a href="#ESC/Java error messages are like compiler error messages.">ESC/Java
error messages are like compiler error messages.</a></li>

<li>
<a href="#ESC/Java doesn't detect all compile-time errors that Java compi">ESC/Java
doesn't detect all compile-time errors that Java compilers detect.</a></li>
</ul>

<li>
<a href="#ESC/Java's extended static checking isn't perfect.">ESC/Java's
extended static checking isn't perfect.</a></li>

<ul>
<li>
<a href="#ESC/Java can miss errors.">ESC/Java can miss errors.</a></li>

<li>
<a href="#ESC/Java can give spurious warnings.">ESC/Java can give spurious
warnings.</a></li>

<li>
<a href="#Pragmas give the user some control over ESC/Java's unsoundness">Pragmas
give the user some control over ESC/Java's unsoundness and incompleteness.</a></li>

<li>
<a href="#ESC/Java issues caution messages in some (but not all) cases wh">ESC/Java
issues <i>caution</i> messages in some (but not all) cases where unsound
checking may occur.</a></li>
</ul>
</ul>
<font size=+1><a href="#2  ESC/Java pragmas">2&nbsp; ESC/Java pragmas</a></font>
<blockquote><a href="#2.0  Rules about where pragmas may occur">2.0&nbsp;
Rules about where pragmas may occur</a>
<blockquote><a href="#2.0.0  ESC/Java pragmas must occur within pragma-containing com">2.0.0&nbsp;
ESC/Java pragmas must occur within <i>pragma-containing comments</i>.</a>
<br><a href="#2.0.1  There are four syntactic categories of pragmas.">2.0.1&nbsp;
There are four <i>syntactic categories</i> of pragmas.</a>
<br><a href="#2.0.2  ESC/Java sometimes allows pragmas to contain nested prag">2.0.2&nbsp;
ESC/Java sometimes allows pragmas to contain nested pragmas or comments</a>.</blockquote>
<a href="#2.1  The most basic pragmas">2.1&nbsp; The most basic pragmas</a>
<blockquote><a href="#2.1.0  nowarn pragma">2.1.0&nbsp; <tt>nowarn</tt>
pragma</a>
<br><a href="#2.1.1  assert pragma">2.1.1&nbsp; <tt>assert</tt> pragma</a>
<br><a href="#2.1.2  assume pragma">2.1.2&nbsp; <tt>assume</tt> pragma</a>
<br><a href="#2.1.3  unreachable pragma">2.1.3&nbsp; <tt>unreachable</tt>
pragma</a></blockquote>
<a href="#2.2  Some remarks concerning assert and assume">2.2&nbsp; Some
remarks concerning <tt>assert</tt> and <tt>assume</tt></a>
<blockquote><a href="#2.2.0  The assume pragma should be used with judgment.">2.2.0&nbsp;
The <tt>assume</tt> pragma should be used with judgment.</a>
<br><a href="#2.2.1  Most ESC/Java pragmas are just fancy forms of assert and">2.2.1
Most ESC/Java pragmas are just fancy forms of <tt>assert</tt> and <tt>assume</tt>.</a>
<br><a href="#2.2.2  A nowarn pragma suppresses warnings by turning assertion">2.2.2&nbsp;
A <tt>nowarn</tt> pragma suppresses warnings by turning assertions into
assumptions.</a>
<br><a href="#2.2.3  A helpful tip:  Experiments with assert and assume pragm">2.2.3&nbsp;
A helpful tip:&nbsp; Experiments with <tt>assert</tt> and <tt>assume</tt>
pragmas can help you understand ESC/Java's behavior and debug your annotated
code.</a></blockquote>
<a href="#2.3  Pragmas for specifying routines">2.3&nbsp; Pragmas for specifying
routines</a>
<blockquote><a href="#2.3.0  requires pragma">2.3.0&nbsp; <tt>requires</tt>
pragma</a>
<br><a href="#2.3.1  modifies pragma">2.3.1&nbsp; <tt>modifies</tt> pragma</a>
<blockquote><a href="#2.3.1.0  target fields">2.3.1.0&nbsp; target fields</a></blockquote>
<a href="#2.3.2  ensures pragma">2.3.2&nbsp; <tt>ensures</tt> pragma</a>
<br><a href="#2.3.3  A note on the interaction of modifies and \old">2.3.3&nbsp;
A note on the interaction of <tt>modifies</tt> and <tt>\old</tt></a>
<br><a href="#2.3.4  exsures pragma">2.3.4&nbsp; <tt>exsures</tt> pragma</a>
<br><a href="#2.3.5  also_ensures pragma">2.3.5&nbsp; <tt>also_ensures</tt>
pragma</a>
<br><a href="#2.3.6  also_exsures pragma">2.3.6&nbsp; <tt>also_exsures</tt>
pragma</a>
<br><a href="#2.3.7  also_requires pragma">2.3.7&nbsp; <tt>also_requires</tt>
pragma</a>
<br><a href="#2.3.8  also_modifies pragma">2.3.8&nbsp; <tt>also_modifies</tt>
pragma</a></blockquote>
<a href="#2.4  Pragmas for specifying data invariants">2.4&nbsp; Pragmas
for specifying data invariants</a>
<blockquote><a href="#2.4.0  non_null pragma">2.4.0&nbsp; <tt>non_null</tt>
pragma</a>
<br><a href="#2.4.1  invariant pragma">2.4.1&nbsp; <tt>invariant</tt> pragma</a>
<br><a href="#2.4.2  axiom pragma">2.4.2&nbsp; <tt>axiom</tt> pragma</a>
<br><a href="#2.4.3  loop_invariant pragma">2.4.3&nbsp; <tt>loop_invariant</tt>
pragma</a></blockquote>
<a href="#2.5  Pragmas affecting conditions under which variables may be">2.5&nbsp;
Pragmas affecting conditions under which variables may be referenced</a>
<blockquote><a href="#2.5.0  spec_public pragma">2.5.0&nbsp; <tt>spec_public</tt>
pragma</a>
<br><a href="#2.5.1  readable_if pragma">2.5.1&nbsp; <tt>readable_if</tt>
pragma</a>
<br><a href="#2.5.2  uninitialized pragma">2.5.2&nbsp; <tt>uninitialized</tt>
pragma</a></blockquote>
<a href="#2.6  Pragmas concerning ghost variables">2.6&nbsp; Pragmas concerning
ghost variables</a>
<blockquote><a href="#2.6.0  ghost pragma">2.6.0&nbsp; <tt>ghost</tt> pragma</a>
<br><a href="#2.6.1  set pragma">2.6.1&nbsp; <tt>set</tt> pragma</a>
<br><a href="#2.6.2  Examples using ghost variables">2.6.2&nbsp; Examples
using ghost variables</a></blockquote>
<a href="#2.7  Pragmas for specifying synchronization">2.7&nbsp; Pragmas
for specifying synchronization</a>
<blockquote><a href="#2.7.0  monitored_by pragma">2.7.0&nbsp; <tt>monitored_by</tt>
pragma</a>
<br><a href="#2.7.1  monitored pragma">2.7.1&nbsp; <tt>monitored</tt> pragma</a>
<br><a href="#2.7.2  Examples illustrating race and deadlock checking">2.7.2&nbsp;
Examples illustrating race and deadlock checking</a></blockquote>
</blockquote>
<font size=+1><a href="#3  Specification expressions">3&nbsp; Specification
expressions</a></font>
<blockquote><a href="#3.0  Specification types">3.0&nbsp; Specification
types</a>
<br><a href="#3.1  Restrictions">3.1&nbsp; Restrictions</a>
<br><a href="#3.2  Additions">3.2&nbsp; Additions</a>
<blockquote><a href="#3.2.0  \type">3.2.0&nbsp; <tt>\type</tt></a>
<br><a href="#3.2.1  \typeof">3.2.1&nbsp; <tt>\typeof</tt></a>
<br><a href="#3.2.2  \elemtype">3.2.2&nbsp; <tt>\elemtype</tt></a>
<br><a href="#3.2.3   Subtype:  <:">3.2.3&nbsp; Subtype:&nbsp; <tt>&lt;:</tt></a>
<br><a href="#3.2.4  Examples involving \TYPE, \type, \typeof, \elemtype, and <:">3.2.4&nbsp;
Examples involving <tt>\TYPE</tt>, <tt>\type</tt>, <tt>\typeof</tt>, <tt>\elemtype</tt>,
and <tt>&lt;:</tt></a>
<br><a href="#3.2.5  \lockset">3.2.5&nbsp; <tt>\lockset</tt></a>
<br><a href="#3.2.6  Membership in lock sets:  [ ]">3.2.6&nbsp; Membership
in lock sets:&nbsp; <tt>[ ]</tt></a>
<br><a href="#3.2.7  Lock order:  < and <=">3.2.7&nbsp; Lock order: <tt>&lt;</tt>
and <tt>&lt;=</tt></a>
<br><a href="#3.2.8  \max">3.2.8&nbsp; <tt>\max</tt></a>
<br><a href="#3.2.9  Implication:  ==>">3.2.9&nbsp; Implication: <tt>==></tt></a>
<br><a href="#3.2.10  \forall">3.2.10&nbsp; <tt>\forall</tt></a>
<br><a href="#3.2.11  \exists">3.2.11&nbsp; <tt>\exists</tt></a>
<br><a href="#3.2.12  \nonnullelements">3.2.12&nbsp; <tt>\nonnullelements</tt></a>
<br><a href="#3.2.13  \fresh">3.2.13&nbsp; <tt>\fresh</tt></a>
<br><a href="#3.2.14  \result">3.2.14&nbsp; <tt>\result</tt></a>
<br><a href="#3.2.15  \old">3.2.15&nbsp; <tt>\old</tt></a>
<br><a href="#3.2.16  \lblneg and \lblpos">3.2.16&nbsp; <tt>\lblneg</tt>
and
<tt>\lblpos</tt></a>
<br><a href="#3.2.17 owner">3.2.17 <tt>owner</tt></a></blockquote>
<a href="#3.3  Scoping, name resolution, and access control in specificat">3.3
Scoping, name resolution, and access control in specification expressions</a></blockquote>
<font size=+1><a href="#4  Warnings">4&nbsp; Warnings</a></font>
<blockquote><a href="#4.0  Parts of ESC/Java warning messages">4.0&nbsp;
Parts of ESC/Java warning messages</a>
<br><a href="#4.1  ArrayStore warning">4.1&nbsp; <tt>ArrayStore</tt> warning</a>
<br><a href="#4.2  Assert warning">4.2&nbsp; <tt>Assert</tt> warning</a>
<br><a href="#4.3  Cast warning">4.3&nbsp; <tt>Cast</tt> warning</a>
<br><a href="#4.4  Deadlock warning">4.4&nbsp; <tt>Deadlock</tt> warning</a>
<br><a href="#4.5  Exception warning">4.5&nbsp; <tt>Exception</tt> warning</a>
<br><a href="#4.6  IndexNegative warning">4.6&nbsp; <tt>IndexNegative</tt>
warning</a>
<br><a href="#4.7  IndexTooBig warning">4.7&nbsp; <tt>IndexTooBig</tt>
warning</a>
<br><a href="#4.8  Invariant warning">4.8&nbsp; <tt>Invariant</tt> warning</a>
<br><a href="#4.9  LoopInv warning">4.9&nbsp; <tt>LoopInv</tt> warning</a>
<br><a href="#4.10  NegSize warning">4.10&nbsp; <tt>NegSize</tt> warning</a>
<br><a href="#4.11  NonNull warning">4.11&nbsp; <tt>NonNull</tt> warning</a>
<br><a href="#4.12  NonNullInit warning">4.12&nbsp; <tt>NonNullInit</tt>
warning</a>
<br><a href="#4.13  Null warning">4.13&nbsp; <tt>Null</tt> warning</a>
<br><a href="#4.14  OwnerNull warning">4.14&nbsp; <tt>OwnerNull</tt> warning</a>
<br><a href="#4.15  Post warning">4.15&nbsp; <tt>Post</tt> warning</a>
<br><a href="#4.16  Pre warning">4.16&nbsp; <tt>Pre</tt> warning</a>
<br><a href="#4.17  Race warning">4.17&nbsp; <tt>Race</tt> warning</a>
<br><a href="#4.18  Reachable warning">4.18&nbsp; <tt>Reachable</tt> warning</a>
<br><a href="#4.19  Unreadable warning">4.19&nbsp; <tt>Unreadable</tt>
warning</a>
<br><a href="#4.20  Uninit warning">4.20&nbsp; <tt>Uninit</tt> warning</a>
<br><a href="#4.21  ZeroDiv warning">4.21&nbsp; <tt>ZeroDiv</tt> warning</a></blockquote>
<font size=+1><a href="#5  Command-line options and environment variables">5&nbsp;
Command-line options and environment variables</a></font>
<blockquote><a href="#5.0  -suggest">5.0&nbsp; <tt>-suggest</tt></a>
<br><a href="#5.1  Specification (.spec) files and the ESC/Java's class path">5.1&nbsp;
Specification (<tt>.spec</tt>) files and the ESC/Java's class path</a>
<blockquote><a href="#5.1.0  File reading modes">5.1.0&nbsp; File reading
modes</a>
<br><a href="#5.1.1  The ESC/Java class path (-classpath, CLASSPATH, -bootcla">5.1.1&nbsp;
The ESC/Java class path (<tt>-classpath</tt>, <tt>CLASSPATH</tt>, <tt>-bootclasspath</tt>)</a>
<br><a href="#5.1.2  Specification (.spec) files">5.1.2&nbsp; Specification
(<tt>.spec</tt>) files</a>
<br><a href="#5.1.3  How ESC/Java decides which files to read and in which mo">5.1.3&nbsp;
How ESC/Java decides which files to read and in which modes</a>
<br><a href="#5.1.4  -depend">5.1.4&nbsp; <tt>-depend</tt></a></blockquote>
</blockquote>
<font size=+1><a href="#6  Java language support and limitations">6&nbsp;
Java language support and limitations</a></font>
<p><font size=+1><a href="#Appendix A:  Overview of how ESC/Java works">Appendix
A:&nbsp; Overview of how ESC/Java works</a></font>
<p><font size=+1><a href="#Appendix B:  Installing and using ESC/Java at your site">Appendix
B:&nbsp; Installing and using ESC/Java at your site</a></font>
<p><font size=+1><a href="#Appendix C:  Sources of unsoundness and incompleteness ESC/Java">Appendix
C:&nbsp; Sources of unsoundness and incompleteness ESC/Java</a></font>
<blockquote><a href="#C.0  Known sources of unsoundness">C.0&nbsp; Known
sources of unsoundness</a>
<blockquote><a href="#C.0.0  Trusting pragmas">C.0.0&nbsp; Trusting pragmas</a>
<br><a href="#C.0.1  Loops">C.0.1&nbsp; Loops</a>
<br><a href="#C.0.2  Object invariants">C.0.2&nbsp; Object invariants</a>
<br><a href="#C.0.3  Modification targets">C.0.3&nbsp; Modification targets</a>
<br><a href="#C.0.4  The also_modifies and also_requires pragmas">C.0.4&nbsp;
The <tt>also_modifies</tt> and <tt>also_requires</tt> pragmas</a>
<br><a href="#C.0.5  Multiple inheritance">C.0.5&nbsp; Multiple inheritance</a>
<br><a href="#C.0.6  Arithmetic overflow">C.0.6&nbsp; Arithmetic overflow</a>
<br><a href="#C.0.7  Ignored exceptional conditions">C.0.7&nbsp; Ignored
exceptional conditions</a>
<br><a href="#C.0.8  Constructor leaking">C.0.8&nbsp; Constructor leaking</a>
<br><a href="#C.0.9  Static initialization">C.0.9&nbsp; Static initialization</a>
<br><a href="#C.0.10  Class paths and .spec files">C.0.10&nbsp; Class paths
and <tt>.spec files</tt></a>
<br><a href="#C.0.11  Shared variables">C.0.11&nbsp; Shared variables</a>
<br><a href="#C.0.12  Initialization of fields declared non_null">C.0.12&nbsp;
Initialization of fields declared <tt>non_null</tt></a>
<br><a href="#C.0.13  String literals">C.0.13&nbsp; String literals</a>
<br><a href="#C.0.14  Search limits in Simplify">C.0.14&nbsp; Search limits
in Simplify</a>
<br><a href="#C.0.15  Integer arithmetic bug in Simplify">C.0.15&nbsp;
Integer arithmetic bug in Simplify</a></blockquote>
<a href="#C.1  Some sources of incompleteness">C.1&nbsp; Some sources of
incompleteness</a>
<blockquote><a href="#C.1.0  Incompleteness of the theorem-prover">C.1.0&nbsp;
Incompleteness of the theorem-prover</a>
<br><a href="#C.1.1  Incomplete modeling of Java semantics">C.1.1&nbsp;
Incomplete modeling of Java semantics</a>
<br><a href="#C.1.2  Modular checking">C.1.2&nbsp; Modular checking</a></blockquote>
</blockquote>
<font size=+1><a href="#References">References</a></font></blockquote>

<h2>

<hr WIDTH="100%"></h2>

<h2>
<a NAME="0  An illustrative example of using ESC/Java"></a>0&nbsp; An illustrative
example of using ESC/Java</h2>
To give the reader a general idea of what ESC/Java does and how to use
it, we begin with an example illustrating some salient features of ESC/Java
through its application to a simple class declaration deliberately seeded
with some errors.
<h3>
<a NAME="0.0  Scene 0:  We write a class declaration."></a>0.0&nbsp; Scene
0:&nbsp; We write a class declaration.</h3>
Our example is the class <tt>Bag</tt> declared in a file <tt>Bag.java</tt>
as follows:
<blockquote><tt><font size=-2>line</font></tt>
<br><tt><font size=-2>&nbsp;1:&nbsp; </font>class Bag {</tt>
<br><tt><font size=-2>&nbsp;2:&nbsp;&nbsp;</font>&nbsp; int[] a;</tt>
<br><tt><font size=-2>&nbsp;3:&nbsp;&nbsp;</font>&nbsp; int n;</tt>
<br><tt><font size=-2>&nbsp;4:</font></tt>
<br><tt><font size=-2>&nbsp;5:&nbsp;&nbsp;</font>&nbsp; Bag(int[] input)
{</tt>
<br><tt><font size=-2>&nbsp;6:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; n =
input.length;</tt>
<br><tt><font size=-2>&nbsp;7:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; a =
new int[n];</tt>
<br><tt><font size=-2>&nbsp;8:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; System.arraycopy(input,
0, a, 0, n);</tt>
<br><tt><font size=-2>&nbsp;9:&nbsp;&nbsp;</font>&nbsp; }</tt>
<br><tt><font size=-2>10:</font></tt>
<br><tt><font size=-2>11:&nbsp;&nbsp;</font>&nbsp; int extractMin() {</tt>
<br><tt><font size=-2>12:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; int m =
Integer.MAX_VALUE;</tt>
<br><tt><font size=-2>13:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; int mindex
= 0;</tt>
<br><tt><font size=-2>14:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; for (int
i = 1; i &lt;= n; i++) {</tt>
<br><tt><font size=-2>15:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (a[i] &lt; m) {</tt>
<br><tt><font size=-2>16:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mindex = i;</tt>
<br><tt><font size=-2>17:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m = a[i];</tt>
<br><tt><font size=-2>18:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt><font size=-2>19:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt><font size=-2>20:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; n--;</tt>
<br><tt><font size=-2>21:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; a[mindex]
= a[n];</tt>
<br><tt><font size=-2>22:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; return m;</tt>
<br><tt><font size=-2>23:&nbsp;&nbsp;</font>&nbsp; }</tt>
<br><tt><font size=-2>24:&nbsp; </font>}</tt></blockquote>
A copy of this program is in <i>escjavaRoot</i><tt>/examples/0.0/Bag.java</tt>,
where <i>escjavaRoot</i> denotes the (site-specific) top-level directory
for ESC/Java (see <a href="#Appendix B:  Installing and using ESC/Java at your site">appendix
B</a>).&nbsp; The idea is that an object <tt>x</tt> of class <tt>Bag</tt>
represents a multiset (also known as a ``bag'') of integers in the form
of integer array <tt>x.a</tt> together with an integer <tt>x.n</tt>, where
the elements of the multiset are the first <tt>x.n</tt> elements of the
array.&nbsp; In our example declaration, we define a constructor that creates
a <tt>Bag</tt> from an array, and a single method <tt>extractMin</tt> that
finds, removes, and returns the minimal element of a <tt>Bag</tt>. The
<tt>extractMin</tt>
method iterates over the first <tt>this.n</tt> elements of <tt>this.a</tt>,
keeping track of the smallest one in the local variable
<tt>m</tt> .&nbsp;
After finding the smallest element of <tt>this.a</tt>,&nbsp; it copies
the element at the highest used position of <tt>x.a</tt> into the position
formerly occupied by the minimum element, decreases the count of used elements,
and returns the value that was saved in <tt>m</tt> .
<h3>
<a NAME="0.1  Scene 1:  We run ESC/Java, and it warns of two potential n"></a>0.1&nbsp;
Scene 1:&nbsp; We run ESC/Java, and it warns of two potential <tt>null</tt>
dereferences.</h3>
To compile <tt>Bag.java</tt>, we would type the command line:
<blockquote><tt>javac Bag.java</tt></blockquote>
To check our definition of class <tt>Bag</tt> with ESC/Java, we instead
type the following similar command line:
<blockquote><tt>escjava Bag.java</tt></blockquote>
ESC/Java then produces the following output:
<blockquote><tt>Bag.java:6: Warning: Possible null dereference (Null)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; n = input.length;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>Bag.java:15: Warning: Possible null dereference (Null)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a[i] &lt; m) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</tt>
<br><tt>Execution trace information:</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Completed 0 loop iterations in "Bag.java", line
14, col 4.</tt>
<p><tt>Bag.java:15: Warning: Array index possibly too large (IndexTooBig)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a[i] &lt; m) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</tt>
<br><tt>Execution trace information:</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Completed 0 loop iterations in "Bag.java", line
14, col 4.</tt>
<p><tt>Bag.java:21: Warning: Possible null dereference (Null)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a[mindex] = a[n];</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>Execution trace information:</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Completed 0 loop iterations in "Bag.java", line
14, col 4.</tt>
<p><tt>Bag.java:21: Warning: Possible negative array index (IndexNegative)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a[mindex] = a[n];</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>Execution trace information:</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Completed 0 loop iterations in "Bag.java", line
14, col 4.</tt>
<p><tt>5 warnings</tt>
<p><font size=-1><b>Remark:</b>&nbsp; Actually,&nbsp; the above is the
output generated by the command</font>
<blockquote><tt><font size=-1>escjava -quiet Bag.java</font></tt></blockquote>
<font size=-1>The normal output of ESC/Java also includes various progress
messages and timing information which are omitted here.</font>
<p><font size=-1><b>Remark:</b>&nbsp; Some of the messages above include
a part marked as ``<tt>Execution trace information</tt>''.&nbsp; We say
more about execution traces below, particularly in <a href="#4.0  Parts of ESC/Java warning messages">section
4.0</a>, but will not discuss them further in the course of this introductory
example.</font></blockquote>

<h3>
<a NAME="0.2  Scene 2:  We write a requires (precondition) pragma for"></a>0.2&nbsp;
Scene 2:&nbsp; We write a <tt>requires</tt> (precondition) pragma for the
<tt>Bag</tt>
constructor.</h3>
ESC/Java's first warning is that the attempt on line 6 to access <tt>input.length</tt>
might fail because <tt>input</tt> might be <tt>null</tt>.&nbsp; We now
must decide what to do about this warning.
<p>One approach would be to decide that the implementation of the constructor
is incorrect.&nbsp; Following this approach, we would modify the constructor
to test for a null argument and, for example, construct an empty multiset:
<blockquote><tt>&nbsp; Bag(int[] input) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if (input == null) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = new int[0];</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = input.length;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = new int[n];</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.arraycopy(input, 0, a, 0,
n);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt></blockquote>
This would indeed eliminate the first warning.&nbsp; Instead, however,
we will continue our example by illustrating a second approach, in which
we decide that the implementation of the constructor is correct, but that
we do not intend for the constructor ever to be called with a null argument.&nbsp;
We inform ESC/Java of this decision by adding an annotation to the constructor
declaration:
<blockquote><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp;
//@ requires input != null;</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; Bag(int[]
input) {</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;
n = input.length;</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; </tt>...</blockquote>
When the character <tt>@</tt> is the first character after the initial
<tt>//</tt>
or <tt>/*</tt> of a Java comment, as in the first line of the program fragment
above, ESC/Java expects the body of the comment to consist of a sequence
of ESC/Java annotations, known as <i>pragmas</i>.&nbsp; The
<tt>requires</tt>
pragma above specifies a <i>precondition</i> for the constructor, that
is, a boolean expression which must be <tt>true</tt> at the start of any
call.&nbsp; When checking the body of a method or constructor that is annotated
with a precondition, ESC/Java can assume the truth of the precondition
to confirm the absence of errors in the body (for example, the absence
of a null dereference during the evaluation of <tt>input.length</tt> in
the code fragment above).&nbsp; When checking code that calls a method
or constructor annotated with a precondition, ESC/Java will issue a warning
if it cannot confirm that the precondition (with the values of the actual
parameters substituted for the formal parameter names) would always evaluate
to <tt>true</tt> at the call site.
<h3>
<a NAME="0.3  Scene 3:  We add a non_null pragma for the field a."></a>0.3&nbsp;
Scene 3:&nbsp; We add a <tt>non_null</tt> pragma for the field <tt>a</tt>.</h3>
So much for the first warning.&nbsp; We now turn our attention to the second
warning:
<blockquote><tt>Bag.java:15: Warning: Possible null dereference (Null)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a[i] &lt; m) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</tt></blockquote>
Here, ESC/Java is warning that the array variable <tt>a</tt> (actually
<tt>this.a</tt>)
might be <tt>null</tt>.&nbsp; We could deal with this warning by either
of the approaches discussed above in connection with the first warning--that
is, by adding the precondition <tt>requires a != null</tt> to the <tt>extractMin</tt>
method, or by adding special code for the case <tt>a == null</tt>. However
ESC/Java offers yet another choice, which is to specify that the <tt>a</tt>
field of any <tt>Bag</tt> is always supposed to be non-null.&nbsp; To do
this, we annotate the declaration of <tt>a</tt> with a <tt>non_null</tt>
pragma:
<blockquote><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp; </font>class Bag
{</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; /*@ non_null
*/ int[] a;</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; </tt>...</blockquote>
This causes ESC/Java to assume that the <tt>a</tt> field of any <tt>Bag</tt>
object is itself non-null (and thus can safely be dereferenced).&nbsp;
Conversely, it causes ESC/Java to issue a warning for any assignment to
the <tt>a</tt> field of a <tt>Bag</tt>, if it cannot confirm that the expression
being assigned will have a non-null value at run time.&nbsp; Furthermore
ESC/Java will check that every <tt>Bag</tt> constructor initializes the
<tt>a</tt>
field of the constructed object to a non-null value.
<h3>
<a NAME="0.4  Scene 4:  We correct a bug in Bag.extractMin."></a>0.4&nbsp;
Scene 4:&nbsp; We correct a bug in <tt>Bag.extractMin</tt>.</h3>
We now consider the third warning:
<blockquote><tt>Bag.java:15: Warning: Array index possibly too large (IndexTooBig)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a[i] &lt; m) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</tt></blockquote>
Examining the program, we now find a genuine bug.&nbsp; The <tt>for</tt>
loop starting on line 15 (in the original program) examines array elements
<tt>a[1]</tt>
through
<tt>a[n]</tt>, but array indexing in Java is zero based.&nbsp;
We correct the line to read
<blockquote><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;
for (int i = 0; i &lt; n; i++) {</tt></blockquote>

<h3>
<a NAME="0.5  Scene 5:  We take no action for a redundant warning."></a>0.5&nbsp;
Scene 5:&nbsp; We take no action for a redundant warning.</h3>
The fourth warning
<blockquote><tt>Bag.java:21: Warning: Possible null dereference (Null)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a[mindex] = a[n];</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
requires no action, as the <tt>non_null</tt> pragma we added in section
0.3 already prevents <tt>a</tt> from being <tt>null.</tt>&nbsp; In other
words, the second and fourth warnings complain about the same problem.
<blockquote><font size=-1><b>Remark:</b>&nbsp; ESC/Java often avoids issuing
such redundant warnings.&nbsp; Note, for example, that it doesn't complain
about the expression <tt>a[m]</tt> on (original) line 17, or the expression
<tt>a[mindex]</tt>
on the left hand side of the assignment on (original) line 21.&nbsp; However,
it does not avoid them in all cases.&nbsp; A detailed description of the
circumstances in which ESC/Java will or will not issue multiple warnings
with the same underlying cause is beyond the scope of this manual.</font></blockquote>

<h3>
<a NAME="0.6  Scene 6:  We supply a precondition for Bag.extractMin."></a>0.6&nbsp;
Scene 6:&nbsp; We supply a precondition for <tt>Bag.extractMin</tt>.</h3>
We now consider the last of the five warnings:
<blockquote><tt>Bag.java:21: Warning: Possible negative array index (IndexNegative)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a[mindex] = a[n];</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
The problem is that the code in (original) lines 20-21 removes an element
from the bag even when the bag is already empty (that is, when <tt>this.n
== 0</tt> on entry to <tt>extractMin</tt>).&nbsp; ESC/Java has called our
attention to the need for another design decision:&nbsp; do we add special
code to handle the situation when
<tt>extractMin</tt> is called on an empty
bag, or do we add a precondition forbidding such calls?&nbsp; Let's try
the latter course:
<blockquote><tt><font size=-2>12:&nbsp;</font>&nbsp;&nbsp; //@ requires
n >= 1;</tt>
<br><tt><font size=-2>13:&nbsp;&nbsp;</font>&nbsp; int extractMin() {</tt></blockquote>

<h3>
<a NAME="0.7  Scene 7:  We run ESC/Java again and it still issues a warn"></a>0.7
Scene 7:&nbsp; We run ESC/Java again and it still issues a warning.</h3>
With all the changes described above, our example program now reads:
<blockquote><tt><font size=-2>&nbsp;1:&nbsp; </font>class Bag {</tt>
<br><tt><font size=-2>&nbsp;2:&nbsp;&nbsp;</font>&nbsp; /*@ non_null */
int[] a;</tt>
<br><tt><font size=-2>&nbsp;3:&nbsp;&nbsp;</font>&nbsp; int n;</tt>
<br><tt><font size=-2>&nbsp;4:</font></tt>
<br><tt><font size=-2>&nbsp;5:&nbsp;&nbsp;</font>&nbsp; //@ requires input
!= null;</tt>
<br><tt><font size=-2>&nbsp;6:&nbsp;&nbsp;</font>&nbsp; Bag(int[] input)
{</tt>
<br><tt><font size=-2>&nbsp;7:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; n =
input.length;</tt>
<br><tt><font size=-2>&nbsp;8:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; a =
new int[n];</tt>
<br><tt><font size=-2>&nbsp;9:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; System.arraycopy(input,
0, a, 0, n);</tt>
<br><tt><font size=-2>10&nbsp;&nbsp;</font>&nbsp;&nbsp; }</tt>
<br><tt><font size=-2>11:</font></tt>
<br><tt><font size=-2>12:&nbsp;&nbsp;</font>&nbsp; //@ requires n >= 1;</tt>
<br><tt><font size=-2>12:&nbsp;&nbsp;</font>&nbsp; int extractMin() {</tt>
<br><tt><font size=-2>13:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; int m =
Integer.MAX_VALUE;</tt>
<br><tt><font size=-2>14:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; int mindex
= 0;</tt>
<br><tt><font size=-2>15:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; for (int
i = 0; i &lt; n; i++) {</tt>
<br><tt><font size=-2>16:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (a[i] &lt; m) {</tt>
<br><tt><font size=-2>17:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mindex = i;</tt>
<br><tt><font size=-2>18:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m = a[i];</tt>
<br><tt><font size=-2>19:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt><font size=-2>20:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt><font size=-2>21:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; n--;</tt>
<br><tt><font size=-2>22:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; a[mindex]
= a[n];</tt>
<br><tt><font size=-2>23:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; return m;</tt>
<br><tt><font size=-2>24:&nbsp;&nbsp;</font>&nbsp; }</tt>
<br><tt><font size=-2>25:&nbsp; </font>}</tt></blockquote>
We now run ESC/Java again and it produces the following warning:
<blockquote><tt>Bag.java:17: Warning: Array index possibly too large (IndexTooBig)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a[i] &lt; m) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</tt></blockquote>

<h3>
<a NAME="0.8  Scene 8:  We supply an invariant pragma relating n to a.le"></a>0.8&nbsp;
Scene 8:&nbsp; We supply an <tt>invariant</tt> pragma relating
<tt>n</tt>
to <tt>a.length</tt>.</h3>
It may appear that ESC/Java is still complaining about the bug we thought
we'd fixed in section 0.4, but further study reveals a different problem:&nbsp;
ESC/Java has no reason to expect that <tt>n</tt>, which we intend to be
the length of the meaningful prefix of <tt>a</tt>, will in fact be at most
<tt>a.length</tt>.&nbsp;&nbsp;
We can express this intention with an <tt>invariant</tt> pragma:
<blockquote><tt><font size=-2>&nbsp;1:&nbsp; </font>class Bag {</tt>
<br><tt><font size=-2>&nbsp;2:&nbsp;&nbsp;</font>&nbsp; /*@ non_null */
int[] a;</tt>
<br><tt><font size=-2>&nbsp;3:&nbsp;&nbsp;</font>&nbsp; int n;</tt>
<br><tt><font size=-2>&nbsp;4:&nbsp;&nbsp;</font>&nbsp; //@ invariant 0
&lt;= n &amp; n &lt;= a.lenght;</tt>
<br>...</blockquote>
Roughly speaking, ESC/Java treats an invariant as an implicit postcondition
of every constructor and as both a precondition and postcondition of every
method.&nbsp; The semantics of <tt>invariant</tt> pragmas--and all other
ESC/Java pragmas--are described in greater detail in <a href="#2  ESC/Java pragmas">section
2</a> below.&nbsp; The full rules about expressions that can occur in pragmas
(called <i>specification expressions</i>) are given in section 3.&nbsp;
For now, we remark that since specification expressions are not actually
executed, the unconditional logical operators <tt>&amp;</tt> and <tt>|</tt>
are interchangeable (except for binding power) in specification expressions
with the respective conditional operators <tt>&amp;&amp;</tt> and <tt>||</tt>.
<h3>
<a NAME="0.9  Scene 9:  ESC/Java notices a typographical error."></a>0.9&nbsp;
Scene 9:&nbsp; ESC/Java notices a typographical error.</h3>
When we run ESC/Java again, the result is:
<blockquote><tt>Bag.java:4: Error: No such field in type int[]</tt>
<br><tt>&nbsp; //@ invariant 0 &lt;= n &amp; n &lt;= a.lenght;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>Caution: Turning off extended static checking due to type error(s)</tt>
<br><tt>1 caution</tt>
<br><tt>1 error</tt></blockquote>

<h3>
<a NAME="0.10  Scene 10:  Our efforts come to a happy conclusion."></a>0.10&nbsp;
Scene 10:&nbsp; Our efforts come to a happy conclusion.</h3>
Whoops!&nbsp; Our <tt>invariant</tt> pragma had a spelling error. We correct
it to read
<blockquote><tt><font size=-2>&nbsp;4:&nbsp;&nbsp;&nbsp;</font> //@ invariant
0 &lt;= n &amp; n &lt;= a.length;</tt></blockquote>
and try again.&nbsp; This time ESC/Java runs without reporting any further
complaints.
<p>The file <i>escjavaRoot</i><tt>/examples/0.10/Bag.java</tt> contains
a copy of the final version of the <tt>Bag</tt> class.
<hr WIDTH="100%">
<h2>
<a NAME="1  An overview of ESC/Java and of this manual"></a>1&nbsp; An
overview of ESC/Java and of this manual</h2>
In this section we summarize the principal features of ESC/Java. While
some of the things we say here reiterate points made in our example of
<a href="#0  An illustrative example of using ESC/Java">section
0</a>, we also describe a number of features of ESC/Java that are not discussed
at all in <a href="#0  An illustrative example of using ESC/Java">section
0</a>.&nbsp; Moreover, we address a number of points that were glossed
over in <a href="#0  An illustrative example of using ESC/Java">section
0</a>, and that possibly raised questions in the mind of the perceptive
reader.&nbsp; Throughout this section we refer the reader to later parts
of this manual where various topics are discussed in more detail.
<ul>
<li>
<a NAME="ESC/Java is a checker for Java programs, optionally annotated w"></a><b>ESC/Java
is a checker for Java programs, optionally annotated with user-supplied
<i>pragmas</i>.</b></li>

<ul>
<li>
<a NAME="ESC/Java pragmas must occur within pragma-containing comments."></a><b>ESC/Java
pragmas must occur within <i>pragma-containing comments</i>.</b></li>

<br>We showed some examples of pragma-containing comments in <a href="#0  An illustrative example of using ESC/Java">section
0</a>.&nbsp; <a href="#2  ESC/Java pragmas">Section 2</a> includes all
the rules about where the various kinds of pragmas are allowed.
<li>
<a NAME="ESC/Java pragmas can contain expressions that are similar to Ja"></a><b>ESC/Java
pragmas can contain expressions that are similar to Java expressions.</b></li>

<br>The ESC/Java <i>specification language</i>--that is, the language of
ESC/Java pragmas--includes expressions, which we call <i>specification
expressions</i>, or <i>SpecExpr</i>'s.&nbsp; While the syntax, name-resolution,
and type-checking rules for specification expressions are similar to those
for
ordinary Java expressions, there are inevitably some differences.&nbsp;
The rules for specification expressions are described in <a href="#3  Specification expressions">section
3</a> of this manual.
<li>
<a NAME="ESC/Java pragmas record programmer design decisions."></a><b>ESC/Java
pragmas record programmer design decisions.</b></li>

<br>In addition to giving the user control over ESC/Java, pragmas serve
to record formally some of the programmer's intentions about the function
and use of methods, constructors, and variables (for example, that the
<tt>Bag</tt>
constructor of our example in <a href="#0  An illustrative example of using ESC/Java">section
0</a> was meant never to be called with a <tt>null</tt> argument). These
are the same sorts of intentions that good programmers may already record
informally in natural language comments.
<li>
<a NAME="ESC/Java pragmas support modular checking."></a><b>ESC/Java's
pragmas support <i>modular</i> checking.</b></li>

<br>The checking done by ESC/Java is <i>modular.</i>&nbsp; When checking
the body of a <i>routine</i> (that is, a method or constructor) <tt>r</tt>,
ESC/Java does not examine bodies of routines called by <tt>r</tt>.&nbsp;
Rather, it relies on the <i>specifications</i> of those routines, as expressed
by <tt>requires</tt> pragmas, by other pragmas described below, and by
Java constructs such as signatures, return types, and <tt>throws</tt> clauses.
Conversely, to check the body of <tt>r</tt>, ESC/Java does not examine
callers of <tt>r</tt>.&nbsp; It does, however, assume that <tt>r</tt> is
called only in accordance with its own specification.
<li>
<a NAME="When Java sources are unavailable, users can supply pragmas in"></a><b>When
Java sources are unavailable, users can supply pragmas in <tt>.spec </tt>files.</b></li>

<br>When the file declaring a class <tt>T</tt> uses a type <tt>U</tt>,
ESC/Java may need data invariants of <tt>U</tt> and/or specifications of
<tt>U</tt>'s
routines in order to check the routines of <tt>T</tt>.&nbsp; If ESC/Java
can find only a binary (<tt>.class</tt>) file and no source file declaring
<tt>U</tt>,
then it will assume simple default specifications for the routines of <tt>U</tt>
based on their signatures.&nbsp; The user can supply additional specifications
for the routines of <tt>U</tt>, and also invariants for
<tt>U</tt>, by
putting them in pragmas in a file <tt>U.spec</tt>.&nbsp; A <tt>.spec</tt>
file is like a <tt>.java</tt> file except that it is allowed to omit method
bodies.&nbsp; <a href="#5.1  Specification (.spec) files and the ESC/Java's class path">Section
5.1</a> tells more about <tt>.spec</tt>&nbsp; files.</ul>
<a href="#2  ESC/Java pragmas">Section 2</a> includes descriptions of all
ESC/Java pragmas.
<br>&nbsp;
<li>
<a NAME="ESC/Java is checker for almost all of Java 1.2."></a><b>ESC/Java
is checker for (almost all of) Java 1.2.</b></li>

<br>ESC/Java is targeted for Java 1.2, as described in <i>The Java Specification
Language</i>, by James Gosling, Bill Joy, and Guy Steele [<i><a href="http://java.sun.com/docs/books/jls/html/index.html">JLS</a></i>],
supplemented by the ``Inner Classes Specification'' [<i><a href="#[ICS]">ICS</a></i>],
except for some limitations described in <a href="#6  Java language support and limitations">section
6</a> of this manual.
<br>&nbsp;
<li>
<a NAME="ESC/Java has a command-line interface like the Java compiler's."></a><b>ESC/Java
has a command-line interface like the Java compiler's.</b></li>

<br>An invocation of ESC/Java has the form:
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>escjava</tt> [
<i>options</i>
] <i>sourcefiles</i>
<p>The <tt>escjava(1)</tt> man page in the ESC/Java release (see <a href="#Appendix B:  Installing and using ESC/Java at your site">appendix
B</a>) includes descriptions of ESC/Java's command-line options and of
environment variables that affect ESC/Java's operation.&nbsp; For now we
mention only the <tt>CLASSPATH</tt> environment variable, whose effect
on ESC/Java is similar to its effect on <tt>javac(5)</tt> and the <tt>-suggest</tt>
command-line option, which causes ESC/Java to offer suggestions of pragmas
that might eliminate certain kinds of warnings.&nbsp;&nbsp; <a href="#5.x  Specification (.spec) files, and the ESC/Java classpath.">Section
5</a> contains further description of these features (but not all command-line
options and environment variables).
<br>&nbsp;
<li>
<a NAME="ESC/Java issues warning messages for potential run-time errors."></a><b>ESC/Java
issues <i>warning</i> messages for potential run-time errors.</b></li>

<ul>
<li>
<a NAME="The current ESC/Java checks only method and constructor bodies."></a><b>The
current ESC/Java checks only method and constructor bodies.</b></li>

<br>The current ESC/Java provides no warnings for potential run-time errors
in static initializers [<i>JLS</i>, 8.5] or in initializers for <tt>static</tt>
fields or in anonymous classes.
<li>
<a NAME="ESC/Java treats exceptions thrown by the Java run-time system a"></a><b>ESC/Java
treats exceptions thrown by the Java run-time system as run-time errors.</b></li>

<br>Some of the potential ``error'' conditions detected by ESC/Java are
conditions that would be detected by the Java run-time system and give
rise to exceptions (specifically, <tt>NullPointerException</tt>,<tt> IndexOutOfBoundsException</tt>,
<tt>ClassCastException</tt>,<tt>
ArrayStoreException</tt>,<tt> ArithmeticException</tt>, and <tt>NegativeArraySizeException</tt>
[<i>JLS</i>, 11.5.1.1]).&nbsp; The current ESC/Java treats these conditions
as errors, and generates warnings for them even if the program actually
catches the resulting exceptions.&nbsp; Accordingly, our use of the word
``error'' in this manual includes such conditions.&nbsp; Future versions
of ESC/Java may provide support for checking programs that catch exceptions
thrown by the Java run-time system.&nbsp;&nbsp; The current ESC/Java version
does support checking of programs that catch explicitly-thrown exceptions
(including those just listed).
<li>
<a NAME="ESC/Java does not warn of potential errors in the evaluation of"></a><b>ESC/Java
does not warn of potential errors in the evaluation of specification expressions.</b></li>

<br>Specification expressions are never actually evaluated, and (with one
exception described in <a href="#2.6.1  set pragma">section 2.6.1</a>)
ESC/Java will not produce specific warnings about specifications expressions
whose evaluation might dereference <tt>null</tt>, access arrays out of
bounds, etc.&nbsp; Rather, the meanings of such expressions (for example,
<tt><i>O</i>.f</tt>
where <i><tt>O</tt></i> , if it were actually evaluated, might evaluate
to <tt>null</tt>) are an unspecified function of (the meanings of) their
subexpressions.&nbsp; In most cases, attempts to prove things about such
unspecified values will fail, thus giving rise to warnings of some sort
(though alas not the clearest warnings that one could hope for).
<li>
<a NAME="ESC/Java warning messages may include execution traces."></a><b>ESC/Java
warning messages may include <i>execution traces</i>.</b></li>

<br>Associated with each ESC/Java warning message is some execution path
that--so far as ESC/Java can determine--may plausibly lead to the run-time
error mentioned in the warning.&nbsp; If certain kinds of ``interesting''
events occur on this execution path, the message will contain an <i>execution
trace</i> listing those events.&nbsp; See
<a href="#4.0  Parts of ESC/Java warning messages">section
4.0</a> for details about which events are considered ``interesting''.</ul>
<a href="#4  Warnings">Section 4</a> of this manual includes descriptions
of all ESC/Java warning messages.
<br>&nbsp;
<li>
<a NAME="ESC/Java issues error messages for badly formed programs."></a><b>ESC/Java
issues <i>error</i> messages for badly formed programs</b>.</li>

<br>Before ESC/Java can analyze a program for potential run-time errors,
it must first perform operations such as parsing, name resolution, and
type-checking both of the Java code and of any pragmas.&nbsp; When ESC/Java
detects an illegal construct (such as the syntactically incorrect pragma
shown in <a href="#0.8  Scene 8:  We supply an invariant pragma relating n to a.le">section
0.8</a> above) during this preliminary processing, it issues an <i>error</i>
message.&nbsp; Error messages are distinguished from warning messages by
the occurrence of the word&nbsp; <tt>Error</tt>&nbsp; instead of <tt>Warning</tt>&nbsp;
near the beginning of the message.&nbsp; Only when its input is free of
such errors can ESC/Java go on to look for potential run-time errors and
generate warnings (just as a compiler generates object code only when the
source code is free of compile-time errors).
<ul>
<li>
<a NAME="ESC/Java error messages are like compiler error messages."></a><b>ESC/Java
error messages are like compiler error messages.</b></li>

<br>ESC/Java error messages are similar to compiler error messages, and
we hope they will be self-explanatory.&nbsp; Thus, they are not fully enumerated
or described in this manual.&nbsp; We believe that all ESC/Java error messages
arise either (1) from circumstances that would cause the Java compilers
to report compile-time errors or (2) from violations of the rules for writing
pragmas as given in <a href="#2  ESC/Java pragmas">section 2</a> and <a href="#3  Specification expressions">section
3</a>.
<li>
<a NAME="ESC/Java doesn't detect all compile-time errors that Java compi"></a><b>ESC/Java
doesn't detect all compile-time errors that Java compilers detect.</b></li>

<br>A number of conditions that give rise to Java compile-time errors are
not detected by ESC/Java.&nbsp; For example, the current ESC/Java does
not enforce Java's definite assignment rules [<i>JLS</i>, 16] or all of
Java's restrictions on access to <tt>protected</tt> variables [<i>JLS</i>,
6.6.2].&nbsp; Thus it is wise to run your code through a Java compiler
at least once before trying to run it through ESC/Java.&nbsp; (<b>Tip:</b>&nbsp;
Sometimes the nature of a syntax error in your program may not be immediately
clear from an ESC/Java error message.&nbsp; In such cases, a compiler may
detect the same error and offer a better--or at least different--description
of the problem.)</ul>

<li>
<a NAME="ESC/Java's extended static checking isn't perfect."></a><b>ESC/Java's
extended static checking isn't perfect.</b></li>

<ul>
<li>
<a NAME="ESC/Java can miss errors."></a><b>ESC/Java can miss errors.</b></li>

<br>When ESC/Java processes a program and produces no warnings, it is not
necessarily true that the program is free of all errors.&nbsp; For example,
ESC/Java never checks for some kinds of errors, such as arithmetic overflow,
or infinite looping. Also ESC/Java doesn't check programs for functional
correctness properties other than those given by the user in pragmas.&nbsp;
Finally, even when ESC/Java checks for a particular kind of errors, there
may be situations in which it erroneously concludes that the error cannot
occur, and therefore fails to issue a legitimate warnings.&nbsp; In the
jargon of proof theory, we say that ESC/Java--viewed as a system for proving
program correctness--is <i>unsound</i>.&nbsp; <a href="#C.0  Known sources of unsoundness">Section
C.0</a> describes the known sources of unsoundness in ESC/Java.
<li>
<a NAME="ESC/Java can give spurious warnings."></a><b>ESC/Java can give
spurious warnings.</b></li>

<br>Conversely, when ESC/Java issues a warning, it doesn't necessarily
indicate the presence of an error; it merely means that ESC/Java is unable
to conclude that the indicated error will never occur, given the annotations
that the user has supplied.&nbsp; In the jargon, ESC/Java--viewed as a
system for proving program correctness--is <i>incomplete</i>.&nbsp; <a href="#C.1  Some sources of incompleteness">Section
C.1</a> describes the main sources of incompleteness in ESC/Java.
<li>
<a NAME="Pragmas give the user some control over ESC/Java's unsoundness"></a><b>Pragmas
give the user some control over ESC/Java's unsoundness and incompleteness.</b></li>

<br>ESC/Java provides pragmas that let the user eliminate spurious warnings--that
is, reduce ESC/Java's incompleteness--either without loss of soundness
(as, for example, the
<tt>requires</tt> pragma we wrote in <a href="#0.2  Scene 2:  We write a requires (precondition) pragma for">section
0.2</a> eliminated the warning about a potential dereference of <tt>null</tt>
in the <tt>Bag</tt> constructor by imposing a precondition on calls) or,
if need be, at some risk of lost soundness (as in the case of the <tt>nowarn</tt>,
<tt>assume</tt>,
and <tt>axiom</tt> pragmas respectively described in sections
<a href="#2.1.0  nowarn pragma">2.1.0</a>,
<a href="#2.1.2  assume pragma">2.1.2</a>,
and <a href="#2.4.2  axiom pragma">2.4.2</a> below).
<li>
<a NAME="ESC/Java issues caution messages in some (but not all) cases wh"></a><b>ESC/Java
issues <i>caution</i> messages in some (but not all) cases where unsound
checking may occur.</b></li>
</ul>
</ul>

<h2>

<hr WIDTH="100%"></h2>

<h2>
<a NAME="2  ESC/Java pragmas"></a>2&nbsp; ESC/Java pragmas</h2>
In this section we describe all the kinds of ESC/Java pragmas, the places
where they can occur, and (informally) what they mean.&nbsp; We begin by
giving some general information about where pragmas can occur, and then
go on to describe the individual pragmas.
<p>Many pragmas can contain expressions--called specification expressions--which
are similar to Java expressions, but with a few constructs legal in Java
expressions being forbidden and a number of added constructs being permitted.&nbsp;
We mention some of the added constructs in connection with pragmas where
they are of use, but defer a detailed description of specification expressions
to <a href="#3  Specification expressions">section 3</a>.
<p>Most pragmas are ways of asking ESC/Java to produce warnings if certain
user expectations about the behavior of the annotated program may be wrong.&nbsp;
We will often say that ESC/Java ``checks'' that some condition <i>x</i>
holds at a particular control point when it would be more precise to say
that ESC/Java issues a warning message if it cannot prove that <i>x</i>
holds at that point.&nbsp; Keep in mind that in addition to the possibility
that <i>x</i> might fail, the warning may also be issued because the annotations
are inadequate to imply that <i>x</i> holds, because the theorem-prover's
deductive power is inadequate to complete the proof, or because ESC/Java's
model of Java semantics is incomplete.
<h3>
<a NAME="2.0  Rules about where pragmas may occur"></a>2.0&nbsp; Rules
about where pragmas may occur</h3>

<h4>
<a NAME="2.0.0  ESC/Java pragmas must occur within pragma-containing com"></a>2.0.0
<b>ESC/Java
pragmas must occur within <i>pragma-containing comments</i>.</b></h4>
ESC/Java looks for pragmas within certain specially formatted comments.&nbsp;
Specifically:
<ul>
<li>
When the character <tt>@</tt> is the first character after the initial
<tt>//</tt>
or <tt>/*</tt> of a Java comment, ESC/Java expects the rest of the comment's
body to consist entirely of a sequence of (zero or more) ESC/Java pragmas.</li>

<li>
Inside a documentation comment [<i>JLS</i>, 18], a sequence ESC/Java pragmas
can be bracketed by</li>

<br><tt>&lt;esc></tt> and <tt>&lt;/esc></tt>.</ul>
Many pragmas end with an optional semi-colon ( <tt>;</tt><i><sub>opt</sub></i>
).&nbsp; If such a pragma is followed by another pragma in the same pragma-containing
comment, then this semi-colon is required.
<h4>
<a NAME="2.0.1  There are four syntactic categories of pragmas."></a>2.0.1&nbsp;
There are four <i>syntactic categories</i> of pragmas.</h4>
Pragmas are divided into four <i>syntactic categories</i> according to
the places in a program where they can sensibly be used.&nbsp; All pragmas
in any single pragma-containing comment must be of the same syntactic category.
<ul>
<li>
<i>Lexical pragmas</i> may occur anywhere that ordinary Java comments may
occur.</li>

<ul><font size=-1>[It would be more accurate to say that ESC/Java allows
the occurrence of a pragma-containing comment whose body is a sequence
of zero or more lexical pragmas at any point where Java allows a comment;
we henceforth take the liberty to eschew this degree of pedantry.]</font></ul>
The current ESC/Java includes only one kind of lexical pragma:
<ul>
<li>
<tt>nowarn</tt> pragma (<a href="#2.1.0  nowarn pragma">section 2.1.0</a>).</li>
</ul>

<li>
<i>Declaration pragmas</i>--such as, for example, the <tt>invariant</tt>
pragma in <a href="#0.8  Scene 8:  We supply an invariant pragma relating n to a.le">section
0.8</a> in our introductory example--are analogous to Java declarations,
and may occur only where declarations of class members or interface members
may occur.&nbsp; The current ESC/Java includes the following kinds of declaration
pragmas:</li>

<ul>
<li>
<tt>invariant</tt> pragma (<a href="#2.4.1  invariant pragma">section 2.4.1</a>)</li>

<li>
<tt>axiom</tt> pragma (<a href="#2.4.2  axiom pragma">2.4.2</a>)</li>

<li>
<tt>ghost</tt> pragma (<a href="#2.6.0  ghost pragma">2.6.0</a>)</li>
</ul>

<li>
<i>Statement pragmas</i> are analogous to Java statements.&nbsp; They may
occur only where Java statements may occur.&nbsp; The current ESC/Java
includes the following statement pragmas:</li>

<ul>
<li>
<tt>assert</tt> pragma (<a href="#2.1.1  assert pragma">2.1.1</a>)</li>

<li>
<tt>assume</tt> pragma (<a href="#2.1.2  assume pragma">2.1.2</a>)</li>

<li>
<tt>unreachable</tt> pragma (<a href="#2.1.3  unreachable pragma">2.1.3</a>)</li>

<li>
<tt>loop_invariant</tt> pragma (<a href="#2.4.3  loop_invariant pragma">2.4.3</a>)</li>

<li>
<tt>set</tt> pragma (<a href="#2.6.1  set pragma">2.6.1</a>)</li>
</ul>

<li>
<i>Modifier pragmas</i> are analogous to Java modifiers such as <tt>private</tt>
and <tt>final</tt>.&nbsp; Generally, modifier pragmas are allowed in the
same positions as Java modifiers, but they are also allowed in a few other
places, as described in the fine points below.&nbsp; Some modifier pragmas
(for example, the
<tt>non_null</tt> pragma in <a href="#0.3  Scene 3:  We add a non_null pragma for the field a.">section
0.3</a> in the introductory example) modify variable declarations; other
modifier pragmas (for example, the<tt> requires</tt> pragmas in sections
<a href="#0.2  Scene 2:  We write a requires (precondition) pragma for">0.2</a>
and <a href="#0.6  Scene 6:  We supply a precondition for Bag.extractMin.">0.6</a>
in the introductory example) modify declarations of <i>routines</i> (methods
or constructors).&nbsp; The current ESC/Java includes the following modifier
pragmas for variable declarations:</li>

<ul>
<li>
<tt>non_null</tt> pragma (<a href="#2.4.0  non_null pragma">2.4.0</a>)</li>

<li>
<tt>spec_public</tt> pragma (<a href="#2.5.0  spec_public pragma">2.5.0</a>)</li>

<li>
<tt>readable_if</tt> pragma (<a href="#2.5.1  readable_if pragma">2.5.1</a>)</li>

<li>
<tt>uninitialized</tt> pragma (<a href="#2.5.2  uninitialized pragma">2.5.2</a>)</li>

<li>
<tt>monitored_by</tt> pragma (<a href="#2.7.0  monitored_by pragma">2.7.0</a>)</li>

<li>
<tt>monitored</tt> pragma (<a href="#2.7.1  monitored pragma">2.7.1</a>)</li>
</ul>
The current ESC/Java includes the following modifier pragmas for routine
declarations:
<ul>
<li>
<tt>requires</tt> pragma (<a href="#2.3.0  requires pragma">2.3.0</a>)</li>

<li>
<tt>modifies</tt> pragma (<a href="#2.3.1  modifies pragma">2.3.1</a>)</li>

<li>
<tt>ensures</tt> pragma (<a href="#2.3.2  ensures pragma">2.3.2</a>)</li>

<li>
<tt>exsures</tt> pragma (<a href="#2.3.4  exsures pragma">2.3.4</a>)</li>

<li>
<tt>also_ensures</tt> pragma (<a href="#2.3.5  also_ensures pragma">2.3.5</a>)</li>

<li>
<tt>also_exsures</tt> pragma (<a href="#2.3.6  also_exsures pragma">2.3.6</a>)</li>

<li>
<tt>also_modifies</tt> pragma (<a href="#2.3.8  also_modifies pragma">2.3.8</a>)</li>
</ul>
In the current ESC/Java there are no pragmas that can modify both variable
and routine declarations.</ul>
<b>Fine points</b>
<p>A modifier pragma that modifies a routine (method or constructor) declaration
may appear either in any of the following places:
<ul>
<li>
near the beginning of the declaration, in the usual place where Java modifiers
such as&nbsp; <tt>private</tt>&nbsp; or
<tt>final</tt> may occur,</li>

<li>
just before the opening left brace of the routine's body, or</li>

<li>
just before the final semicolon of a routine declaration if there is no
body (as in an interface, in an <tt>abstract</tt> class, or sometimes in
a <tt>.spec</tt> file (see <a href="#5.1.2  Specification (.spec) files">section
5.1.2</a>)</li>
</ul>
The semantics of a routine modifier pragma is independent of whether the
pragma appears lexically before or after the signature of the routine.&nbsp;
Routine modifier pragmas are described further in <a href="#2.3  Pragmas for specifying routines">section
2.3</a>.
<p>A modifier pragma that modifies a variable declaration may appear either
in the usual place for modifiers near the beginning of the declaration
or just before the final semicolon.&nbsp; The pragma applies to all variables
declared in the declaration, and its semantics is independent of its position
within the declaration.&nbsp; For convenient reference, here is a table
listing ESC/Java pragmas that can modify variable declarations, the sections
of this manual where they are described, and the kinds of declarations
they are allowed to modify:
<ul><a NAME="variable modifier table"></a><tt><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
instance&nbsp; static&nbsp; local&nbsp;&nbsp;&nbsp;&nbsp; formal</font></tt>
<br><tt><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
variable&nbsp; field&nbsp;&nbsp; variable&nbsp; parameter</font></tt>
<p><font size=-1><tt>non_null </tt>(<a href="#2.4.0  non_null pragma">2.4.0</a>)<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
yes&nbsp;&nbsp;&nbsp;&nbsp; yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
yes</tt></font>
<br><font size=-1><tt>spec_public </tt>(<a href="#2.5.0  spec_public pragma">2.5.0</a>)<tt>&nbsp;&nbsp;&nbsp;
yes&nbsp;&nbsp;&nbsp;&nbsp; yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
no</tt></font>
<br><font size=-1><tt>readable_if </tt>(<a href="#2.5.1  readable_if pragma">2.5.1</a>)<tt>&nbsp;&nbsp;&nbsp;
yes&nbsp;&nbsp;&nbsp;&nbsp; yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
no</tt></font>
<br><font size=-1><tt>uninitialized </tt>(<a href="#2.5.2  uninitialized pragma">2.5.2</a>)<tt>&nbsp;
no&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no</tt></font>
<br><font size=-1><tt>monitored_by </tt>(<a href="#2.7.0  monitored_by pragma">2.7.0</a>)<tt>&nbsp;&nbsp;
yes&nbsp;&nbsp;&nbsp;&nbsp; yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
no</tt></font>
<br><font size=-1><tt>monitored </tt>(<a href="#2.7.1  monitored pragma">2.7.1</a>)<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
yes&nbsp;&nbsp;&nbsp;&nbsp; no&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
no&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no</tt></font>
<br>&nbsp;</ul>
Note that ESC/Java sometimes allows modifier pragmas in declarations of
local variables (including those declared in the <i>ForInit</i> of a
<tt>for</tt>
statement [<i>JLS</i>, 14.12]) and formal parameters.
<p>Particular pragmas may have further restrictions on where they may occur
beyond those given above.&nbsp; These restrictions are described in the
sections describing the respective pragmas.
<h4>
<a NAME="2.0.2  ESC/Java sometimes allows pragmas to contain nested prag"></a>2.0.2&nbsp;
ESC/Java sometimes allows pragmas to contain nested pragmas or comments.</h4>
Situations sometimes arise where it is convenient to nest a comment inside
a pragma, or where it is convenient--or even necessary--to nest a pragma
inside another pragma.&nbsp; In particular, this is the only way to annotate
a ghost field (see section
<a href="#2.6.0  ghost pragma">2.6.0</a>) with
a modifier pragma.&nbsp; We describe here the rules governing such nesting.&nbsp;
[<i>Readers may wish to skip the remainder of this section on first reading
of the manual, or until occasion for using such nesting presents itself.</i>]
<p>In the current ESC/Java, a pragma-containing comment (call it <i><tt>inner</tt></i>)
may be nested inside pragma-containing comment (<i><tt>outer</tt></i>)
only in the following cases:
<blockquote>(1)&nbsp; each pragma in <i><tt>inner</tt></i> is a lexical
(<tt>nowarn</tt>) pragma (see section <a href="#2.1.0  nowarn pragma">2.1,0</a>),
or
<p>(2)&nbsp; each pragma in <i><tt>inner</tt></i> is a modifier pragma
for a ghost variable declared in <i><tt>outer</tt></i> (see section
<a href="#2.6.0  ghost pragma">2.6.0</a>
for further details).</blockquote>
Furthermore, <i><tt>outer</tt></i> must not itself be nested inside another
pragma-containing comment. (However, <i><tt>outer</tt></i> may be of the
form <tt>&lt;esc></tt>...<tt>&lt;/esc></tt>, which must of necessity occur
inside a Java documentation comment).
<p>Any pragma-containing comment
<i><tt>outer</tt></i>--even a nested one--may
have an ordinary (i.e., non-pragma-containing) comment
<i><tt>inner</tt></i>
nested inside it.
<p>Also, there are some restrictions concerning the syntactic forms of
a nested (ordinary or pragma-containing) comment <i><tt>inner</tt></i>
and the enclosing pragma-containing comment <i><tt>outer</tt></i>, as given
in the following table and the associated notes.&nbsp; These restrictions
ensure that the portions of the input file that ESC/Java regards as comments
or pragmas will be precisely those regarded as comments by Java compilers.&nbsp;
Each row of the table corresponds to a syntactic form of <i><tt>outer</tt></i>
and each column corresponds to a syntactic form of <i><tt>inner</tt></i>.&nbsp;
Entries tell whether each specific form of nesting is allowed and reference
notes giving any additional restrictions on allowed forms of nesting and
explanations of why forbidden forms of nesting are forbidden.
<blockquote><table>
<tr><td></td>
    <td align="right"><font size=-1><tt><i>inner</i>&nbsp;</tt></font></td>
    <td><font size=-1><tt>&nbsp;//...&nbsp;</tt></font></td>
    <td><font size=-1><tt>&nbsp;//@...&nbsp;</tt></font></td>
    <td><font size=-1><tt>&nbsp;/*...*/&nbsp;</tt></font></td>
    <td><font size=-1><tt>&nbsp;/*@...*/&nbsp;</tt></font></td>
    <td><font size=-1><tt>&nbsp;/**...*/&nbsp;</tt></font></td>
</tr>
<tr><td align ="center"><font size=-1><tt><i>outer</i></tt></font></td><tr>
<tr><td><font size=-2>&nbsp;</td></tr>
<tr><td align="right"><font size=-1><tt>//@...<i>inner</i>...</tt></font></td>
    <td></td>
    <td align="center"><font size=-1><tt>ok(1)</tt></font></td>
    <td align="center"><font size=-1><tt>ok(1)</tt></font></td>
    <td align="center"><font size=-1><tt>ok(2)</tt></font></td>
    <td align="center"><font size=-1><tt>ok(2)</tt></font></td>
    <td align="center"><font size=-1><tt>no(3)</tt></font></td>
</tr>
<tr><td align="right"><font size=-1><tt>/*@...<i>inner</i>...*/</tt></font></td>
    <td></td>
    <td align="center"><font size=-1><tt>ok(4)</tt></font></td>
    <td align="center"><font size=-1><tt>ok(4)</tt></font></td>
    <td align="center"><font size=-1><tt>no(5)</tt></font></td>
    <td align="center"><font size=-1><tt>no(5)</tt></font></td>
    <td align="center"><font size=-1><tt>no(5)</tt></font></td>
</tr>
<tr><td align="right"><font size=-1><tt>&lt;esc>...<i>inner</i>...&lt;/esc></tt></font></td>
    <td></td>
    <td align="center"><font size=-1><tt>ok(6)</tt></font></td>
    <td align="center"><font size=-1><tt>ok(6)</tt></font></td>
    <td align="center"><font size=-1><tt>no(5)</tt></font></td>
    <td align="center"><font size=-1><tt>no(5)</tt></font></td>
    <td align="center"><font size=-1><tt>no(5)</tt></font></td>
</tr>
</table></blockquote>
Notes:
<blockquote>(1)&nbsp; ESC/Java considers <i><tt>inner</tt></i> to extend
to the end of the line on which it begins.
<br>(2)&nbsp; <i><tt>inner</tt></i> must be entirely on one line (because
Java defines <i><tt>outer</tt></i> to end at the end of the line).
<br>(3)&nbsp; The current ESC/Java might accept this form of nesting, but
it is strongly deprecated.&nbsp; There is no good reason to use it, and
<tt>javadoc(5)</tt>
will not recognize <i><tt>inner</tt></i> as a documentation comment.
<br>(4)&nbsp; ESC/Java considers <tt>inner</tt> to extend either to the
end of the line or up to the closing <tt>*/</tt> of <i><tt>outer</tt></i>,
whichever is earlier.
<br>(5)&nbsp; These forms of nesting are forbidden because Java does not
allow comments of the form <tt>/*</tt>...<tt>*/</tt> to be nested inside
each other.&nbsp; Thus Java compilers would interpret the closing <tt>*/</tt>
of <i><tt>inner</tt></i> as ending <i><tt>outer</tt></i>.
<br>(6)&nbsp;&nbsp; ESC/Java considers <tt>inner</tt> to extend either
to the end of the line or up to the closing <tt>&lt;/esc></tt> of <i><tt>outer</tt></i>,
whichever is earlier.</blockquote>
<b>Examples</b>
<p>Here are some examples of legal nesting of comments and pragmas inside
pragmas:
<blockquote>
<ul>
<li>
<tt>//@ ghost public /*@ non_null // comment */ Object o;</tt></li>

<br>&nbsp;
<li>
<tt>/*@ requires a > 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// comment 1</tt></li>

<br><tt>&nbsp;&nbsp;&nbsp; requires b > 0;&nbsp; //@ nowarn Pre // comment
2</tt>
<br><tt>&nbsp;&nbsp;&nbsp; requires c > 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// comment 3 */</tt>
<br><tt>&nbsp; void m(int a, int b, int c) { </tt>...</ul>
</blockquote>
Here are some examples of illegal nesting:
<blockquote>
<ul>
<li>
<tt>/*@ ghost public /*@ non_null */ Object o; */</tt></li>

<li>
<tt>//@ requires a > 0;&nbsp; /* multi-line "nested"</tt></li>

<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
comment */</tt></ul>
</blockquote>
<b>Tip:&nbsp; </b>ESC/Java's warning messages for these two examples of
illegal nesting fail to give the line number on which the error occurs
(but do indicate that the problem is an "unterminated comment").&nbsp;
You can localize the error by running a Java compiler on your program (which
is generally a good thing to do before running ESC/Java, anyway).
<h3>
<a NAME="2.1  The most basic pragmas"></a>2.1&nbsp; The most basic pragmas</h3>
In this section we describe the simplest ESC/Java pragmas: <tt>nowarn</tt>,
<tt>assume</tt>,
<tt>assert</tt>,
and <tt>unreachable</tt>.&nbsp; The <tt>nowarn</tt> pragma is essentially
a blunt instrument for getting ESC/Java to shut up about uninteresting
warnings, thus helping to prevent ESC/Java's known imperfections and limitations
from becoming major sources of user annoyance.&nbsp; The
<tt>assert</tt>
and
<tt>assume</tt> pragmas are the fundamental pragmas of which most others
are simply more elaborate forms (see <a href="#2.2.1  Most ESC/Java pragmas are just fancy forms of assert and">section
2.2.1</a>).&nbsp; They may also be useful in their own right (see particularly
<a href="#2.2.3  A helpful tip:  Experiments with assert and assume pragm">section
2.2.3</a>).
<h4>
<a NAME="2.1.0  nowarn pragma"></a>2.1.0&nbsp; <tt>nowarn</tt> pragma</h4>
A <tt>nowarn</tt> pragma is a lexical pragma.&nbsp; It has the form:
<blockquote><tt>nowarn <i>L</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>L</tt></i> is a (possibly empty) comma-separated list of warning
types from the following list:
<blockquote><tt>ArrayStore&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Invariant&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Post</tt>
<br><tt>Assert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoopInv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Pre</tt>
<br><tt>Cast&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
NegSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Race</tt>
<br><tt>Deadlock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NonNull&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Reachable</tt>
<br><tt>Exception&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NonNullInit&nbsp;&nbsp;&nbsp;&nbsp;
Unreadable</tt>
<br><tt>IndexNegative&nbsp;&nbsp; Null&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Uninit</tt>
<br><tt>IndexTooBig&nbsp;&nbsp;&nbsp;&nbsp; OwnerNull&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ZeroDiv</tt></blockquote>
The pragma suppresses any warning messages of the types in <i><tt>L</tt></i>
that are associated with the line on which the pragma appears.&nbsp; If
<i><tt>L</tt></i>
is empty, all warning types are suppressed.&nbsp;&nbsp; See <a href="#4  Warnings">section
4</a> for descriptions of the different types of warnings.
<p><b>Fine points</b>
<p>Some ESC/Java warning messages refer to two source code locations, namely
(1) a location indicating the control point where an error could potentially
occur at run-time, and (2) the location of a pragma (or, occasionally,
a Java declaration) associated with the warning.&nbsp; In such cases the
warning can be suppressed by a <tt>nowarn</tt> pragma on either of the
indicated source lines.
<p>The <tt>nowarn</tt> pragma is potentially unsound, and should be used
only in cases where the programmer is willing to take responsibility that
the suppressed warnings are really false alarms.&nbsp; The primary intended
use of <tt>nowarn</tt> pragmas is where the suppressed warnings concern
situations that are impossible in practice, but for reasons beyond ESC/Java's
ability to discover.&nbsp; Another use would be to suppress warnings for
circumstances that are actually harmless (and where the programmer is willing
to take responsibility that they are harmless).&nbsp; For example, a <tt>nowarn</tt>
pragma might be used to suppress a warning for a null dereference if the
resulting exception would be caught by a handler (but in such a case the
current ESC/Java will not check that there actually is a handler, nor will
it check for any errors that might occur during or after execution of the
handler).
<p>The <tt>nowarn</tt> pragma suppresses warnings on a line-by-line basis.&nbsp;
ESC/Java also provide command-line options that enable and disable checking
at a much coarser grain (see the descriptions of the <tt>-nowarn</tt>,
<tt>-warn</tt>,
<tt>-start</tt>,
<tt>-routine</tt>,
and <tt>-routineIndirect</tt> options on the <tt>escjava(1)</tt> man page).
<p>Unlike warning messages, ESC/Java error messages cannot be suppressed
by <tt>nowarn</tt> pragmas.&nbsp; Error messages report conditions that
prevent ESC/Java from making enough sense of the program to do further
checking.
<p><b>Bug:</b>&nbsp; The current ESC/Java does not allow another pragma
to follow a <tt>nowarn</tt> pragma in the same pragma-containing comment.&nbsp;
Since the only lexical pragma in the current ESC/Java is <tt>nowarn</tt>,
and since you can say with one <tt>nowarn</tt> pragma anything that you
can say with two, this should not cause problems in practice.
<h4>
<a NAME="2.1.1  assert pragma"></a>2.1.1&nbsp; <tt>assert</tt> pragma</h4>
An <tt>assert</tt> pragma is a statement pragma.&nbsp; It has the form
<blockquote><tt>assert <i>E</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>E</tt></i> is boolean specification expression.&nbsp; The
pragma causes ESC/Java to issue a warning if it cannot establish that <i><tt>E</tt></i>
is true whenever control reaches the pragma.
<br>&nbsp;
<h4>
<a NAME="2.1.2  assume pragma"></a>2.1.2&nbsp; <tt>assume</tt> pragma</h4>
An <tt>assume</tt> pragma is a statement pragma.&nbsp; It has the form
<blockquote><tt>assume <i>E</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>E</tt></i> is boolean specification expression.&nbsp; The
pragma causes ESC/Java to assume that <i><tt>E</tt></i> is true whenever
control reaches the pragma.&nbsp; In other words, for any execution path
in which <i><tt>E</tt></i> is false when control reaches the pragma, ESC/Java
ignores the path from that point on.
<p><b>Example</b>
<p>The usual purpose of an <tt>assume</tt> pragma is to supply ESC/Java
with some piece of information that is incapable of deducing on its own,
thereby preventing ESC/Java from generating spurious warnings.&nbsp; In
the code fragment
<blockquote><tt><font size=-2>22:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;
// start complicated computation guaranteed to leave i != 0</tt>
<br><tt><font size=-2>...&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; </tt>...
<br><tt><font size=-2>146:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp; //
end of complicated computation</tt>
<br><tt><font size=-2>147:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp; //@
assume i != 0;</tt>
<br><tt><font size=-2>148:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp; if
(b) {</tt>
<br><tt><font size=-2>149:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
g = h/i;</tt>
<br><tt><font size=-2>150:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp; }
else {</tt>
<br><tt><font size=-2>151:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
h = g/i + g/j;</tt>
<br><tt><font size=-2>152:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp; }</tt></blockquote>
the <tt>assume</tt> pragma at line 147 prevents ESC/Java from warning that
the division by <tt>i</tt> in lines 149 and 151 may give rise to an <tt>ArithmeticException</tt>,
but ESC/Java will still generate a warning about the division by <tt>j</tt>
in line 151 unless it can deduce that <tt>j</tt> will never be zero when
control reaches that point.
<p><b>Fine points</b>
<p>Like the <tt>nowarn</tt> pragma, the <tt>assume</tt> pragma is potentially
unsound, and should be used only if the programmer is willing to take responsibility
that <i><tt>E</tt></i> holds whenever control reaches the pragma (or at
least is willing to give up further checking for any execution paths on
which <i><tt>E</tt></i> is false).&nbsp; When faced with the choice of
using either an<tt> assume</tt> pragma or a <tt>nowarn</tt> pragma to suppress
a spurious warning, it is preferable to use an <tt>assume</tt> pragma (if
it is practical to do so), since the <tt>assume</tt> pragma more explicitly
documents your assumptions about the behavior of the program.
<p>The sentence ``In other words, for any execution path ... from that
point on.'' may have seemed unclear to some readers.&nbsp; For some more
examples of its meaning, consider the following code fragment:
<blockquote><tt><font size=-2>31:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;
if (u != null | v != null) e = 10;</tt>
<br><tt><font size=-2>32:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; if (v ==
null) {</tt>
<br><tt><font size=-2>33:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
w = a.f;</tt>
<br><tt><font size=-2>34:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//@ assert b != null;</tt>
<br><tt><font size=-2>35:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//@ assume a != null &amp; b != null &amp; c != null &amp; d != null &amp;
e > 0;</tt>
<br><tt><font size=-2>36:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
x = c.f;</tt>
<br><tt><font size=-2>37:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//@ assert d != null;</tt>
<br><tt><font size=-2>38:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt><font size=-2>39:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
c = new </tt>...<tt>;</tt>
<br><tt><font size=-2>40:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
d = v;</tt>
<br><tt><font size=-2>41:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt><font size=-2>42:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; y = a.g;</tt>
<br><tt><font size=-2>43:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; //@ assert
b != null;</tt>
<br><tt><font size=-2>44:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; z = c.g;</tt>
<br><tt><font size=-2>45:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; //@ assert
d != null;</tt>
<br><tt><font size=-2>46:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; //@ assert
e > 0;</tt></blockquote>
When ESC/Java checks this code:
<blockquote>
<li>
ESC/Java will not warn of a possible dereference of <tt>null</tt> at line
36 or of a possible assertion failure at line 37, because the only way
control can reach those lines is by first reaching the <tt>assume</tt>
pragma at line 35.</li>

<li>
The <tt>assume</tt> pragma at line 35 will not prevent ESC/Java from issuing
warnings about line 33&nbsp; and/or 34, because control can reach those
lines before reaching line 35.</li>

<li>
ESC/Java might issue warnings about line 42 and/or 43, because control
might reach those lines by some path that does not first reach line 35.&nbsp;
This can happen if control can reach line 32 with <tt>a</tt> or <tt>b</tt>
being <tt>null</tt> and <tt>x</tt> being non-null.</li>

<li>
ESC/Java will not warn of a possible dereference of <tt>null</tt> at line
44 or of a possible assertion failure at line 45 or 46.&nbsp; Every execution
path that reaches line 44 first either reaches line 35 (in which case ESC/Java
considers further execution of that path only for cases where the expression
in the <tt>assume</tt> pragma would evaluate to <tt>true</tt>) or reaches
lines 39 and 40 (in which case the <tt>c</tt> and <tt>d</tt> are assigned
non-null values, and <tt>e</tt> must already have been assigned a nonnegative
value at line 31).</li>
</blockquote>
For a concise formal description of the semantics of <tt>assume</tt>, see
[<a href="#[LSS99]">LSS99</a>].
<h4>
<a NAME="2.1.3  unreachable pragma"></a>2.1.3&nbsp; <tt>unreachable</tt>
pragma</h4>
An <tt>unreachable</tt> pragma is a statement pragma.&nbsp; It has the
form
<blockquote><tt>unreachable ;</tt><i><sub>opt</sub></i></blockquote>
The pragma is semantically equivalent to
<blockquote><tt>assert false;</tt></blockquote>
except for giving rise to a different warning message.
<h3>
<a NAME="2.2  Some remarks concerning assert and assume"></a>2.2&nbsp;
Some remarks concerning <tt>assert</tt> and <tt>assume</tt></h3>
[<i>Readers anxious to ``cut to the chase'' may skip this section on first
reading.&nbsp; Others, however, may find that this material aids their
intuition about how ESC/Java works.</i>]
<p>The <tt>assert</tt> and <tt>assume</tt> pragmas introduced in <a href="#2.1  The most basic pragmas">section
2.1</a> are in some sense the most basic ESC/Java pragmas.&nbsp; We make
some remarks about them here before going on to describe the rest.
<h4>
<a NAME="2.2.0  The assume pragma should be used with judgment."></a>2.2.0&nbsp;
The <tt>assume</tt> pragma should be used with judgment.</h4>
An <tt>assume</tt> pragma resembles an <tt>assert</tt> pragma in that each
states a condition that the programmer believes to hold whenever control
reaches a certain point in the program.&nbsp; The difference is that ESC/Java
checks--that is, issues a warning if it cannot establish--the condition
(called an <i>asserted condition</i> or <i>assertion</i>) in an <tt>assert</tt>
pragma, but ESC/Java takes the <i>assumed condition</i> (or <i>assumption</i>)
in an <tt>assume</tt> pragma for granted.&nbsp; That is, the programmer
takes responsibility that assumed conditions will hold.
<p>Put another way, the <tt>assume</tt> pragma allows the programmer to
trade spurious warnings (incompleteness) for possible missed warnings (unsoundness).&nbsp;
Thus, you should use <tt>assume</tt> pragmas with care, lest by supplying
an incorrect assumption you suppress warnings of genuine errors.&nbsp;
For example, ESC/Java will not warn of any error that might occur downstream
in the execution path from the line:
<blockquote><tt>&nbsp;&nbsp;&nbsp; x = null; //@ assume x != null;</tt></blockquote>
since there can be no execution path where the assumption holds after the
assignment is performed.
<p>On the other hand, there will be cases where <tt>assume</tt> pragmas
(or <tt>nowarn</tt> pragmas, which call for similar caution in their use)
will be the only practical means to eliminate spurious warnings.&nbsp;
Also, while it is sometimes possible to eliminate spurious warnings by
means that don't carry the same risks of missed warnings, some judgment
must be exercised as to whether the improved assurance of correctness will
be worth the increased effort in any particular case.
<h4>
<a NAME="2.2.1  Most ESC/Java pragmas are just fancy forms of assert and"></a>2.2.1&nbsp;
Most ESC/Java pragmas are just fancy forms of <tt>assert</tt> and <tt>assume</tt>.</h4>
The ESC/Java annotation language includes over twenty different kinds of
pragmas, but to a first approximation they are mainly more or less elaborate
ways of adding assertions (i.e., claims about the program state that are
checked by the ESC/Java) and/or assumptions (i.e., claims that are taken
for granted by ESC/Java) at different points in the program.&nbsp; Indeed
one can also think of the checking that ESC/Java does in the absence of
any user annotations as simply checking implicit assertions before each
pointer dereference, array access, etc., so that, for example, the program
fragment
<blockquote><tt>x = a[i];</tt></blockquote>
is treated as if it were
<blockquote><tt>//@ assert a != null; assert 0 &lt;= i; assert i &lt; a.length;</tt>
<br><tt>x = a[i];</tt></blockquote>
There are several valuable differences between the explicit introduction
of assertions through the use of <tt>assert</tt> pragmas and their implicit
introduction through other ESC/Java pragmas and through built-in checking
rules:
<blockquote>
<li>
Warnings arising from <tt>assert</tt> pragmas all produce the same kind
of warning message:</li>

<blockquote>...<tt>: Warning: Possible assertion failure (Assert)</tt></blockquote>
Implicitly introduced assertions, on the other hand, give rise to a wide
variety of more specific messages.
<li>
An <tt>assert</tt> pragma can occur only where a Java statement can occur,
but implicitly introduced assertions are not limited to statement boundaries.&nbsp;
For example, given the statement</li>

<blockquote><tt>p = m(q) + q[++i]</tt></blockquote>
ESC/Java makes sure that the implicit assertion that array <tt>q</tt> is
non-null is introduced at a control point after the call to method
<tt>m</tt>,
and that the implicit assertion that index <tt>i</tt> is in bounds is introduced
at a control point after <tt>i</tt> is incremented.&nbsp; For the user
to introduce explicit assertions at these points, it would be necessary
to modify the Java source code, breaking the statement into several parts
and introducing a temporary variable for the result of the call to <tt>m</tt>.
<li>
An <tt>assert</tt> pragma introduces a single assertion at the control
point where it occurs.&nbsp; In contrast, a single other pragma (or built-in
checking rule) can introduce many assertions throughout the program--for
example, at every call of a given method, or at every access to a given
variable.</li>

<li>
The systematic introduction of assertions at certain points in a program
sometimes makes it possible for ESC/Java safely to introduce assumption
at other points.</li>
</blockquote>
In short, the various pragmas (and built-in checking rules) provided by
ESC/Java enable the introduction of collections of assertions and assumptions
in a manner that would be quite tedious, awkward, and error-prone to accomplish
with explicit <tt>assert</tt> and <tt>assume</tt> pragmas alone.
<h4>
<a NAME="2.2.2  A nowarn pragma suppresses warnings by turning assertion"></a>2.2.2&nbsp;
A <tt>nowarn</tt> pragma suppresses warnings by turning assertions into
assumptions.</h4>
Recall from the previous section (<a href="#2.2.1  Most ESC/Java pragmas are just fancy forms of assert and">2.2.1</a>)
that ESC/Java's built-in checking for null dereferences works, in effect,
by implicitly putting an assertion before each pointer dereference in the
program, so that the line
<p><tt>&nbsp;&nbsp;&nbsp; <font size=-2>209:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;
z = x.f;</tt>
<p>gets treated as if it were
<blockquote><tt><font size=-2>209:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;
/*@ assert x != null; */ z = x.f;</tt></blockquote>
except that the precise text of the warning message, if any, is different.&nbsp;
The way that a <tt>nowarn</tt> pragma suppresses warnings is by turning
the (implicit or explicit) assertions that would generate the warnings
into assumptions.&nbsp; Thus, for example, the code fragment
<blockquote><tt><font size=-2>209:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;
z = x.f; //@ nowarn Null;</tt>
<br><tt><font size=-2>210:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; w = x.g;</tt></blockquote>
is treated by ESC/Java like
<blockquote><tt><font size=-2>209:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;
/*@ assume x != null; */ z = x.f;</tt>
<br><tt><font size=-2>210:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; /*@ assert
x != null; */ w = x.g;</tt></blockquote>
By changing the implicit assertion that <tt>x</tt> is non-null on line
209 into an assumption, the <tt>nowarn</tt> pragma not only prevents ESC/Java
from warning of a possible dereference of <tt>null</tt> on line 209, but
also satisfies the implicit assertion on line 210, thus preventing ESC/Java
from warning that the evaluation of the expression <tt>x.g</tt> might dereference
<tt>null</tt>.
<p>It should be clear from the above that the comments in <a href="#2.2.0  The assume pragma should be used with judgment.">section
2.2.0</a> about the need for judgment regarding the use of <tt>assume</tt>
pragmas are (at least) equally applicable to <tt>nowarn</tt> pragmas.
<h4>
<a NAME="2.2.3  A helpful tip:  Experiments with assert and assume pragm"></a>2.2.3&nbsp;
A helpful tip:&nbsp; Experiments with <tt>assert</tt> and <tt>assume</tt>
pragmas can help you understand ESC/Java's behavior and debug your annotated
code.</h4>
As illustrated in the example of <a href="#0  An illustrative example of using ESC/Java">section
0</a>, using ESC/Java will often be an iterative process:&nbsp; You run
ESC/Java on your program; it reports some warnings; you address the warnings
by changing either the Java code itself or the annotations; you run ESC/Java
again; and so on until ESC/Java reports no warnings.&nbsp; At some point
in this process, you may find that you can't figure out why ESC/Java is
issuing some warning, or why the change you made to address some warning
isn't making the warning go away.&nbsp; In such cases experiments with
<tt>assert</tt>&nbsp;
and&nbsp; <tt>assume</tt>&nbsp; pragmas can be useful in the same way that
displaying intermediate results is useful in ordinary debugging.
<p>Suppose, for example, that the problem seems to be that ESC/Java is
missing some critical fact that ``should be obvious.''&nbsp; You might
try adding an <tt>assert</tt> pragma for the (supposedly obvious) fact
and see whether ESC/Java really warns that the <tt>assert</tt> could fail.&nbsp;
Or you might try adding an <tt>assume</tt> pragma to see whether supplying
the (supposedly critical) missing fact really eliminates the warning.
<p>Such experiments can also clarify your own understanding of your program.&nbsp;
Consider, for example, the situation described in <a href="#0.7  Scene 7:  We run ESC/Java again and it still issues a warn">section
0.7</a>, where ESC/Java continued to complain of a possible array bounds
error even after we fixed the bug in the surrounding <tt>for</tt> loop:
<blockquote><b><font face="Arial,Helvetica">ESC/Java input from file Bag.java:</font></b>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp; </tt>...
<br><tt><font size=-2>16:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; for (int
i = 0; i &lt; n; i++) {</tt>
<br><tt><font size=-2>17:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (a[i] &lt; m) {</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; </tt>...
<br><b><font face="Arial,Helvetica">ESC/Java output:</font></b>
<br><tt>Bag.java:17: Warning: Possible array index too large (IndexTooBig)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a[i] &lt; m) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</tt>
<br><tt>1 warning</tt></blockquote>
If we found this behavior puzzling we might consider the experiment of
adding an&nbsp; <tt>assert</tt>&nbsp; pragma between lines 16 and 17.&nbsp;
The outcome of the experiment would depend on which of the two ``obvious''
assertions we chose:
<blockquote><tt>//@ assert i &lt; n;</tt></blockquote>
or
<blockquote><tt>//@ assert i &lt; a.length;</tt></blockquote>
In either case, observing the outcome might take us a step closer to understanding
the situation.
<p><b>Note:</b>&nbsp; Some earlier versions of ESC/Java had a bug that
sometimes resulted in highly counterintuitive failure to warn of the first
potential error on an execution path.&nbsp; For example, if a program contained
the lines
<blockquote><tt><font size=-2>23:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;
//@ assert x &lt; 10 &amp; y &lt; 10;</tt>
<br><tt><font size=-2>...&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; </tt>...<tt>&nbsp;&nbsp;
// statements not modifying x</tt>
<br><tt><font size=-2>33:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; //@ assert
x &lt; 10;</tt></blockquote>
then ESC/Java might have produced an <tt>Assert</tt> warning for line 33,
but not for line 23 (even though the assertion at line 33 could be false
after execution of lines 24-32 only if the assertion at lines 23 had been
false beforehand, and even though ESC/Java would have warned about line
23 if the assertion in line 33 were not present).&nbsp; This behavior could
be quite confusing for a user attempting to use <tt>assert</tt> pragmas
as a debugging aid, as suggested in this section.&nbsp; We have since made
changes to ESC/Java to prevent such behavior, or at least greatly reduce
its likelihood.&nbsp; If you observe a case where addition of an assertion
inhibits ESC/Java from warning about a potential error earlier in the execution
path, we would like to know about it. See the instructions on reporting
bugs in <a href="#Appendix B:  Installing and using ESC/Java at your site">appendix
B</a>.
<h3>
<a NAME="2.3  Pragmas for specifying routines"></a>2.3&nbsp; Pragmas for
specifying routines</h3>
In this section, we describe those pragmas, called <i>routine modifier
pragmas</i>,&nbsp; that explicitly supply specifications for individual
routines.
<p><b>Fine points</b>
<p>The reader should be aware that these pragmas are not the only ones
that give rise to routine specifications.&nbsp; In this regard, we direct
the reader's attention particularly to the descriptions of the <tt>non_null</tt>
and <tt>invariant</tt> pragmas in sections <a href="#2.4.0  non_null pragma">2.4.0</a>
and <a href="#2.4.1  invariant pragma">2.4.1</a>, as well as to the description
of the <tt>axiom</tt> pragma in section <a href="#2.4.2  axiom pragma">2.4.2</a>.
<p>All routine modifier pragmas have a number of properties in common:
<ul>ESC/Java allows modifiers for a routine declaration to appear not only
in the usual place for modifiers near the beginning of the declaration,
but also just before the opening left brace of the routine's body, or before
the final semicolon if there is no body (as in an interface, <tt>abstract</tt>
class, or sometimes in a <tt>.spec</tt> file (see <a href="#5.1.2  Specification (.spec) files">section
5.1.2</a>)).&nbsp; For example, the <tt>requires</tt> pragma that we introduced
for the <tt>Bag</tt> constructor in <a href="#0.2  Scene 2:  We write a requires (precondition) pragma for">section
0.2</a>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; //@ requires
input != null;</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; Bag(int[]
input) {</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; </tt>...
<br>might equally well have been written after the signature of the constructor
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; Bag(int[]
input)</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;
/*@ requires input != null; */ {</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; </tt>...
<br>with identical semantics (except, of course, that warning messages
referring to the pragma would indicate a different source file location).
<li>
Regardless of where a routine modifier pragma appears, the parameters of
the routine are in scope in any specification expression in the pragma.</li>

<li>
In an <tt>ensures</tt> (<a href="#2.3.2  ensures pragma">section 2.3.2</a>)
pragma modifying a constructor and in any pragma modifying an instance
method, specification expressions may mention <tt>this</tt>, denoting the
constructed object or the object whose method is being invoked.&nbsp; As
usual in contexts where <tt>this</tt> may occur, it may occur implicitly,
a field access <tt>this.<i>f</i></tt> being written simply as <i><tt>f</tt></i>
(unless the name <i><tt>f</tt></i> is hidden, for example by a parameter
name).</li>

<li>
The pragmas in this section specify preconditions, modification targets,
and normal and exceptional postconditions of routines.&nbsp; When a method
of a class or interface <i><tt>S</tt></i> inherits or overrides [<i>JLS</i>,
8.4.6] a method <i><tt>m</tt></i> from a class or interface <i><tt>T</tt></i>,
the method <i><tt>S.m</tt></i> inherits all the preconditions, modification
targets, and postconditions of <i><tt>T.m</tt></i>, with the formal parameter
names of <i><tt>S.m</tt></i> being substituted for those of <i><tt>T.m</tt></i>.&nbsp;
(ESC/Java desugars implicit references to <tt>this</tt>, as described in
the previous bullet, before doing the formal parameter substitution, so
nothing funny happens if only one of the two formal parameter lists includes
a name conflicting with a field of <tt>this</tt>.)&nbsp; This treatment
of inheritance sometimes leads to unsound checking in the presence of multiple
inheritance (see section <a href="#C.0.5  Multiple inheritance">C.0.5</a>).</li>

<li>
When checking code that contains a call to a routine, ESC/Java interprets
the routine's preconditions, modification targets, and postconditions with
the actual parameters values substituted for the formal parameter names,
and in the case of an instance method call <tt><i>E</i>.<i>m</i>(</tt>...<tt>)</tt><i>,</i>
with the value of <i><tt>E</tt></i> substituted for <tt>this</tt> (including,
of course, implicit occurrences of <tt>this</tt>).&nbsp; In cases where
evaluation of the actual parameters may have side-effects or may raise
exceptions, ESC/Java does the right thing:&nbsp; It checks the preconditions
of the routine for the program state after the side-effects, and only for
cases in which evaluation of all parameters would terminate normally.</li>

<li>
When checking code that contains a method call <tt><i>E</i>.<i>m</i>(</tt>...<tt>)</tt>,
ESC/Java determines the specification (preconditions, modification targets,
and postconditions) of <i><tt>m</tt></i> based on the static type <i><tt>T</tt></i>
of <i><tt>E</tt></i>, even if <i><tt>E</tt></i> can be proven always to
be of some subtype <i><tt>S</tt></i> of <i><tt>T</tt></i>.&nbsp; (To get
ESC/Java to use additional specifications of <tt><i>S</i>.<i>m</i></tt>
beyond those inherited from <tt><i>T</i>.<i>m</i></tt>, you could rewrite
the Java code to cast <i><tt>E</tt></i> to type <i><tt>S</tt></i> before
invoking <i><tt>m</tt></i>.)</li>
</ul>

<h4>
<a NAME="2.3.0  requires pragma"></a>2.3.0&nbsp; <tt>requires</tt> pragma</h4>
A <tt>requires</tt> pragma is a routine modifier pragma.&nbsp; It has the
form
<blockquote><tt>requires <i>E</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>E</tt></i> is a boolean specification expression.&nbsp; The
pragma makes <i><tt>E</tt></i> a precondition of the routine the pragma
modifies.&nbsp; When checking the body of the routine, ESC/Java assumes
that <i><tt>E</tt></i> holds initially.&nbsp;&nbsp; When checking a call
to the routine, ESC/Java issues a warning if it cannot establish that <i><tt>E</tt></i>
holds at the call site.
<p><b>Fine points</b>
<p>If the routine is <tt>synchronized</tt>, then <i><tt>E</tt></i> is assumed
to hold before acquisition of the lock.&nbsp; If the routine is a constructor,
then <i><tt>E</tt></i> is assumed to hold before the implicit superclass
constructor call, if any, and thus also before execution of instance variable
initializers.
<p>Except for the formal parameters of the routine, the variables mentioned
in <i><tt>E</tt></i> must be spec-accessible (see <a href="#3.3  Scoping, name resolution, and access control in specificat">section
3.3</a>) anywhere the routine itself is accessible.&nbsp; For example,
a precondition of a <tt>public</tt> method may not mention a <tt>private</tt>
variable (unless the variable is declared <tt>spec_public</tt>, see <a href="#2.5.0  spec_public pragma">section
2.5.0</a>).
<p>A method declaration that overrides another method declaration cannot
be modified with a <tt>requires</tt> pragma, but inherits the overridden
method's preconditions as described above.&nbsp; Multiple inheritance can
lead to unsoundness in some cases, as discussed in <a href="#C.0.5  Multiple inheritance">section
C.0.5</a>.
<p>A single routine declaration may be modified with any number of <tt>requires</tt>
pragmas.&nbsp; The effective precondition is the conjunction of all the
preconditions given, but any resulting warning message indicates the specific
<tt>requires</tt>
pragma giving rise to the warning, and warnings arising from each pragma
can be suppressed individually.
<h4>
<a NAME="2.3.1  modifies pragma"></a>2.3.1&nbsp; <tt>modifies</tt> pragma</h4>
A <tt>modifies</tt> pragma is a routine modifier pragma.&nbsp; It has the
form
<blockquote><tt>modifies <i>L</i> ;</tt><i><sub><font size=-1>opt</font></sub></i></blockquote>
where <i><tt>L</tt></i> is a nonempty, comma-separated list of specification
designators.&nbsp; A specification designator designates a mutable component
of the state.&nbsp; It is very much like a Java <i>LeftHandSide</i> [<i>JLS</i>,
19.12], but generalized as described below.&nbsp; The pragma specifies
that the routine is allowed (but not required) to modify any of the state
components listed in <i><tt>L</tt></i>.
<p>The state components named in modifies pragmas of a routine are called
<i>modification
targets</i> of the routine.&nbsp; When checking code that calls a routine,
ESC/Java assumes that the call modifies only the routine's modification
targets (with the usual substitutions) and possibly also any freshly allocated
state, regardless of whether the call terminates normally or abruptly.
However, the current ESC/Java does not enforce <tt>modifies</tt> pragmas
when checking a routine's implementation.
<p><b>Fine points</b>
<p>Permissible forms of specification designators are:
<blockquote>
<ul>
<li>
<i>a simple name</i> <i><tt>n</tt></i>.&nbsp; The name must denote a non-<tt>final</tt>
field (possibly a ghost field, see <a href="#2.6.0  ghost pragma">section
2.6.0</a>).&nbsp; This form allows modification of <tt>this.<i>n</i></tt>
if the routine is an instance method, or of <tt><i>T</i>.<i>n</i></tt>
if the routine is a static method of class <i><tt>T</tt></i>.</li>

<li>
<i>a field access</i> of the form <tt><i>O</i>.<i>f</i></tt>, where <i><tt>O</tt></i>
is a specification expression of a reference type <tt>T</tt> and <i><tt>f</tt></i>
denotes one of the fields (possibly a ghost field) of <tt>T</tt>.&nbsp;
This form allows modification of <tt><i>O</i>.<i>f</i></tt>.&nbsp; If <i><tt>f</tt></i>
is a static field, <i><tt>O</tt></i> is used only in that its static type
disambiguates <i><tt>f</tt></i>.</li>

<li>
<i>an array access</i> of the form <tt><i>A</i>[<i>I</i>]</tt>, where <i><tt>A</tt></i>
is a specification expression of an array type, and <i><tt>I</tt></i> is
a specification expression of an integral type other than <tt>long</tt>.&nbsp;
This form allows modification of <tt><i>A</i>[<i>I</i>]</tt>.</li>

<li>
<i>an array range</i> of the form <tt><i>A</i>[*]</tt>, where <i><tt>A</tt></i>
is a specification expression of an array type.&nbsp; This form allows
modification of all elements of <i><tt>A</tt></i> (but not of <i><tt>A</tt></i>
itself).</li>
</ul>
</blockquote>
A routine may be annotated with multiple <tt>modifies</tt> pragmas, in
which case a call is assumed possibly to modify any state component listed
in any of the <tt>modifies</tt> pragmas.&nbsp; If no modification targets
are specified for a routine, then ESC/Java will assume that calls to the
routine modify only freshly allocated state, if any.
<p>A method declaration that overrides another method declaration cannot
be annotated with a <tt>modifies</tt> pragma, but inherits the modification
targets of the overridden method.&nbsp; Note that this forbids the overriding
method from modifying additional state, but see the description of <tt>also_modifies</tt>
below (<a href="#2.3.8  also_modifies pragma">section 2.3.8</a>).
<h4>
<a NAME="2.3.1.0  target fields"></a>2.3.1.0&nbsp; target fields</h4>
When a modification target of a routine has the form <tt><i>E</i>.<i>f</i></tt>
(or simply <i><tt>f</tt></i>, meaning <tt>this.<i>f</i></tt>), the field
<i><tt>f</tt></i>
is said to be a <i>target field</i> of the routine.&nbsp; (Note that a
modification target of the form <tt><i>E</i>.<i>g</i>.<i>f</i></tt> makes
<i><tt>f</tt></i>
but not <i><tt>g</tt></i> be a target field).
<h4>
<a NAME="2.3.2  ensures pragma"></a>2.3.2&nbsp; <tt>ensures</tt> pragma</h4>
An <tt>ensures</tt> pragma is a routine modifier pragma.&nbsp; It has the
form
<blockquote><tt>ensures <i>E</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>E</tt></i> is a boolean specification expression.&nbsp; The
pragma makes <i><tt>E</tt></i> a normal (that is, non-exceptional) postcondition
of the routine the pragma modifies.&nbsp; When checking the body of the
routine, ESC/Java issues a warning if it cannot establish that <i><tt>E</tt></i>
holds whenever the routine terminates normally. When checking code that
calls the routine, ESC/Java assumes that <i><tt>E</tt></i> holds just after
the call if the call terminates normally.
<p>In a postcondition of a non-<tt>void</tt> method, the special ESC/Java
identifier <tt>\result</tt> denotes the result of the method.&nbsp; (For
constructors, the constructed object may be denoted only by <tt>this</tt>,
not by <tt>\result</tt>.) The static type of <tt>\result</tt> is the result
type of the method.
<p>Within <i><tt>E</tt></i>, an expression of the form <tt>\fresh(<i>R</i>)</tt>
where <i><tt>R</tt></i> is a specification expression of a reference type
is true if the object denoted by <i><tt>R</tt></i> in the post-state is
allocated in the post-state (implying that <tt><i>R </i>!= null</tt> in
the post-state) and was not allocated in the pre-state.&nbsp; The static
type of <tt>\fresh(<i>R</i>)</tt> is boolean.
<p>A postcondition <i><tt>E</tt></i> may contain expressions of the form
<tt>\old(<i>X</i>)</tt>.&nbsp;
Roughly speaking, <tt>\old(<i>X</i>)</tt> means the value of <i><tt>X</tt></i>
in the pre-state.&nbsp; The static type of <tt>\old(<i>X</i>)</tt> is the
same as the static type of <i><tt>X</tt></i>.&nbsp; An expression <i><tt>X</tt></i>
used as an argument of <tt>\old</tt> may not itself contain applications
of <tt>\old</tt> or <tt>\fresh</tt>.&nbsp; More precise details are given
below.
<p><b>Fine points</b>
<p>Postconditions of a <tt>synchronized</tt> method apply to the state
after the release of the lock.
<p>Except for formal parameters, identifiers used in postconditions of
a routine (and not within <tt>\old</tt>) denote their values in the post-state.&nbsp;
While Java allows a routine body to include assignment to the routine's
formal parameters (thus using the parameters as local variables), such
assignments have no effect as seen by the caller, since parameters are
passed by value.&nbsp; Therefore ESC/Java interprets occurrences of formal
parameters in postconditions as denoting the original (pre-state) actual
parameter values.
<p>A single routine declaration may be modified with any number of <tt>ensures</tt>
pragmas.&nbsp; The effective postcondition is the conjunction of all the
postconditions given, but any resulting warning message indicates the specific
<tt>ensures</tt>
pragma giving rise to the warning, and warnings arising from each pragma
can be suppressed individually.
<p>In a postcondition, an expression of the form <tt>\old(<i>X</i>)</tt>,
where <i><tt>X</tt></i> is a specification expression, denotes the value
denoted by <i><tt>X</tt></i>, except that (1) any occurrence in <i><tt>X</tt></i>
of a target field (see <a href="#2.3.1.0  target fields">section 2.3.1.0</a>)
of the routine is interpreted according to the pre-state value of the field,
and (2) if any modification target of the routine has the form <tt><i>A</i>[<i>i</i>]</tt>
or <tt><i>A</i>[*]</tt>, then <i>all</i> array accesses within <i><tt>X</tt></i>
are interpreted according to the pre-state contents of arrays.&nbsp; Note
that in the normal postcondition of a non-<tt>void</tt> method, <tt>\result</tt>
always refers to the method's result, even when <tt>\result</tt> occurs
in an argument to <tt>\old</tt>.&nbsp; Similarly occurrences of <tt>this</tt>
in a normal postcondition of a constructor always refer to the constructed
object.&nbsp; See sections <a href="#2.3.3  A note on the interaction of modifies and \old">2.3.3</a>and
<a href="#3.2.15  \old">3.2.15</a>
for further discussion of the semantics of <tt>\old</tt>.
<p>It is a source of potential unsoundness for a postcondition to mention
a variable that might not be spec-accessible (<a href="#3.3  Scoping, name resolution, and access control in specificat">section
3.3</a>) to an override of that method, and ESC/Java may forbid such postconditions.&nbsp;
In particular ESC/Java forbids postconditions of a method that mention
<tt>private</tt>
variables except when the routine is <tt>static</tt>, is <tt>final</tt>,
is <tt>private</tt>, or is declared in a <tt>final</tt> class, or when
the <tt>private</tt> variables mentioned are declared <tt>spec_public</tt>
(<a href="#2.5.0  spec_public pragma">section 2.5.0</a>).&nbsp; The current
ESC/Java doesn't forbid, for example, postconditions of <tt>public</tt>
methods from mentioning <tt>package</tt> variables, but future versions
of ESC/Java may not be so lenient.
<p>A method declaration that overrides another method declaration cannot
be modified with an <tt>ensures</tt> pragma, but inherits the postconditions
of the overridden method.&nbsp; (See also the <tt>also_ensures</tt> pragma
described in <a href="#2.3.5  also_ensures pragma">section 2.3.5</a>.)
<p>Since Java guarantees that a constructor call returns a newly allocated
object, ESC/Java automatically supplies the postcondition <tt>\fresh(this)</tt>for
every constructor.
<h4>
<a NAME="2.3.3  A note on the interaction of modifies and \old"></a>2.3.3&nbsp;
A note on the interaction of <tt>modifies</tt> and <tt>\old</tt></h4>
[<i>This section may be skipped on first reading.</i>]
<p>The current ESC/Java does not check that the body of a routine actually
obeys the constraint expressed by the routine's <tt>modifies</tt> pragmas.&nbsp;
This lack of checking is one of several potential sources of missed warnings
(unsoundness).&nbsp; The potential for missed warnings is mitigated somewhat
by a fact that may have seemed surprising when we mentioned it in the previous
section (<a href="#2.3.2  ensures pragma">2.3.2</a>):&nbsp; If a particular
field (either a static field or an instance variable) is not specified
as a target field (<a href="#2.3.1.0  target fields">section 2.3.1.0</a>)
of a routine, then occurrences of that field within arguments to <tt>\old</tt>
in the routine's postconditions are taken to refer to post-state values.
<p>Consider, for example a class with an integer field <tt>f</tt> and a
method <tt>incf</tt> declared as follows, with no <tt>modifies</tt> pragma:
<blockquote><tt>//@ ensures f == \old(f) + 1;</tt>
<br><tt>void incf() {</tt>
<br><tt>&nbsp; this.f++;</tt>
<br><tt>}</tt></blockquote>
Since <tt>f</tt> is not specified as a modification target of <tt>incf</tt>,
ESC/Java will interpret both occurrences of <tt>f</tt> in the ensures pragma
as referring to the post-state value of <tt>this.f</tt>.&nbsp; Consequently
ESC/Java will be unable to show that the method establishes the specified
postcondition, and will issue a warning to that effect.
<p>While this warning may seem surprising, the result of interpreting the
second occurrence of <tt>f</tt> as the pre-state value of <tt>this.f</tt>
would be even worse.&nbsp; Under the latter interpretation ESC/Java would
issue no warnings about the body of <tt>incf</tt>, but would assume after
a call
<tt>x.incf()</tt> both (1)&nbsp; that <tt>x.f</tt> had been incremented
in accordance the postcondition), and (2) that <tt>x.f</tt> was left unchanged
in accordance with the (unchecked) empty set of modification targets.&nbsp;
Since these assumptions are mutually contradictory, the result would be
equivalent to assuming <tt>false</tt>, and ESC/Java would silently omit
all checking after the call.
<p>As an additional guard against omission of <tt>modifies</tt> pragmas,
ESC/Java issues a caution message for any occurrence of <tt>\old(<i>X</i>)</tt>
in a postcondition of a method <i><tt>m</tt></i> unless (1) the expression
<i><tt>X</tt></i>
mentions some target field of <i><tt>m</tt></i>, or (2) the expression
<i><tt>X</tt></i>
includes an array access and <i><tt>m</tt></i> has some modification target
of the form <tt><i>A</i>[<i>I</i>]</tt> or
<tt><i>A</i>[*]</tt>.
<p><font face="Times New Roman,Times">Of course,&nbsp; the interactions
of </font><tt>modifies</tt><font face="Times New Roman,Times"> and </font><tt>\old</tt><font face="Times New Roman,Times">
described above do not entirely make up for the fact that the current ESC/Java
does no checking of </font><tt>modifies</tt><font face="Times New Roman,Times">
pragmas.&nbsp; A method declaration like</font>
<blockquote><tt><font face="Times New Roman,Times">/</font>/@ modifies
someOtherObject.f; //instead of this.f</tt>
<br><tt>//@ ensures f == \old(f) + 1;</tt>
<br><tt>void incf() {</tt>
<br><tt>&nbsp; this.f++;</tt>
<br><tt>}</tt></blockquote>
<font face="Times New Roman,Times">can still effectively disable checking
of code following calls to <tt>incf</tt>.</font>
<h4>
<a NAME="2.3.4  exsures pragma"></a>2.3.4&nbsp; <tt>exsures</tt> pragma</h4>
An <tt>exsures</tt> pragma is a routine modifier pragma.&nbsp; It has the
form
<blockquote><tt>exsures (<i>T</i> <i>t</i>) <i>E</i> ;</tt><i><sub>opt</sub></i></blockquote>
or
<blockquote><tt>exsures (<i>T</i>) <i>E</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>T</tt></i> is a subtype of <tt>java.lang.Throwable</tt>, <i><tt>t</tt></i>
(if included) is a an identifier, and <i><tt>E</tt></i> is a boolean specification
expression.&nbsp; The identifier <i><tt>t</tt></i> (if included) is in
scope in <i><tt>E</tt></i>, where it has type <i><tt>T</tt></i>.&nbsp;
The pragma makes <i><tt>E</tt></i> an exceptional postcondition of the
routine the pragma modifies.&nbsp; That is, it specifies that <i><tt>E</tt></i>
holds whenever the routine completes abruptly by throwing an exception
<i><tt>t</tt></i>
whose type is a subtype of <i><tt>T</tt></i>.
<p>When checking the body of the routine, ESC/Java checks that <i><tt>E</tt></i>
holds whenever the routine completes abruptly by throwing an exception
<i><tt>t</tt></i>
whose type is a subtype of <i><tt>T</tt></i>.&nbsp; When checking code
that calls the routine, ESC/Java assumes that the <i><tt>E</tt></i> holds
just after the call if the call completes abruptly with an exception whose
type is a subtype of <i><tt>T</tt></i>.
<p><b>Fine points</b>
<p>Like normal postconditions, exceptional postconditions of <tt>synchronized</tt>
methods apply to the state after the release of the lock.
<p>The identifier <i><tt>t</tt></i> may not be the same as any formal parameter
of the routine, and quantified expressions (see sections <a href="#3.2.10  \forall">3.2.10</a>
and <a href="#3.2.11  \exists">3.2.11</a>) within <i><tt>E</tt></i> may
not use <i><tt>t</tt></i> as a bound variable name.
<p>The expression <i><tt>E</tt></i> can include uses of <tt>\fresh</tt>
and <tt>\old</tt>, which have the same semantics as in an <tt>ensures</tt>
pragma.&nbsp; However, <i><tt>E</tt></i> cannot mention <tt>\result</tt>,
since an abruptly-terminating routine invocation returns no result.&nbsp;
Similarly
<i><tt>E</tt></i> cannot mention <tt>this</tt> if the <tt>exsures</tt>
pragma modifies a constructor, since we take the view that the object being
constructed should be discarded.&nbsp; (This view is potentially unsound;
see <a href="#C.0.8  Constructor leaking">section C.0.8</a>.)
<p>A single routine declaration may be modified with any number of <tt>exsures</tt>
pragmas.&nbsp; ESC/Java checks that the body obeys each <tt>exsures</tt>
pragma and assumes that calls obey each <tt>exsures</tt> pragma.&nbsp;
For example, if a routine is modified by the pragmas
<blockquote><tt>exsures (<i>T1</i> <i>t</i>) <i>E1</i>; exsures (<i>T2
t</i>)
<i>E2</i>;</tt></blockquote>
where <i><tt>T2</tt></i> is a subtype of <i><tt>T1</tt></i>, then ESC/Java
checks (if checking the body of the routine) or assumes (if checking a
caller) that <i><tt>E1</tt></i> holds whenever the routine completes abruptly
by throwing an exception that is an instance of <i><tt>T1</tt></i>,&nbsp;
and that both <i><tt>E1</tt></i> and <i><tt>E2</tt></i> hold whenever the
routine completes abruptly by throwing an exception that is an instance
of <i><tt>T2</tt></i>.
<p>A method declaration that overrides another method declaration cannot
be modified with an <tt>exsures</tt> pragma, but inherits the exceptional
postconditions of the overridden method.&nbsp; (See also the <tt>also_exsures</tt>
pragma described in <a href="#2.3.6  also_exsures pragma">section 2.3.6</a>.)
<h4>
<a NAME="2.3.5  also_ensures pragma"></a>2.3.5&nbsp; <tt>also_ensures</tt>
pragma</h4>
An <tt>also_ensures</tt> pragma is a routine modifier pragma.&nbsp; It
has the form
<blockquote><tt>also_ensures <i>E</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>E</tt></i> is a boolean specification expression.&nbsp; An
<tt>also_ensures</tt> pragma
has the same semantics as an <tt>ensures</tt> pragma, but may appear as
a modifier only of a method declaration that overrides another method declaration
(while overriding method declarations are forbidden to have
<tt>ensures</tt>
pragmas).
<h4>
<a NAME="2.3.6  also_exsures pragma"></a>2.3.6&nbsp; <tt>also_exsures</tt>
pragma</h4>
An <tt>also_exsures</tt> pragma is a routine modifier pragma.&nbsp; It
has the form
<blockquote><tt>also_exsures (<i>T</i> <i>t</i>) <i>E</i> ;</tt><i><sub>opt</sub></i></blockquote>
or
<blockquote><tt>also_exsures (<i>T</i> <i>t</i>) <i>E</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>T</tt></i> is a subtype of <tt>java.lang.Throwable</tt>, <i><tt>t</tt></i>
(if included) is a an identifier, and <i><tt>E</tt></i> is a boolean specification
expression.&nbsp; An <tt>also_exsures</tt> pragma has the same semantics,
and must obey the same syntactic restrictions, as an <tt>exsures</tt> pragma,
but may appear as a modifier only of a method declaration that overrides
another method declaration (while overriding method declarations are forbidden
to have
<tt>exsures</tt> pragmas).
<p>The relationship between <tt>also_exsures</tt> and <tt>exsures</tt>
is exactly analogous to that between <tt>also_ensures</tt> and <tt>ensures</tt>.
<h4>
<a NAME="2.3.7  also_requires pragma"></a>2.3.7&nbsp; <tt>also_requires</tt>
pragma</h4>
An <tt>also_requires</tt> pragma is a routine modifier pragma.&nbsp; It
has the form
<blockquote><tt>also_requires <i>E</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>E</tt></i> is a boolean specification expression.&nbsp; An
<tt>also_requires</tt>
pragma has the same semantics as a <tt>requires</tt> pragma, but the declaration
of a method <i><tt>C.m</tt></i> may be modified by an <tt>also_requires</tt>
pragma only if all three of the following conditions hold:
<ul>
<li>
<i><tt>C</tt></i> is a class (not an interface),</li>

<li>
the declaration of <i><tt>C.m</tt></i> overrides some method declaration
in a superinterfaces of <i><tt>C</tt></i>, and</li>

<li>
the declaration of <i><tt>C.m</tt></i> does <i>not</i> override any method
declaration in a superclass of <i><tt>C</tt></i>.</li>
</ul>
(By contrast, a <tt>requires</tt> pragma may only modify a method [or constructor]
declarations that does not override any other method declaration, and neither
a <tt>requires</tt> pragma nor an <tt>also_requires</tt> pragma may modify
a method declarations in classes that overridden declaration in a superclasses,
or a method declaration in an interface that overrides a method declaration
in a superinterface.)
<p><b>Fine points</b>
<p>The <tt>also_require</tt> pragma is a potential source of unsoundness.&nbsp;
Suppose method <tt>C.m</tt> of class <tt>C</tt> overrides method <tt>I.m</tt>
of interface <tt>I</tt>.&nbsp; When checking a call of the form <tt><i>E</i>.m(</tt>...<tt>)</tt>,
where <i><tt>E</tt></i> is an expression of type <tt>I</tt>, ESC/Java only
enforces the preconditions of <tt>I.m</tt> and not any preconditions given
by <tt>also_requires</tt> pragmas modifying the declaration of <tt>C.m</tt>.&nbsp;
However, the expression <i><tt>E</tt></i> might evaluate to a value of
type <tt>C</tt>, causing the call to invoke <tt>C.m</tt>, and the correctness
of <tt>C.m</tt>'s implementation may depend on preconditions given in such
<tt>also_requires</tt>
pragmas.&nbsp; The reason that ESC/Java includes an <tt>also_requires</tt>
pragma, despite its unsoundness, is that it is often essential for preconditions
of a method <tt>C.m</tt> to mention instance variables of class <i><tt>C</tt></i>,
and Java does not allow instance variables to be declared in interfaces.&nbsp;
[Note, however, that ESC/Java does allow declarations of ghost variables
(<a href="#2.6.0  ghost pragma">section 2.6.0</a>) in interfaces.]
<p>In addition to the potential unsoundness just described, the <tt>also_requires</tt>
pragma shares the potential unsoundness of the <tt>require</tt> pragma
in the presence of multiple inheritance (see <a href="#C.0.5  Multiple inheritance">section
C.0.5</a>).
<h4>
<a NAME="2.3.8  also_modifies pragma"></a>2.3.8&nbsp; <tt>also_modifies</tt>
pragma</h4>
An <tt>also_modifies</tt> pragma is a routine modifier pragma.&nbsp; It
has the form
<blockquote><tt>also_modifies <i>L</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>L</tt></i> is a nonempty, comma-separated list of specification
designators (see <a href="#2.3.1  modifies pragma">section 2.3.1</a>).&nbsp;
An <tt>also_modifies</tt> pragma has the same semantics as a <tt>modifies</tt>
pragma (<a href="#2.3.1  modifies pragma">section 2.3.1</a>), but may appear
only as a modifier of a method declaration that overrides another method
declaration (while overriding method declarations are forbidden to have
<tt>modifies</tt>
pragmas).
<p>An overriding method declaration may modify both the targets named in
its own <tt>also_modifies</tt> pragmas and any modification targets it
inherits from the overridden method.
<p><b>Fine points</b>
<p>Like the <tt>also_require</tt> pragma (<a href="#2.3.7  also_requires pragma">section
2.3.7</a>), the <tt>also_modifies</tt> pragma is a potential source of
unsoundness.&nbsp; When writing code that follows a call <tt><i>E</i>.m(</tt>...<tt>)</tt>
where <i><tt>E</tt></i> has static type <tt>T</tt>, a programmer may reasonably
be expected to cope with the possibility that the call has modified parts
of the state named in <tt>modifies</tt> pragmas that annotate the declaration
of <tt>T.m</tt>, but it seems unreasonable to expect the programmer to
deal with the possibility that the call might modify other parts of the
state (perhaps parts mentioned in <tt>also_modifies</tt> pragmas of yet-to-be-written
overrides) as well.
<p>The reason that ESC/Java includes an <tt>also_modifies</tt> pragma is
that an overriding method may need to modify fields that are not in scope
at the point where the overridden method is declared, such as <tt>private</tt>
variables of the class declaring the overriding method.
<p>To reduce the likelihood of unsoundness, <tt>also_modifies</tt> pragmas
ought not to name modification targets that are accessible [<i>JLS</i>,
6.6] from the scope of the overridden method.&nbsp; However, the current
ESC/Java does not enforce any such restriction.&nbsp; For more discussion
of the problem of specifying modification targets in the presence of subclassing,
and for a sound solution thereof, see [<a href="#[Leino98]">Leino98</a>].
<h3>
<a NAME="2.4  Pragmas for specifying data invariants"></a>2.4&nbsp; Pragmas
for specifying data invariants</h3>
This section describes several pragmas that ESC/Java provides for specifying
properties of variables and data structures.
<h4>
<a NAME="2.4.0  non_null pragma"></a>2.4.0&nbsp; <tt>non_null</tt> pragma</h4>
A <tt>non_null</tt> pragma is a modifier pragma.&nbsp; It may modify the
declaration of a variable of a reference type.&nbsp; The variable may be
a static field, instance variable, local variable, or parameter.&nbsp;
It has the form
<blockquote><tt>non_null</tt></blockquote>
The pragma causes ESC/Java to check, at each assignment to the variable,
that the value assigned is not <tt>null</tt>, and to assume at each use
(except in one case, described below) that the value is not <tt>null</tt>.&nbsp;
When a formal parameter declaration is annotated with a <tt>non_null</tt>
pragma, ESC/Java checks at each call site that the corresponding actual
is not <tt>null</tt>.
<p><b>Fine points</b>
<p>In the case that a <tt>non_null</tt> instance variable <i><tt>x</tt></i>
is declared in a class <i><tt>C</tt></i> and a read access of <i><tt>x</tt></i>
occurs in a constructor of <i><tt>C</tt></i> that does not call a sibling
constructor, then ESC/Java does not automatically assume that the value
read will be non-null.
<p>ESC/Java allows a <tt>non_null</tt> pragma to modify a formal parameter,
even though Java 1.0 syntax does not allow modifiers on parameter declarations.
<p>A <tt>non_null</tt> pragma may not modify a parameter declaration of
a method that overrides another method.
<p>Sometimes the same design decision might be expressed either by a <tt>non_null</tt> pragma
or by some other kind of pragma, such as a <tt>requires</tt> pragma or
an <tt>invariant</tt> pragma.&nbsp; For example, instead of using a
<tt>requires</tt>
pragma in <a href="#0.2  Scene 2:  We write a requires (precondition) pragma for">section
0.2</a>
<blockquote><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp;
//@ requires input != null;</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; Bag(int[]
input) {</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; </tt>...
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; }</tt></blockquote>
we might have written
<blockquote><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp;
Bag(/*@ non_null */ int[] input) </tt>...</blockquote>
and instead of using a <tt>non_null</tt> pragma in <a href="#0.3  Scene 3:  We add a non_null pragma for the field a.">section
0.3</a>
<blockquote><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp; </font>class Bag
{</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; /*@ non_null
*/ int[] a;</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; </tt>...</blockquote>
we might have written
<blockquote><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp; </font>class Bag
{</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; int[]
a;</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; //@ invariant
a != null;</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp; </tt>...</blockquote>
In each of these cases, the alternative annotations have slightly different
semantics, but either alternative would be adequate to enable checking
of our example program.&nbsp; (The differences are that the <tt>non_null</tt>
pragmas are checked at every assignment to <tt>input</tt> or <tt>a</tt>,
whereas the <tt>requires</tt> pragma would allow assignments of <tt>null</tt>
to <tt>input</tt> within the body of the <tt>Bag</tt> constructor, and
the <tt>invariant</tt> pragma would be checked only at routine calls, as
explained in <a href="#2.4.1  invariant pragma">section 2.4.1</a>.)
<p>We recommend that <tt>non_null</tt> pragmas be used in preference to
semantically similar <tt>requires</tt> and<tt> invariant</tt> pragmas except
in cases where the somewhat stricter semantics of <tt>non_null</tt> makes
its use untenable.
<p><b>Limitation:</b>&nbsp; Since the current ESC/Java does not check static
bodies and static initializers, it is entirely the user's responsibility
to ensure that static fields declared as <tt>non_null</tt> are in fact
initialized to have non-null values.
<h4>
<a NAME="2.4.1  invariant pragma"></a>2.4.1&nbsp; <tt>invariant</tt> pragma</h4>
An <tt>invariant</tt> pragma is a declaration pragma.&nbsp; It has the
form
<blockquote><tt>invariant <i>E</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>E</tt></i> is a boolean specification expression.&nbsp; The
pragma declares <i>E</i> to be an <i>object invariant</i> of the class
within whose declaration the pragma occurs.&nbsp; If <i><tt>E</tt></i>
mentions <tt>this</tt>, either explicitly or implicitly, then <i><tt>E</tt></i>
is said to be an <i>instance invariant</i>; otherwise <i><tt>E</tt></i>
is a <i>static invariant</i>. Roughly speaking, all object invariants are
supposed to hold at all routine call boundaries.&nbsp; That is (1) if <i><tt>E</tt></i>
an instance invariant of class <i><tt>T</tt></i>, then
<blockquote><tt>(\forall <i>T</i> <i>t</i>; <i>E</i><sub>this=<i>t</i></sub>)</tt></blockquote>
should be true at all routine calls and returns, where <i><tt>t</tt></i>
is a variable not occurring in <i><tt>E</tt></i>, the universal quantification
ranges over all allocated instances <i><tt>T</tt></i>, and <tt><i>E</i><sub>this=<i>t</i></sub></tt>
is the result of substituting <i><tt>t</tt></i> for all (explicit and implicit)
occurrences of <tt>this</tt> in <i><tt>E</tt></i>, and (2) if <i><tt>E</tt></i>
is a static invariant of class <i><tt>T</tt></i>, then <i><tt>E</tt></i>
should be true at all routine call boundaries, regardless of whether or
not any allocated objects of class <i><tt>T</tt></i> exist.
<p><b>Fine points</b>
<p>ESC/Java does not fully enforce the discipline just described, partly
because it would be too strict for many programs (which may have legitimate
reasons for temporarily breaking object invariants) and partly because
such checking would be very expensive.&nbsp; Instead, it performs less
expensive (and potentially unsound) checking.&nbsp; Essentially, ESC/Java
assumes object invariants for all objects on entry to a routine body, and
checks objects invariants for all objects at the end of the body; however,
at call sites, ESC/Java checks object invariants only for parameters and
static fields, and assumes of the call only that it doesn't break any object
invariants and that it establishes object invariants for freshly allocated
objects.&nbsp; More precisely, when checking the body of a routine <i><tt>R</tt></i>:
<blockquote>ESC/Java chooses, from all available object invariants, a set
of invariants to be considered relevant to the checking of <i><tt>R</tt></i>.&nbsp;
[The heuristic used to choose the ``relevant'' object invariants is fairly
complicated and subject to change, so we don't explain it in this manual.]
<p>ESC/Java assumes that at the start of <i><tt>R</tt></i>'s body, all
relevant static invariants hold, and all relevant instance invariants hold
for all allocated objects.</blockquote>

<blockquote>For every routine call in the body of <i><tt>R</tt></i>:
<blockquote>ESC/Java checks that all relevant (to <i><tt>R</tt></i>) static
invariants hold before the call.
<p>ESC/Java checks that the value of each actual parameter of the call,
including the implicit <tt>this</tt> parameter of an instance method call,
satisfies every relevant (to <i><tt>R</tt></i>) instance invariant of every
supertype of the static type of the corresponding formal parameter.
<p>ESC/Java checks that the value of each static field <i><tt>f</tt></i>
(actually each of a heuristically selected set of ``relevant'' static fields)
satisfies every relevant (to <i><tt>R</tt></i>) instance invariant of every
supertype of the static type of <i><tt>f</tt></i>.
<p>ESC/Java assumes that all relevant (to <i><tt>R</tt></i>) static invariants
hold after the call.
<p>ESC/Java assumes that, after the call, each relevant (to <i><tt>R</tt></i>)
object invariant <i><tt>E</tt></i> of type <i><tt>T</tt></i> holds for
all instances of <i><tt>T</tt></i> for which <i><tt>E</tt></i> held before
the call, and for all instances of <i><tt>T</tt></i> allocated by the call
(except that when a constructor calls a superclass constructor, ESC/Java
assumes that the constructed object satisfies the instance invariants of
the supertype but not necessarily any additional invariants of the subtype).</blockquote>
ESC/Java checks that at the end of <i><tt>R</tt></i>'s body all relevant
static invariants hold, and all relevant instance invariants hold for all
allocated objects (except that if <i><tt>R</tt></i> is a constructor, ESC/Java
assumes that the constructed object satisfies all relevant object invariants
of <i><tt>R</tt></i>'s type, including those inherited from supertypes,
but not necessarily those of any subtypes of <i><tt>R</tt></i> whose constructors
may call <i><tt>R</tt></i> as a superclass constructor, and furthermore,
when considering abnormally-terminating executions of the constructor <i><tt>R</tt></i>,
ESC/Java makes no assumptions about the constructed object).</blockquote>
It is a potential source of unsoundness for an object invariant to mention
fields other than those declared in the class declaring the invariant.&nbsp;
For example, suppose that <tt>S</tt> is a subclass of <tt>T</tt> and that
an instance invariant of <tt>S</tt> mentions a field <tt>f</tt> declared
in <tt>T</tt>, and consider a routine <tt>R</tt> containing an assignment
<tt>x.f
= </tt>... where <tt>x</tt> has static type <tt>T</tt>.&nbsp; If
<tt>x</tt>
has allocated type <tt>S</tt>, the assignment might break the instance
invariant declared in <tt>S</tt>.&nbsp; But neither the programmer of <tt>R</tt>
nor ESC/Java can reasonably be expected to enforce the invariants of <tt>S</tt>,
since <tt>S</tt> might not be in scope in <tt>R</tt>, and indeed might
be written after <tt>R</tt>.&nbsp; The current ESC/Java does not attempt
to detect declarations of such unenforceable invariants, but future versions
may bring some such declarations to the programmer's attention.&nbsp; (For
a more detailed examination of the unenforceable invariant problem, see
[<a href="#[LS97]">LS97</a>].)
<p>When a <tt>final</tt> field <i><tt>f</tt> </i>is declared with a <i>VaribleInitializer
</i>[<i>JLS</i>,
19.8.2], ESC/Java may infer some simple invariants automatically.&nbsp;
For instance, if the initializer is a constant expression [<i>JLS</i>,
15.27] <i><tt>C</tt></i> not of type <tt>String</tt>, then ESC/Java infers
the invariant <tt><i>f</i> == <i>C</i></tt>; and if the initializer is
a string literal, an array constructor, or an invocation of <tt>new</tt>,
then ESC/Java infers the invariant <tt><i>f</i> != null</tt>.
<p><b>Limitation:</b>&nbsp; The static bodies and static initializers of
a class are supposed to establish the static invariants declared in the
class, but the current ESC/Java does not check this.&nbsp; Thus the responsibility
for initial establishment of static invariants lies entirely with the user.
<h4>
<a NAME="2.4.2  axiom pragma"></a>2.4.2&nbsp; <tt>axiom</tt> pragma</h4>
An <tt>axiom</tt> pragma is a declaration pragma.&nbsp; It has the form
<blockquote><tt>axiom <i>E</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>E</tt></i> is a boolean specification expression.&nbsp; The
pragma causes ESC/Java to assume that <i><tt>E</tt></i> (which we call
an <i>axiom</i>) is true at the start of every routine body that it checks.
<p><b>Fine points</b>
<p>Since the <tt>axiom</tt> pragma introduces assumptions without introducing
reciprocal checks, it is potentially unsound and programmers should use
it carefully.
<p>An obvious use of an <tt>axiom</tt> pragma would be to state some universally
true fact.&nbsp; For example, the built-in capabilities of Simplify (<tt>Simplify(1)</tt>),
the theorem prover used by ESC/Java, include a decision procedure for linear
arithmetic but no rules about multiplication other than by constants.&nbsp;
Thus there may be cases where ESC/Java would be helped by an annotation
like
<blockquote><tt>//@ axiom (\forall int x, y; x >= 0 &amp; y >= 0 ==> x*y
>= 0);</tt></blockquote>
(recall that ESC/Java doesn't claim to check for arithmetic overflow, so
an axiom like this is consistent with the view that Java <tt>int</tt>'s
behave like the mathematical integers, although this view is not true).&nbsp;
Beware that profligate introduction of axioms (in the hope that they may
occasionally be useful) can have a serious impact on performance.
<p>Less obviously, axioms mentioning Java variables are sometimes useful,
and ESC/Java allows such axioms despite the unsoundness inherent in assuming
them when checking method bodies without also checking them at call sites.&nbsp;
For further discussion of this point, see the example in <a href="#2.7.2  Examples illustrating race and deadlock checking">section
2.7.2</a> involving an axiom about the lock order.&nbsp; Axioms may not
mention <tt>this</tt> or <tt>\lockset</tt>.
<p>When checking a constructor body, ESC/Java assumes that axioms hold
before the implicit superclass constructor call, if any, and thus also
before execution of instance variable initializers.
<p>When it is clear that the correctness of the program depends on a particular
property holding for a particular expression <i><tt>E</tt></i> of type
<i><tt>T</tt></i>
at a particular point in the program, it may be better to write an <tt>assume</tt>
pragma
<blockquote><tt>//@ assume </tt>...<i><tt>E</tt></i>...<tt>;</tt></blockquote>
at that point in the program, in preference to introducing an axiom pragma
<blockquote><tt>//@ axiom (\forall t <i>T</i>; </tt>...<tt>t</tt>...<tt>);</tt></blockquote>
stating that the property holds for all values of the type (even if it
does).&nbsp; For one thing, the Simplify theorem prover used by ESC/Java
is incomplete, and may not discover the relevant instance of the axiom
to apply.&nbsp; On the other hand, regardless of whether Simplify discovers
the relevant instance of the axiom, it may spend a lot of time considering
many irrelevant instances.
<p><b>Limitation:&nbsp; </b>Just as for invariants (<a href="#2.4.1  invariant pragma">section
2.4.1</a>), ESC/Java limits its use of axioms to a restricted set of axioms
considered ``relevant'' to the checking of any particular routine <i><tt>R</tt></i>.&nbsp;
In the current version of ESC/Java, the only axioms considered relevant
are those declared in the same class as the implementation being checked.
Consequently, there is no way for the user to declare ``libraries'' of
potentially useful axioms.
<h4>
<a NAME="2.4.3  loop_invariant pragma"></a>2.4.3&nbsp; <tt>loop_invariant</tt>
pragma</h4>
A <tt>loop_invariant</tt> pragma is a statement pragma.&nbsp; It has the
form
<blockquote><tt>loop_invariant <i>E</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>E</tt></i> is a boolean specification expression.&nbsp;&nbsp;
A <tt>loop_invariant</tt> pragma must appear before a Java loop statement--that
is, a Java <tt>for</tt>, <tt>while</tt>, or <tt>do</tt> statement [<i>JLS</i>,
14.10, 14.11. 14.12], or a Java labeled statement [<i>JLS</i>, 14.6] <tt><i>L</i>:<i>
S</i></tt> such that <i><tt>S</tt></i> is a Java labeled statement. Between
the <tt>loop_invariant</tt> pragma and the associated loop statement, there
may be no intervening Java code and no intervening pragmas, except for
<tt>nowarn</tt>
pragmas and other <tt>loop_invariant</tt> pragmas.&nbsp; The pragma causes
ESC/Java to check that <i><tt>E</tt></i> holds at the start of each iteration
of the loop.
<p><b>Fine points</b>
<p>For the purposes of name-scoping, a loop invariant is treated as if
it occurred just inside the associated loop statement.&nbsp; That is, if
the associated loop statement is a <tt>for</tt> statement (or a <tt>for</tt>
statement wrapped within one or more labeled statements), then the variables
declared by the <i>ForInit</i> [<i>JLS</i>, 19.11] are in scope in the
loop invariant.
<p>An ``iteration of a loop'' includes the termination test, and also includes
the update code in a <tt>for</tt> loop.&nbsp; Thus
<blockquote><tt>//@ loop_invariant <i>E</i>;</tt>
<br><tt>while (<i>B</i>) {</tt>
<br><tt>&nbsp; <i>S</i></tt>
<br><tt>}</tt></blockquote>
intuitively means
<blockquote><tt>while (true) {</tt>
<br><tt>&nbsp; //@ assert <i>E</i>;&nbsp;&nbsp;&nbsp; // but giving a LoopInv
warning</tt>
<br><tt>&nbsp; if (!(<i>B</i>)) break;</tt>
<br><tt>&nbsp; S</tt>
<br><tt>}</tt></blockquote>
(however, see the comments below about loop unrolling).&nbsp; Note that
the checking of the loop invariant <i><tt>E</tt></i> applies to the state
before the test of <i><tt>B</tt></i> (and before any side effects in the
evaluation of <i><tt>B</tt></i>).&nbsp; Likewise,
<blockquote><tt>//@ loop_invariant </tt><i>E</i><tt>;</tt>
<br><tt>do {</tt>
<br><tt>&nbsp; <i>S</i></tt>
<br><tt>} while (B);</tt></blockquote>
intuitively means
<blockquote><tt>while (true) do</tt>
<br><tt>&nbsp;//@ assert <i>E</i>;&nbsp;&nbsp;&nbsp; // but giving a LoopInv
warning</tt>
<br><tt>&nbsp;<i>S</i></tt>
<br><tt>&nbsp;if (!(<i>B</i>)) break;</tt>
<br><tt>}</tt></blockquote>
and
<blockquote><tt>//@ loop_invariant <i>E;</i></tt>
<br><tt><i>L</i>: for(<i>I1</i>, </tt>...<tt>, <i>Im</i>; <i>B</i>;
<i>U1,
</i></tt>...<tt><i>,
Un</i>) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; <i>S</i></tt>
<br><tt>&nbsp;&nbsp; }</tt></blockquote>
intuitively means
<blockquote><tt>{ <i>I1</i>, </tt>...<tt>, <i>Im</i>;</tt>
<br><tt>&nbsp; <i>L</i>: while (true) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; //@ assert <i>E</i>;&nbsp;&nbsp;&nbsp; // but
giving a LoopInv warning</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if (!(<i>B</i>)) break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <i>S</i></tt>
<br><tt>&nbsp;&nbsp;&nbsp; <i>U1</i>, </tt>...<tt>, <i>Un</i>;</tt>
<br><tt>&nbsp;&nbsp; }</tt>
<br><tt>}</tt></blockquote>
but with any occurrence within <i><tt>S</tt></i> of
<blockquote><tt>continue <i>L</i>;</tt></blockquote>
(or simply of <tt>continue;</tt> appearing outside of any nested loop and
thus meaning <tt>continue <i>L</i>;</tt>) transferring control only to
the end of <i><tt>S</tt></i> rather than to the end of <i><tt>Un</tt></i>.
<p>In ESC/Java, loop invariants are optional.&nbsp; The checker considers
only execution paths in which the loop body is executed at most once (and
the test for being finished is executed most twice), rather than the potentially
infinite number of paths that are really possible.&nbsp; Because of this
simplification the checker doesn't need an invariant to analyze the loop.
<p>If you do include a loop invariant, ESC/Java will check that it holds
both initially and after the single loop iteration that the current checker
considers.&nbsp; Consequently, the checking performed on
<blockquote><tt>//@ loop_invariant <i>E</i>;</tt>
<br><tt>while (<i>B</i>) {</tt>
<br><tt>&nbsp; <i>S</i></tt>
<br><tt>}</tt></blockquote>
is actually the same as would be done for
<blockquote><tt>//@ assert <i>E</i>;&nbsp;&nbsp;&nbsp; // but giving a
LoopInv warning</tt>
<br><tt>if (<i>B</i>) {</tt>
<br><tt>&nbsp; S</tt>
<br><tt>&nbsp; //@ assert <i>E</i>;&nbsp; // but giving a LoopInv warning</tt>
<br><tt>&nbsp; //@ assume !B; // (don't check later code for case <i>B</i>
== true)</tt>
<br><tt>}</tt></blockquote>
(where execution of a <tt>continue</tt> in <i><tt>S</tt></i> results in
normal termination of <i><tt>S</tt></i> and execution of a <tt>break</tt>
in <i><tt>S</tt></i> results in normal termination of the entire code fragment
above).&nbsp; You can make ESC/Java check more (or fewer) iterations of
loops by using the <tt>-loop</tt> command-line option (see <a href="#C.0.1  Loops">section
C.0.1</a>).
<br>&nbsp;
<h3>
<a NAME="2.5  Pragmas affecting conditions under which variables may be"></a>2.5&nbsp;
Pragmas affecting conditions under which variables may be referenced</h3>

<h4>
<a NAME="2.5.0  spec_public pragma"></a>2.5.0&nbsp; <tt>spec_public</tt>
pragma</h4>
A <tt>spec_public</tt> pragma is a modifier pragma.&nbsp;&nbsp; It may
occur as a modifier only of a non-<tt>public</tt> field declaration.&nbsp;
It has the form
<blockquote><tt>spec_public</tt></blockquote>
The effect of the pragma is to make the fields declared in the declaration
be as spec-accessible (that is accessible in pragmas, see <a href="#3.3  Scoping, name resolution, and access control in specificat">section
3.3</a>) as they would have been if the declaration had been <tt>public</tt>.
<p>For example, if a <tt>private</tt> field of a class is declared with
a <tt>spec_public</tt> pragma, then the field can be mentioned in pre-
and postconditions of a <tt>public</tt> method, but clients of the class
cannot modify the field directly.
<p><b>Example</b>
<p>Consider the <tt>Bag</tt> example form section 0.&nbsp; In presenting
this example, we glossed over the issue of accessibility.&nbsp; To allow
clients of the <tt>Bag</tt> class to make use of the routines of the class
(<tt>Bag</tt>,<tt>extractMin</tt>, and others that we might add), these
routines should be declared <tt>public</tt>.&nbsp;&nbsp; On the other hand,
the fields
<tt>a</tt> and <tt>n</tt> used in the implementation ought not
to be <tt>public</tt>.&nbsp; For example, arbitrary clients ought not to
be able to write these fields except by calling routines of the
<tt>Bag</tt>
class.
<p>If we simply declare the routines, but not the fields of<tt> Bag</tt>
to be <tt>public</tt>, ESC/Java will complain:
<blockquote><b><font face="Arial,Helvetica">ESC/Java input from Bag.java</font></b>
<br><tt><font size=-2>&nbsp;1:&nbsp; </font>class Bag {</tt>
<br><tt><font size=-2>&nbsp;2:&nbsp;&nbsp;</font>&nbsp; /*@ non_null */
int[] a;</tt>
<br><tt><font size=-2>&nbsp;3:&nbsp;&nbsp;</font>&nbsp; int n;</tt>
<br><font size=-2>&nbsp;...<tt>&nbsp;&nbsp;&nbsp;</tt></font><tt> </tt>...
<br><tt><font size=-2>13:&nbsp;&nbsp;</font>&nbsp; //@ requires n >= 1;</tt>
<br><tt><font size=-2>14:&nbsp;&nbsp;</font>&nbsp; public int extractMin()
{</tt>
<br><font size=-2>&nbsp;...<tt>&nbsp;&nbsp;&nbsp;</tt></font><tt> </tt>...</blockquote>

<blockquote><b><font face="Arial,Helvetica">ESC/Java output:</font></b>
<br><tt>Bag.java:13: Error: Fields mentioned in this modifier pragma must
be at least as accessible as the field/method being modified (perhaps try
spec_public)</tt>
<br><tt>&nbsp; //@ requires n >= 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>Caution: Turning off extended static checking due to type error(s)</tt>
<br><tt>1 caution</tt>
<br><tt>1 error</tt></blockquote>
If programmers using the <tt>Bag</tt> class are not supposed to know that
its implementation includes the field <tt>n</tt>, then it is unreasonable
to expect them to establish a precondition involving <tt>n</tt> before
calling <tt>extractMin</tt>.&nbsp; We can prevent ESC/Java from complaining
by declaring the field <tt>n</tt> to be <tt>spec_public</tt>:
<blockquote><tt><font size=-2>&nbsp;3:&nbsp;&nbsp;</font>&nbsp; /*@ spec_public
*/ int n;</tt></blockquote>
This will allow <tt>n</tt> to be mentioned in <tt>requires</tt> pragmas
of <tt>public</tt> routines, as well as in pragmas occurring in other packages
that import the <tt>Bag</tt> class.&nbsp; Of course, actual Java code in
other packages will not be able to read or write the <tt>n</tt> field directly
(as would be allowed if <tt>n</tt> were declared with a Java
<tt>public</tt>
modifier).
<p><b>Fine point</b>
<p>By declaring <tt>n</tt> with a <tt>spec_public</tt> pragma, the implementer
of the <tt>Bag</tt> class expresses a design decision that users of <tt>Bag</tt>
are supposed to know about the <tt>n</tt> field, even if their Java code
cannot access it directly.&nbsp; This design decision could cause problems
if implementer later decided to change the implementation to represent
a <tt>Bag</tt> using a data structure that did not include an explicit
count--for example, a linked list.&nbsp; See the first example
in <a href="#2.6.2  Examples using ghost variables">section 2.6.2</a> for
further discussion of this issue.
<h4>
<a NAME="2.5.1  readable_if pragma"></a>2.5.1&nbsp; <tt>readable_if</tt>
pragma</h4>
A <tt>readable_if</tt> pragma is a modifier pragma.&nbsp; It can occur
only as a modifier of a field declaration or of a local variable declaration.&nbsp;
It has the form
<blockquote><tt>readable_if <i>E</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>E</tt></i> is a boolean specification expression.
<p>The pragma causes ESC/Java to check that <i><tt>E</tt></i> is true just
before any read access of any of the variable(s) declared in the declaration.&nbsp;
The pragma thus expresses the programmer's intention that the variable
modified by the pragma has a meaningful value only when <i><tt>E</tt></i>
is true.
<p>The specification expression <i><tt>E</tt></i> is allowed to mention
<tt>this</tt>
if the pragma modifies an instance field declaration, or if the pragma
modifies a local variable declaration within an instance method or a constructor.&nbsp;
If the pragma modifies the declaration of an instance field <i><tt>f</tt></i>,
then for purposes of checking a read access <tt><i>O</i>.<i>f</i></tt>,
occurrences of <tt>this</tt> in <i><tt>E</tt></i> are taken to denote the
value of <i><tt>O</tt></i>.
<p><b>Fine points</b>
<p>If the pragma modifies a local variable declaration then the variables
declared by the declaration are not in scope in <i><tt>E</tt></i>, even
if the pragma occurs just before the final semi-colon instead of before
the type.
<blockquote><tt>class C {</tt>
<br><tt>&nbsp; boolean b;</tt>
<br><tt>&nbsp; void m() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean b /*@ readable_if b */;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // "b" in the pragma above means this.b, not
the local b</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // "b" in the pragma below means the local b</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* readable_if b */ int c;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; </tt>...
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
If the pragma modifies a field declaration, then all fields of the containing
class are in scope in <i><tt>E</tt></i>, even those that are declared in
textually later declarations.
<blockquote><tt>class C extends B {</tt>
<br><tt>&nbsp; /*@ readable_if b */ int a;</tt>
<br><tt>&nbsp; boolean b;</tt>
<br><tt>&nbsp; // "b" in the pragma means this.b, not ((B)this).b</tt>
<br><tt>&nbsp; </tt>...
<br><tt>}</tt></blockquote>
If the pragma modifies a field declaration, then the free variables of
<i><tt>E</tt></i>
must be spec-accessible wherever fields declared by the declaration are
accessible according to Java's access control rules [<i>JLS</i>, 6.6]
<blockquote><font size=-1>Remark:&nbsp; For the picky, a more precise name
for this pragma might be ``<tt>meaningful_only_if</tt>''.</font>
<p><font size=-1>Remark:&nbsp; Perhaps unfortunately, ESC/Java does not
provide a way to say when particular array elements are readable (meaningful).&nbsp;
This could be useful since one could then express, for example, ``<tt>a[i]</tt>
is meaningful only if <tt>0 &lt;= i &amp; i &lt; n</tt>'', which says that
only the first <tt>n</tt> elements of array <tt>a</tt> are in use.</font></blockquote>

<h4>
<a NAME="2.5.2  uninitialized pragma"></a>2.5.2&nbsp; <tt>uninitialized</tt>
pragma</h4>
An <tt>uninitialized</tt> pragma is a modifier pragma.&nbsp; An <tt>uninitialized</tt>
pragma can occur as a modifier only of a local variable declaration that
has an initializer.&nbsp; The pragma causes ESC/Java to check that no execution
path reads the variable without first performing an assignment (other than
the initializer) to the variable.
<p>The intended use of the <tt>uninitialized</tt> pragma is for situations
in which the conservative nature of Java's ``definite assignment'' rules
[<i>JLS</i>, 16] has forced the programmer to supply an irrelevant initial
value.
<h3>
<a NAME="2.6  Pragmas concerning ghost variables"></a>2.6&nbsp; Pragmas
concerning ghost variables</h3>
Unlike ESC/Modula-3 (see SRC Report 159, ``<a href="http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-159.html">Extended
static checking</a>'') ESC/Java does not support data abstraction.&nbsp;
But ESC/Java does provide a poor man's version of abstract variables, called
<i>ghost</i>
variables.&nbsp; We describe here the <tt>ghost</tt> pragma, which declares
ghost variables, and the <tt>set</tt> pragma, which modifies them, and
then give an example of their use.
<h4>
<a NAME="2.6.0  ghost pragma"></a>2.6.0&nbsp; <tt>ghost</tt> pragma</h4>
A <tt>ghost</tt> pragma is a declaration pragma.&nbsp; It is allowed where
the declaration of a class or interface member is allowed.&nbsp; It has
the syntax
<blockquote><tt>ghost <i>M</i> <i>T</i> <i>VD</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>T</tt></i> is a specification type (see <a href="#3.0  Specification types">section
3.0</a>), <i><tt>VD</tt></i> is a Java <i>VariableDeclarators</i> [<i>JLS</i>19.8.2],
and <i><tt>M</tt></i> is a sequence of modifiers.&nbsp; (In other words,
the pragma is like an ordinary Java variable declaration preceded by the
word <tt>ghost</tt>.)&nbsp; In the current ESC/Java, <i><tt>M</tt></i>
must include the modifier <tt>public</tt>, and <i><tt>VD</tt></i> can declare
only one identifier.&nbsp; The only other modifier allowed in <i><tt>M</tt></i>
is <tt>static</tt>.&nbsp; No initializers are allowed in <i><tt>VD</tt></i>.
<p>The pragma is like the Java declaration
<blockquote><tt><i>M</i> <i>T</i> <i>VD</i> ;</tt><i><sub>opt</sub></i></blockquote>
except that it is visible only to ESC/Java, not to the compiler.&nbsp;
The variables declared by a <tt>ghost</tt> pragma are called ghost variables.
<p><b>Fine points</b>
<p>No field declared in <i><tt>VD</tt></i> may have the same name as a
field (including a ghost field or a field declared in a supertype) already
declared for the type in whose declaration the pragma occurs.
<p>The current ESC/Java does not implement local ghost variables.
<p>A ghost field declared in an interface <i><tt>I</tt></i> is multiply
inherited by classes that implement <i><tt>I</tt></i> and interfaces that
extend <i><tt>I</tt></i>.&nbsp; (If a ghost variable <i><tt>f</tt></i>
is declared in an interface <i><tt>I</tt></i>, and <i><tt>I</tt></i> is
extended by interfaces <i><tt>J</tt></i> and <i><tt>K</tt></i>, and a class
<i><tt>C</tt></i>
implements <i><tt>I</tt></i>, <i><tt>J</tt></i>, and
<i><tt>K</tt></i>,
and if <i><tt>x</tt></i> is a variable of type <i><tt>C</tt></i>, then
the expressions <tt>((<i>I</i>)<i>x</i>).<i>f</i></tt>, <tt>((<i>J</i>)<i>x</i>).<i>f</i></tt>,
<tt>((<i>K</i>)<i>x</i>).<i>f</i></tt>,
and <tt><i>x</i>.<i>f</i></tt> all denote the same ghost field.&nbsp; That
is, <i><tt>C</tt></i> gets only one copy of <i><tt>f</tt></i>.)
<p>For information about resolution of name conflicts involving ghost variables,
see <a href="#3.3  Scoping, name resolution, and access control in specificat">section
3.3</a>.
<p>In some cases, it is useful to declare a ghost variable with a modifier
pragma, such as <tt>non_null</tt>.&nbsp; In this case, the modifier pragma
must occur within a nested pragma-containing comment, for example:
<blockquote><tt>//@ ghost public /*@ non_null */ T t;</tt></blockquote>
More precisely, within a <tt>ghost</tt> pragma
<blockquote><tt><i>M</i> <i>T</i> <i>VD</i> ;</tt><i><sub>opt</sub></i></blockquote>
an inner pragma-containing comment containing modifier pragmas is allowed
either as part of <i><tt>M</tt></i> or just after <i><tt>VD</tt></i>.&nbsp;
The only modifier pragmas that can usefully modify a ghost variable are
<tt>non_null</tt>,
<tt>monitored</tt>,
and <tt>monitored_by</tt> (the current ESC/Java may accept others, but
if it does they will have no effect on the checking performed).&nbsp; In
addition, these pragmas are allowed only in the case where they would be
allowed for a normal variable according to the table in <a href="#2.0.1  There are four syntactic categories of pragmas.">section
2.0.1</a>.&nbsp; For example, a <tt>static</tt> ghost variable cannot be
declared with the pragma <tt>monitored</tt>, or with the pragma <tt>monitored_by
<i>E</i></tt>
where the expression <i><tt>E</tt></i> mentions <tt>this</tt>.&nbsp; ESC/Java
checks <tt>monitored</tt> (<a href="#2.7.1  monitored pragma">section 2.7.1)</a>
and <tt>monitored_by</tt> (<a href="#2.7.0  monitored_by pragma">section
2.7.0)</a> pragmas for a ghost variable <i><tt>g</tt></i> only where <i><tt>g</tt></i>
is assigned to by a <tt>set</tt> pragma (<a href="#2.6.1  set pragma">section
2.6.1</a>), not at other places where <i><tt>g</tt></i> is used in pragmas.
<h4>
<a NAME="2.6.1  set pragma"></a>2.6.1&nbsp; <tt>set</tt> pragma</h4>
A <tt>set</tt> pragma is a statement pragma.&nbsp; It has the form
<blockquote><tt>set <i>D</i> = <i>E</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>D</tt></i> is a ghost designator and <i><tt>E</tt></i> is
a specification expression containing no quantifiers or labels.&nbsp; The
pragma has the same semantics as the Java assignment statement <tt><i>D</i>=
<i>E</i></tt>
would have if <i><tt>D</tt></i> and <i><tt>E</tt></i> were in Java.
<p>A ghost designator can have one of the following forms:
<blockquote><tt><i>O</i>.<i>f</i></tt> , where <i><tt>O</tt></i> is specification
expression of an object type <i><tt>T</tt></i> and <i><tt>f</tt></i> is
a ghost field of <i><tt>T</tt></i>.
<p><i><tt>f</tt></i> , where <i><tt>f</tt></i> is a static ghost field
or <tt>this.<i>f</i></tt> is a legal ghost designator of the preceding
form.</blockquote>
<b>Fine point</b>
<p>If the field <i><tt>f</tt></i> assigned to by a <tt>set</tt> pragma
is declared with a <tt>non_null</tt>, <tt>monitored</tt>, or <tt>monitored_by</tt>
pragma, then ESC/Java will perform the usual checking implied by the modifier
pragma, generating warnings in case the value being assigned may be <tt>null</tt>,
or in case the specified lock may not be held.&nbsp; This is the only circumstance
in which the current ESC/Java generates warning of possible run-time errors
in the evaluation of pragmas.
<h4>
<a NAME="2.6.2  Examples using ghost variables"></a>2.6.2&nbsp; Examples
using ghost variables</h4>
<b>Example:&nbsp; specifying <tt>Bag</tt> without revealing its implementation</b>
<p>As pointed out in <a href="#2.5.0  spec_public pragma">section 2.5.0</a>,
there is a scoping problem with the <tt>Bag</tt> example from <a href="#0  An illustrative example of using ESC/Java">section
0</a>:&nbsp; In a realistic situation, the implementer of the <tt>Bag</tt>
class may want to make <tt>public</tt> the routines of the class, but not
the fields.&nbsp; How then are clients of the <tt>public</tt> method <tt>extractMin</tt>
to discharge the precondition <tt>requires n >= 1</tt>, which mentions
the non-<tt>public</tt> field <tt>n</tt>?
<p>In section 2.5.0, we showed how to address the problem by declaring
<tt>n</tt>
with a <tt>spec_public</tt> pragma.&nbsp; But what if the implementer of
the <tt>Bag</tt> class wanted to leave open the possibility of switching
to a different implementation (say, a linked list) in which the representation
of a <tt>Bag</tt> did not include an explicit count of the elements?
<p>To resolve this annotation question, we must first make a design decision
about the actual Java code:&nbsp; How, in fact, <i>are</i> the clients
of the <tt>Bag</tt> class supposed to avoid ever calling the <tt>extractMin</tt>
method of an empty <tt>Bag</tt>?
<p>One approach--the one that we will illustrate here--would be for the
implementer of the <tt>Bag</tt> class to provide a method <tt>isEmpty</tt>
that clients could use to test a <tt>Bag</tt> for emptiness before calling
its <tt>extractMin</tt> method.&nbsp; To specify the semantics of the <tt>Bag</tt>
class, we would use a boolean ghost field <tt>empty</tt>, that would be
<tt>true</tt>
precisely for those <tt>Bag</tt>'s that contain no elements.&nbsp; Here's
how that annotated implementation of <tt>Bag</tt> might look like under
this approach:
<blockquote><tt><font size=-2>&nbsp;1:&nbsp;</font> class Bag {</tt>
<br><tt><font size=-2>&nbsp;2:&nbsp;&nbsp;&nbsp;</font>&nbsp; /*@ non_null
*/ int[] a;</tt>
<br><tt><font size=-2>&nbsp;3:&nbsp;&nbsp;&nbsp;</font>&nbsp; int n;</tt>
<br><tt><font size=-2>&nbsp;4:&nbsp;&nbsp;&nbsp;</font>&nbsp; //@ invariant
0 &lt;= n &amp;&amp; n &lt;= a.length;</tt>
<br><tt><font size=-2>&nbsp;5:&nbsp;&nbsp;&nbsp;</font>&nbsp; //@ ghost
public boolean empty;</tt>
<br><tt><font size=-2>&nbsp;6:&nbsp;&nbsp;&nbsp;</font>&nbsp; //@ invariant
empty == (n == 0);</tt>
<br><tt><font size=-2>&nbsp;7:</font></tt>
<br><tt><font size=-2>&nbsp;8:&nbsp;&nbsp;&nbsp;</font>&nbsp; //@ requires
input != null;</tt>
<br><tt><font size=-2>&nbsp;9:&nbsp;&nbsp;&nbsp;</font>&nbsp; //@ ensures
this.empty == (input.length == 0);</tt>
<br><tt><font size=-2>10:&nbsp;&nbsp;&nbsp;</font>&nbsp; public Bag(int[]
input) {</tt>
<br><tt><font size=-2>11:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; n
= input.length;</tt>
<br><tt><font size=-2>12:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; a
= new int[n];</tt>
<br><tt><font size=-2>13:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; System.arraycopy(input,
0, a, 0, n);</tt>
<br><tt><font size=-2>14:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; //@
set empty = n == 0;</tt>
<br><tt><font size=-2>15:&nbsp;&nbsp;&nbsp;</font>&nbsp; }</tt>
<br><tt><font size=-2>16:</font></tt>
<br><tt><font size=-2>17:&nbsp;&nbsp;&nbsp;</font>&nbsp; //@ ensures \result
== empty;</tt>
<br><tt><font size=-2>18:&nbsp;&nbsp;&nbsp;</font>&nbsp; public boolean
isEmpty() {</tt>
<br><tt><font size=-2>19:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; return
n == 0;</tt>
<br><tt><font size=-2>20:&nbsp;&nbsp;&nbsp;</font>&nbsp; }</tt>
<br><tt><font size=-2>21:</font></tt>
<br><tt><font size=-2>22:&nbsp;&nbsp;&nbsp;</font>&nbsp; //@ requires !empty;</tt>
<br><tt><font size=-2>23:&nbsp;&nbsp;&nbsp;</font>&nbsp; //@ modifies empty;</tt>
<br><tt><font size=-2>24:&nbsp;&nbsp;&nbsp;</font>&nbsp; //@ modifies n,
a[*];</tt>
<br><tt><font size=-2>25:&nbsp;&nbsp;&nbsp;</font>&nbsp; public int extractMin()
{</tt>
<br><tt><font size=-2>26:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; int
m = Integer.MAX_VALUE;</tt>
<br><tt><font size=-2>27:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; int
mindex = 0;</tt>
<br><tt><font size=-2>28:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; for
(int i = 0; i &lt; n; i++) {</tt>
<br><tt><font size=-2>29:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (a[i] &lt; m) {</tt>
<br><tt><font size=-2>30:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mindex = i;</tt>
<br><tt><font size=-2>31:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m = a[i];</tt>
<br><tt><font size=-2>32:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt><font size=-2>33:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt><font size=-2>34:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; n--;</tt>
<br><tt><font size=-2>35:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; //@
set empty = n == 0;</tt>
<br><tt><font size=-2>36:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; //@
assert empty == (n == 0);</tt>
<br><tt><font size=-2>37:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; a[mindex]
= a[n];</tt>
<br><tt><font size=-2>38:&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; return
m;</tt>
<br><tt><font size=-2>39:&nbsp;&nbsp;&nbsp;</font>&nbsp; }</tt>
<br><tt><font size=-2>40:&nbsp;&nbsp; </font>}</tt></blockquote>
The precondition for <tt>extractMin</tt> on line 22 specifies that it is
incorrect to invoke the <tt>extractMin</tt> method of an empty <tt>Bag</tt>.&nbsp;
The postcondition for <tt>isEmpty</tt> on line 17 allows clients (and ESC/Java)
to determine that a code fragment like
<blockquote><tt>if (!x.isEmpty()) i = x.extractMin();</tt></blockquote>
will never violate the precondition for <tt>extractMin</tt>.&nbsp; The
invariant on line 6 relates the ghost field <tt>empty</tt> to the actual
field <tt>n</tt> in the implementation of a <tt>Bag</tt> and is of interest
only to the implementer of the <tt>Bag</tt> class and not to clients.&nbsp;
ESC/Java uses this invariant to verify that the implementation of <tt>isEmpty</tt>
satisfies its postcondition, and to verify that the implementation of <tt>extractMin</tt>,
when called in accordance with its precondition, will not attempt to access
<tt>a[-1]</tt>
in line 37.&nbsp; The <tt>set</tt> pragmas on lines 14 and 35 guarantee
that the invariant on line 6 is established by the <tt>Bag</tt> constructor
and preserved by the <tt>extractMin</tt> method.
<p><b>Example:&nbsp; specifying a generic queue</b>
<p>Consider a class that implements queues of <tt>Object</tt>'s.&nbsp;
There is a constructor that creates an empty queue, and there are instance
methods for enqueueing and dequeueing elements and for testing whether
a queue is empty:
<blockquote><tt>public class Queue {</tt>
<br><tt>&nbsp; </tt>...
<br><tt>&nbsp; public class Queue() {</tt>...<tt>}</tt>
<br><tt>&nbsp; public enqueue(Object e) {</tt>...<tt>}</tt>
<br><tt>&nbsp; public boolean isEmpty() {</tt>...<tt>}</tt>
<br><tt>&nbsp; public Object dequeue() throws {</tt>...<tt>}</tt>
<br><tt>}</tt></blockquote>
In the absence of any annotations, a number of problems come up when checking
clients of the <tt>Queue</tt> class.
<p>First, there is no check against calling <tt>dequeue</tt> on an empty
queue.
<p>Second, a user may wish to have a queue whose elements are all of some
type <i><tt>T</tt></i> (a proper subtype of <tt>Object</tt>).&nbsp; Since
the result type of <tt>dequeue</tt> is <tt>Object</tt>, the user will frequently
have to cast the result of dequeue to a <tt>T</tt>.
<blockquote><tt>&nbsp; T t = </tt>...<tt>, u;</tt>
<br><tt>&nbsp; Queue q = new Queue();</tt>
<br><tt>&nbsp; </tt>...
<br><tt>&nbsp; q.enqueue(t);</tt>
<br><tt>&nbsp; </tt>...
<br><tt>&nbsp; u = (T)q.dequeue();</tt></blockquote>
Given the code fragment above, ESC/Java has no way to know that the cast
will succeed.
<p>Finally, it is common for queues (and other such ``container'' objects)
to contain only non-null elements.&nbsp; When a queue is intended to contain
only non-null elements it would be nice to have ESC/Java check that only
non-null elements are enqueued, and on the other hand not issue spurious
warnings about potential null dereferences on dequeued objects.
<p>Here is a <tt>.spec</tt> file (see <a href="#5.1.2  Specification (.spec) files">section
5.1.2</a>) for the <tt>Queue</tt> class with annotations addressing the
issues described above.
<blockquote><tt>public class Queue {</tt>
<p><tt>&nbsp; //@ ghost public int size;</tt>
<br><tt>&nbsp; //@ invariant size >= 0;</tt>
<br><tt>&nbsp; //@ ghost public \TYPE elementType;</tt>
<br><tt>&nbsp; //@ ghost public boolean canHoldNull;</tt>
<p><tt>&nbsp; //@ ensures elementType == \type(Object);</tt>
<br><tt>&nbsp; //@ ensures canHoldNull;</tt>
<br><tt>&nbsp; //@ ensures size == 0;</tt>
<br><tt>&nbsp; public Queue();</tt>
<p><tt>&nbsp; /*@ requires \typeof(e) &lt;: elementType |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(e == null &amp; canHoldNull); */</tt>
<br><tt>&nbsp; //@ modifies size;</tt>
<br><tt>&nbsp; //@ ensures size == \old(size) + 1;</tt>
<br><tt>&nbsp; public void enqueue(Object e);</tt>
<p><tt>&nbsp; //@ ensures \result == (size == 0);</tt>
<br><tt>&nbsp; public boolean isEmpty();</tt>
<p><tt>&nbsp; //@ requires size >= 1;</tt>
<br><tt>&nbsp; //@ modifies size;</tt>
<br><tt>&nbsp; /*@ ensures \typeof(\result) &lt;: elementType |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(\result == null &amp; canHoldNull);</tt>
<br><tt>&nbsp; */</tt>
<br><tt>&nbsp; //@ ensures size == \old(size) - 1;</tt>
<br><tt>&nbsp; public Object dequeue();</tt>
<br><tt>}</tt></blockquote>
(The specification expression constructs <tt>\TYPE</tt>, <tt>\type</tt>,
<tt>\typeof</tt>,
and <tt>&lt;: </tt>are explained in sections <a href="#3.0  Specification types">3.0</a>,
<a href="#3.2.0  \type">3.2.0</a>,
<a href="#3.2.1  \typeof">3.2.1</a>,
and
<a href="#3.2.3   Subtype:  <:">3.2.3</a>, respectively.)&nbsp; Given
the specification above, the user can express the intention to use a queue
<tt>q</tt>
to hold only non-null elements of type <tt>T</tt> by writing
<blockquote><tt>Queue q = new Queue();</tt>
<br><tt>//@ set q.elementType = \type(T);</tt>
<br><tt>//@ set q.canHoldNull = false;</tt></blockquote>
ESC/Java will then warn of a possible precondition violation on any call
<tt>q.enqueue(<i>E</i>)</tt>
where <i><tt>E</tt></i> may not be an instance of <tt>T</tt>.&nbsp; On
the other hand it will not issue a (spurious) warning of possible cast
failure on <tt>(T)q.dequeue()</tt>.&nbsp; Also ESC/Java will warn of a
possible precondition failure on <tt>q.dequeue()</tt> if it cannot establish,
based on the number of elements enqueued and dequeued done since the allocation
of <tt>q</tt> or the most recent call to <tt>q.isEmpty</tt>, that <tt>q</tt>
is nonempty (<tt>q.size >= 1</tt>) at the point of the call.
<p>For more examples of the use ghost variables in specifying container
classes, read the files <tt>Dictionary.spec</tt>, <tt>Enumerator.spec</tt>
and <tt>Vector.spec</tt> in <i>escjavaRoot</i><tt>/lib/specs/java/util</tt>
(see <a href="#Appendix B:  Installing and using ESC/Java at your site">appendix
B</a>).
<h3>
<a NAME="2.7  Pragmas for specifying synchronization"></a>2.7&nbsp; Pragmas
for specifying synchronization</h3>
ESC/Java provides support for checking that multi-threaded programs respect
a locking discipline that prevents race conditions and simple deadlocks.
<p>A race condition is a situation in which two threads access a variable
simultaneously and the accesses are not both read accesses.&nbsp; To prevent
race conditions, the locking discipline requires that every shared variable
is <i>monitored</i> by one or more locks.&nbsp; If a variable is monitored
by a lock, a thread is not allowed to access the variable unless it holds
the lock (and this discipline is enforced by ESC/Java).
<p>A deadlock occurs if there is a cycle of threads, each holding a lock
that some other thread in the cycle is waiting to acquire.&nbsp; To prevent
deadlocks, the locking discipline requires that the programmer declare
a partial order in which locks are to be acquired.&nbsp; ESC/Java will
then check that each thread does in fact acquire locks in the given order.&nbsp;
But the checker trusts the programmer that the declared locking order is
actually a partial order.
<h4>
<a NAME="2.7.0  monitored_by pragma"></a>2.7.0&nbsp; <tt>monitored_by</tt>
pragma</h4>
A <tt>monitored_by</tt> pragma is a modifier pragma.&nbsp; It can occur
only as a modifier of a field declaration.&nbsp; It has the form
<blockquote><tt>monitored_by <i>L</i> ;</tt><i><sub>opt</sub></i></blockquote>
where <i><tt>L</tt></i> is a nonempty, comma-separated list of specification
expressions.
<p>The pragma declares that the modified field is a shared variable monitored
by the locks in <i><tt>L</tt></i>.&nbsp; That is, it causes ESC/Java to
check that (1) the field is never read except by a thread holding at least
one non-null lock in <i><tt>L</tt></i> and (2) that the field is never
written except when at least one lock in <i><tt>L</tt></i> is non-null
and the writing thread holds all non-null locks in <i><tt>L</tt></i>.&nbsp;
(See the first fine points below for an exception the preceding statement.)
<p>If the field declaration modified by the pragma declares an instance
field <i><tt>f</tt></i>, then the expressions in <i><tt>L</tt></i> may
mention <tt>this</tt> (explicitly or implicitly).&nbsp; When ESC/Java checks
an access to <i><tt>O.f</tt></i>, occurrences of <tt>this</tt> within <i><tt>L</tt></i>
are considered to denote the value of <i><tt>O</tt></i>.
<p><b>Fine points</b>
<p>When checking a constructor body ESC/Java does not require that any
lock be held in order to accesses a field of <tt>this</tt>, even if the
field is declared with at <tt>monitored_by</tt> or <tt>monitored</tt> (<a href="#2.7.1  monitored pragma">section
2.7.1</a>) pragma.&nbsp; (In some cases, this can result in unsoundness;
see <a href="#C.0.8  Constructor leaking">section C.0.8</a>.)
<p>All fields of the class containing the pragma are in scope in <i><tt>E</tt></i>,
even those that are declared in textually later declarations.
<blockquote><tt>class C extends B {</tt>
<br><tt>&nbsp; /*@ monitored_by g */ S f;</tt>
<br><tt>&nbsp; T g;</tt>
<br><tt>&nbsp; // "g" in the pragma means this.g, not ((B)this).g</tt>
<br><tt>&nbsp; </tt>...
<br><tt>}</tt></blockquote>
The variables mentioned in <i><tt>L</tt></i> must be spec-accessible (<a href="#3.3  Scoping, name resolution, and access control in specificat">section
3.3</a>) anywhere the field itself is accessible [<i>JLS</i>, 6.6].&nbsp;
For example, a <tt>public</tt> field may not be monitored by a <tt>private</tt>
lock (unless the lock is declared <tt>spec_public</tt>, see <a href="#2.5.0  spec_public pragma">section
2.5.0</a>).
<p>A field declaration may be modified by multiple <tt>monitored_by</tt>
pragmas, in which case the effect is as if there were a single <tt>monitored_by</tt>
pragma listing all the locks mentioned in any of the actual <tt>monitored_by</tt>
pragmas.&nbsp; (<b>Bug/limitation:</b>&nbsp; When ESC/Java issues a <tt>Race</tt>
warning for such a field, it will mention only one of the <tt>monitored_by</tt>
pragmas, and possibly not the right one, as the annotation associated with
the warning.)
<h4>
<a NAME="2.7.1  monitored pragma"></a>2.7.1&nbsp; <tt>monitored</tt> pragma</h4>
A <tt>monitored</tt> pragma is a modifier pragma.&nbsp; It can occur only
as a modifier of an instance variable declaration.&nbsp; It has the form
<blockquote><tt>monitored</tt></blockquote>
and is semantically equivalent to
<blockquote><tt>monitored_by this;</tt></blockquote>

<h4>
<a NAME="2.7.2  Examples illustrating race and deadlock checking"></a>2.7.2&nbsp;
Examples illustrating race and deadlock checking</h4>
Annotation of programs for race and deadlock checking typically requires
use not only of <tt>monitored</tt> and/or <tt>monitored_by</tt> pragmas
but of other pragmas as well, most commonly <tt>requires</tt> pragmas (<a href="#2.3.0  requires pragma">section
2.3.0</a>) and <tt>axiom</tt> pragmas (<a href="#2.4.2  axiom pragma">section
2.4.2</a>) involving the locking order <tt>&lt;</tt> (<a href="#3.2.7  Lock order:  < and <=">section
3.2.7</a>) and the lock set <tt>\lockset</tt> (<a href="#3.2.5  \lockset">section
3.2.5</a>).&nbsp; Rather than leave it to the reader to assemble the big
picture from fragments of information scattered over many sections of this
manual, we present here a few examples to show how the pieces fit together.
<p>In specification expressions the special ESC/Java identifier <tt>\lockset</tt>
refers to a special variable, called the lock set, denoting the set of
all objects held as locks by the current thread.&nbsp; For testing membership
of locks in the lock set, we overload the array subscripting notation,
so that <tt>\lockset[X]</tt> is true when object <tt>X</tt> is in the lock
set
<tt>\lockset</tt>.
<p>Thus, given the instance field declarations
<blockquote><tt>T f;</tt>
<br><tt>U g;</tt>
<br><tt>/*@ monitored_by f, g; */ V h;</tt></blockquote>
the code fragment
<blockquote><tt>x.h = y.h</tt></blockquote>
is treated roughly like
<blockquote><tt>/*@ assert y != null; */&nbsp;&nbsp; // Check for null
dereference</tt>
<br><tt>/*@ assert (y.f != null &amp;&amp; \lockset[y.f]) |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (y.g
!= null &amp;&amp; \lockset[y.g]); */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
Check for race (<a href="#4.17  Race warning">section 4.17</a>) on read</tt>
<br><tt>/*@ assert x != null; */&nbsp;&nbsp; // Check for null dereference</tt>
<br><tt>/*@ assert (x.f != null | x.g != null) &amp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (x.f
!= null ==> \lockset[x.f]) &amp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (x.g
!= null ==> \lockset[x.g]); */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
Check for race on write</tt>
<br><tt>x.h = y.h;</tt></blockquote>
The necessary conditions to establish such locking assertions can be established
explicitly, for example by a <tt>requires</tt> pragma as in
<blockquote><tt>//@ requires f != null &amp;&amp; \lockset[f];</tt>
<br><tt>void m() {</tt>
<br><tt>&nbsp; </tt>...<tt> h </tt>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>//
read access produces no Race warning</tt>
<br><tt>}</tt></blockquote>
Also, a <tt>synchronized</tt> routine body and a <tt>synchronized</tt>
statement always begin by adding a lock to the lock set.
<blockquote><tt>class C {</tt>
<p><tt>&nbsp; monitored T t;</tt>
<p><tt>&nbsp; synchronized void m() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; T x = t; /* no race because starting a synchronized</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
method establishes \lockset[this] */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; </tt>...
<br><tt>&nbsp; }</tt>
<p><tt>&nbsp; void n() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; synchronized (this) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T x = t;&nbsp; // no race</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>...
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
The preceding examples deal only with race detection.&nbsp; We now turn
to the issue of deadlock detection.
<p>ESC/Java supports a synchronization discipline in which deadlocks are
avoided by imposing a partial ordering on locks and acquiring locks only
in increasing order.&nbsp; The arithmetic ordering relations <tt>&lt;</tt>
and <tt>&lt;=</tt> are overloaded to compare objects in the locking order.&nbsp;
The special function <tt>\max</tt> yields the maximum lock in a lock set.
<p>Without some help in the form of user-supplied pragmas, it is never
possible for ESC/Java to prove the absence of deadlock in a program that
ever acquires a lock.&nbsp; Deadlock checking is therefore disabled by
default.&nbsp; When deadlock checking is enabled (by use of the command-line
option
<tt>-warn Deadlock</tt>), ESC/Java checks <tt>synchronized</tt>
statements and <tt>synchronized</tt> methods and issues warnings if they
might acquire locks out of order.
<p>A <tt>synchronized</tt> statement
<blockquote><tt>synchronized (E) {</tt>...<tt>}</tt></blockquote>
is treated roughly like
<blockquote><tt>Object e = E; // where e is a variable name not already
used</tt>
<br><tt>//@ assert e != null;&nbsp; // but with Null warning on failure</tt>
<br><tt>//@ assert \lockset[e] | \max[\lockset] &lt; e;&nbsp; // but with
Deadlock warning</tt>
<br><i>Insert </i><tt>e</tt><i> into </i><tt>\lockset;</tt>
<br><tt>try</tt>
<br><tt>&nbsp; {</tt>...<tt>}</tt>
<br><tt>finally</tt>
<br><tt>&nbsp; </tt><i>Restore former value of</i> <tt>\lockset;</tt></blockquote>
The disjunct <tt>\lockset[e]</tt> in the test for potential deadlocks reflects
the fact that Java locks are ``reentrant'',&nbsp; that is, that a thread
that already holds a lock may acquire the lock again without deadlocking
[<i>JLS</i>, 17.5].
<p>When checking a <tt>synchronized</tt> method declaration, ESC/Java acts
as if the body of the method were wrapped in <tt>synchronized</tt> statement,
as described in [<i>JLS</i>, 8.4.3.5].&nbsp; That is, ESC/Java checks an
instance method
<blockquote><tt>synchronized T m(<i>parameters</i>) {<i>body</i>}</tt></blockquote>
as if it had been written
<blockquote><tt>T m(<i>parameters</i>) {synchronized (this) {<i>body</i>}}</tt></blockquote>
and ESC/Java checks a <tt>static</tt> method
<blockquote><tt>static synchronized T m(<i>parameters</i>) {<i>body</i>}</tt></blockquote>
in a class <tt>C</tt> as if it had been written
<blockquote><tt>static T m(<i>parameters</i>) {synchronized (C.class) {<i>body</i>}}</tt></blockquote>
When a routine that already holds a lock acquires another one, ESC/Java
needs some way of knowing that the first lock precedes the second in the
lock order.&nbsp; One way to give ESC the needed information is by supplying
an <tt>axiom</tt> pragma (see <a href="#2.4.2  axiom pragma">section 2.4.2</a>)
about the lock order, as in the following example:
<blockquote><tt>public class Tree {</tt>
<br><tt>&nbsp; public /*@ monitored */ Tree left, right;</tt>
<br><tt>&nbsp; public /*@ monitored non_null */ Thing contents;</tt>
<p><tt>&nbsp; //@ axiom (\forall Tree t; t.left != null ==> t &lt; t.left);</tt>
<br><tt>&nbsp; //@ axiom (\forall Tree t; t.right != null ==> t &lt; t.right);</tt>
<p><tt>&nbsp; Tree(/*@ non_null */ Thing c) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; contents = c;</tt>
<br><tt>&nbsp; }</tt>
<p><tt>&nbsp; //@ requires \max(\lockset) &lt;= this;</tt>
<br><tt>&nbsp; public synchronized void visit() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; contents.mungle();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if (left != null) left.visit();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if (right != null) right.visit();</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
<b>Fine points</b>
<p>Note that the axioms above are inconsistent if a (so-called) <tt>Tree</tt>
can in fact be cyclic.&nbsp; Note also that inconsistency or incompleteness
can arise from the possible mutation of variables mentioned in the axioms,
namely the fields <tt>left</tt> and
<tt>right</tt>.&nbsp; For example,
given the axioms above, ESC/Java will generate a spurious
<tt>Deadlock</tt>
warning for the following method:
<blockquote><tt>&nbsp; //@ requires \max(\lockset) &lt;= this;</tt>
<br><tt>&nbsp; public synchronized void wiggleWoggle() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // Perform a rotation on this.right (but give
up and just</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // return if this.right or this.right.left is
null):</tt>
<br><tt>&nbsp;&nbsp;&nbsp; //</tt>
<br><tt>&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; this&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
this</tt>
<br><tt>&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/&nbsp; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // ...&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...&nbsp;&nbsp; v</tt>
<br><tt>&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;
-->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp; v&nbsp;&nbsp; y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
u&nbsp;&nbsp; x</tt>
<br><tt>&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/ \</tt>
<br><tt>&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; u&nbsp;&nbsp; w&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
w&nbsp;&nbsp; y</tt>
<br><tt>&nbsp;&nbsp;&nbsp; //</tt>
<br><tt>&nbsp;&nbsp;&nbsp; { Tree x = this.right;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (x == null) return;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized (x) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tree v = x.left;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (v == null) return;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized (v) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x.left =
v.right;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.right
= x;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.right
= v;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// line (a)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // Undo the rotation:</tt>
<br><tt>&nbsp;&nbsp;&nbsp; { Tree v = this.right;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized (v) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// line (b)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tree x = v.right;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (x != null) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// line (c)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized
(x) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // line (d)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
v.right = x.left;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
x.left = v;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
this.right = x;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// line (e)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt></blockquote>
The problem is that the axiom is assumed to apply at the start of the routine,
and thus to apply to the values of <tt>.left</tt> and <tt>.right</tt> at
the start of the routine.&nbsp; According to the lock order thus defined,
the lock acquired at the line <tt>(d)</tt> would precede that acquired
at <tt>(b)</tt>.&nbsp; [Despite these caveats, our experience with ESC
for Modula 3 suggests that axioms like the ones above will do the right
thing surprisingly often and rarely cause problems.]
<p>The preceding example also illustrates a possible source of unsoundness
in ESC/Java's treatment of race detection.&nbsp; If the lines marked <tt>(c)</tt>
and <tt>(e)</tt> are deleted, and if deadlock checking is left disabled,
then ESC/Java will accept line <tt>(d)</tt> without complaint, ignoring
the possibility that some other thread might have taken advantage of the
window between lines <tt>(a)</tt> and <tt>(b)</tt> to synchronize on ``<tt>v</tt>''
and set its <tt>.right</tt> field to <tt>null</tt>.
<hr WIDTH="100%">
<h2>
<a NAME="3  Specification expressions"></a>3&nbsp; Specification expressions</h2>
While specification expressions are generally similar to Java expressions,
there are a number of differences, described below.&nbsp; <a href="#3.0  Specification types">Section
3.0</a> describes a slight extension to the Java type system.&nbsp; <a href="#3.1  Restrictions">Section
3.1</a> describes notations allowed in Java expressions but forbidden in
specification expressions.&nbsp; <a href="#3.2  Additions">Section 3.2</a>
describes additional notations allowed only in specification expressions.
<a href="#3.3  Scoping, name resolution, and access control in specificat">Section
3.3</a> describes how the rules for scoping, name resolution and access
control in specification expressions differ from those in Java.
<p>Specification expressions are never actually evaluated when a Java program
is run, and ESC/Java will not produce specific warnings about specification
expressions whose evaluation (if they were evaluated) might dereference
<tt>null</tt>,
access arrays out of bounds, etc.&nbsp; Rather, the meanings of such expressions
(for example, <tt><i>E</i>.f</tt> where <i><tt>E</tt></i> , if it were
actually evaluated, would evaluate to <tt>null</tt>) are unspecified functions
of (the meanings of) their subexpressions.&nbsp; In most cases, attempts
to prove things about such unspecified values will fail, thus giving rise
to warnings of some sort, though alas not the clearest warnings that one
could hope for.&nbsp; For example, given the program fragment
<blockquote><tt>//@ assume \nonnullelements(a);</tt>
<br><tt>//@ assert a[j] != null;</tt></blockquote>
in a place where <tt>j</tt> might be negative, ESC/Java will produce an
<tt>Assert</tt>
warning (<a href="#4.2  Assert warning">section 4.2</a>) rather than an
<tt>IndexNegative</tt>
warning (<a href="#4.6  IndexNegative warning">section 4.6</a>).
<h3>
<a NAME="3.0  Specification types"></a>3.0&nbsp; Specification types</h3>
Like Java expressions, specification expressions have types (which we call
<i>specification
types</i>).&nbsp; A specification type is either a Java type, or one of
the special types <tt>\TYPE</tt> or <tt>\LockSet</tt> (or an array of special
types, for example <tt>\TYPE[][]</tt>). (In the current ESC/Java, the programmer
cannot mention <tt>\LockSet</tt> explicitly.)
<h3>
<a NAME="3.1  Restrictions"></a>3.1&nbsp; Restrictions</h3>
Specification expressions must be free of subexpressions that, in general,
may have side effects.&nbsp; In particular, specification expressions may
not contain any:
<ul>
<li>
assignment (<tt>=</tt>, <tt>+=</tt>, etc.),</li>

<li>
pre-increment, pre-decrement, post-increment, post-decrement (<tt>++</tt>
or <tt>--</tt>),</li>

<li>
array or object creation (<tt>new</tt>), or</li>

<li>
method invocation.</li>
</ul>
Method invocations are forbidden in specification expressions even when
the method is known to have no side effects.
<p>The next section describes additional constructs that are allowed in
specification expressions beyond those allowed in Java expressions.&nbsp;
Some of these constructs have restrictions on their use.&nbsp; We describe
these restrictions together with the descriptions of the constructs to
which they apply.
<h3>
<a NAME="3.2  Additions"></a>3.2&nbsp; Additions</h3>

<h4>
<a NAME="3.2.0  \type"></a>3.2.0&nbsp; <tt>\type</tt></h4>
An expression of the form <tt>\type(<i>T</i>)</tt> where <i><tt>T</tt></i>
is a specification type (see <a href="#3.0  Specification types">section
3.0</a>), is a specification expression of type <tt>\TYPE</tt>.&nbsp; It
denotes the type <i><tt>T</tt></i>.
<h4>
<a NAME="3.2.1  \typeof"></a>3.2.1&nbsp; <tt>\typeof</tt></h4>
A specification expression of the form <tt>\typeof(<i>E</i>)</tt> where
<i><tt>E</tt></i>
is a specification expression whose type is&nbsp; a reference type is a
specification expression of type <tt>\TYPE</tt>.&nbsp; It denotes the dynamic
type of the value of <i><tt>E</tt></i>.&nbsp; The value of
<tt>\typeof(<i>E</i>)</tt>
is unspecified when <i><tt>E</tt></i> evaluates to <tt>null</tt>.
<h4>
<a NAME="3.2.2  \elemtype"></a>3.2.2&nbsp; <tt>\elemtype</tt></h4>
An expression of the form <tt>\elemtype(<i>E</i>)</tt> where <i><tt>E</tt></i>
is a specification expression of type <tt>\TYPE</tt> is a specification
expression of type <tt>\TYPE</tt>.&nbsp; If <i><tt>E</tt></i> denotes an
array type <tt><i>T</i>[]</tt>, then <tt>\elemtype(<i>E</i>)</tt> denotes
<i><tt>T</tt></i>.&nbsp;
Otherwise the value of <tt>\elemtype(<i>E</i>)</tt> is unspecified.
<h4>
<a NAME="3.2.3   Subtype:  <:"></a>3.2.3&nbsp;&nbsp; Subtype:&nbsp; <tt>&lt;:</tt></h4>
An expression of the form <tt><i>S</i> &lt;: <i>T</i></tt> where <i><tt>S</tt></i>
and <i><tt>T</tt></i> are specification expressions of type <tt>\TYPE</tt>
is a specification expression of type <tt>boolean</tt>.&nbsp; It denotes
that <i><tt>S</tt></i> is a subtype of <i><tt>T</tt></i> (including the
case where <i><tt>S</tt></i> is equal to <i><tt>T</tt></i>).&nbsp; The
operator <tt>&lt;:</tt> has the same binding power as the relational operators
<tt>&lt;</tt>,
<tt>></tt>,
<tt>&lt;=</tt>,
and
<tt>>=</tt>.
<h4>
<a NAME="3.2.4  Examples involving \TYPE, \type, \typeof, \elemtype, and <:"></a>3.2.4&nbsp;
Examples involving <tt>\TYPE</tt>, <tt>\type</tt>, <tt>\typeof</tt>, <tt>\elemtype</tt>,
and <tt>&lt;:</tt></h4>
Suppose file <tt>T.java</tt> contains the following declaration
<blockquote><tt>class T {</tt>
<p><tt>&nbsp; //@ requires a != null &amp;&amp; 0 &lt;= i &amp; i &lt;
a.length;</tt>
<br><tt>&nbsp; static void storeObject(T[] a, int i, T x) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a[i] = x;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; </tt>...</blockquote>
When checking the body of the <tt>storeObject </tt>method, ESC/Java will
produce an <tt>ArrayStore</tt> warning (<a href="#4.1  ArrayStore warning">section
4.1</a>) for the assignment
<blockquote><tt>&nbsp;&nbsp;&nbsp; a[i] = x;</tt></blockquote>
The problem is that, so far as ESC/Java can tell, the actual type of <tt>a</tt>
at the time of the call might be <tt>S[]</tt>, where <tt>S</tt> is some
proper subtype of <tt>T</tt>, and <tt>x</tt> might not be of type <tt>S</tt>.&nbsp;
Consequently, the attempt to store <tt>x</tt> into <tt>a[i]</tt> might
give rise to an <tt>ArrayStoreException</tt> [<i>JLS</i>, 10.10, 15.25.1],
which ESC/Java treats as an error.
<p>The <tt>ArrayStoreException</tt> cannot arise in the method if the parameter
<tt>a</tt>
always has actual type exactly <tt>T[]</tt>.&nbsp; The programmer can express
this intention with the pragma
<blockquote><tt>&nbsp; //@ requires \elemtype(\typeof(a)) == \type(T);</tt></blockquote>
or, equivalently, with the pragma
<blockquote><tt>&nbsp; //@ requires \typeof(a) == \type(T[]);</tt></blockquote>
Note that
<blockquote><tt>&nbsp; //@ requires \typeof(a) == \type(T)[];</tt></blockquote>
would not be legal, since the form <tt><i>N</i>[]</tt> makes sense only
when <i><tt>N</tt></i> is a specification type, not a specification expression
of type <tt>\TYPE</tt>.
<p>A weaker, but still sufficient, precondition for avoiding the <tt>ArrayStoreException</tt>
would be to require that the array <tt>a</tt> merely have an actual element
type adequate to hold the value of <tt>x</tt>.&nbsp; This precondition
is expressed by the pragmas
<blockquote><tt>&nbsp; //@ requires x == null || \typeof(x) &lt;: \elemtype(\typeof(a));</tt></blockquote>
Note that the pragma
<blockquote><tt>&nbsp; //@ requires x == null || x instanceof \elemtype(\typeof(a));</tt></blockquote>
is not legal, since the right hand argument of <tt>instanceof</tt> must
be a type, not a specification expression of type <tt>\TYPE</tt>.
<h4>
<a NAME="3.2.5  \lockset"></a>3.2.5&nbsp; <tt>\lockset</tt></h4>
The special identifier <tt>\lockset</tt> is a specification expression
of type
<tt>\LockSet</tt>.&nbsp; It denotes the set of locks held by the
current thread.
<h4>
<a NAME="3.2.6  Membership in lock sets:  [ ]"></a>3.2.6&nbsp; Membership
in lock sets:&nbsp; <tt>[ ]</tt></h4>
An expression of the form <tt><i>S</i>[<i>L</i>]</tt> where <i><tt>S</tt></i>
is a specification expression of type <tt>\LockSet</tt> and <i><tt>L</tt></i>
is a specification expression of a reference type is a specification expression
of type <tt>boolean</tt>.&nbsp; It denotes that <i><tt>L</tt></i> is a
member of <i><tt>S</tt></i>.
<h4>
<a NAME="3.2.7  Lock order:  < and <="></a>3.2.7&nbsp; Lock order: <tt>&lt;</tt>
and <tt>&lt;=</tt></h4>
Within specification expressions, the relations <tt>&lt;</tt> and &lt;<tt>=</tt>
are extended to apply to locks as well as numbers.&nbsp; The order they
refer to is called the lock order.&nbsp; For some examples of use of the
lock order, see <a href="#2.7.2  Examples illustrating race and deadlock checking">section
2.7.2</a>.
<h4>
<a NAME="3.2.8  \max"></a>3.2.8&nbsp; <tt>\max</tt></h4>
An expression of the form <tt>\max(<i>S</i>)</tt> where <i><tt>S</tt></i>
is a specification expression of type <tt>\LockSet</tt> is a specification
expression of type <tt>Object</tt>.&nbsp; It denotes the maximum element
of <i><tt>S</tt></i> in the lock order.
<p>To insure that <tt>\max</tt> is always well defined, ESC/Java assumes
that lock sets are always nonempty and that their elements are always totally
ordered by the lock order <tt>&lt;</tt>.&nbsp; Since locks must be acquired
in increasing order, and since there is no way to write a program that
releases the fictitious maximum element of the lock set of a thread that
really holds no locks, the preceding assumptions are invariantly true if
they are true initially.
<h4>
<a NAME="3.2.9  Implication:  ==>"></a>3.2.9&nbsp; Implication: <tt>==></tt></h4>
An expression of the form <tt><i>E</i> ==> <i>F</i></tt> where <i><tt>E</tt></i>
and <i><tt>F</tt></i> are specification expressions of type <tt>boolean</tt>
is a specification expression of type <tt>boolean</tt>.&nbsp; It denotes
the condition that <i><tt>E</tt></i> implies <i><tt>F</tt></i>, that is,
<tt>(!(<i>E</i>))
| <i>F</i></tt>.&nbsp; The operator <tt>==></tt> has less binding power
than <tt>&amp;&amp;</tt> and <tt>||</tt>, but binds more strongly than
the ternary conditional operator <tt>? :t</tt>.&nbsp; (The binding precedence
of operators in Java is implicit in the grammar for expressions [<i>JLS</i>,
19.12].)
<h4>
<a NAME="3.2.10  \forall"></a>3.2.10&nbsp; <tt>\forall</tt></h4>
An expression of the form <tt>(\forall <i>T</i> <i>V</i>; <i>E</i>)</tt>
where <i><tt>T</tt></i> is a specification type (see <a href="#3.0  Specification types">section
3.0</a>), <i><tt>V</tt></i> is a nonempty comma-separated list of identifiers
(called <i>bound variables</i>), and <i><tt>E</tt></i> is a specification
expression of type <tt>boolean</tt> is a specification expression of type
<tt>boolean</tt>.&nbsp;
It denotes that <i><tt>E</tt></i> is true for all substitutions of values
of type <i><tt>T</tt></i> for the bound variables.&nbsp; If <i><tt>T</tt></i>
is a reference type, the quantification ranges only over allocated objects
that are instances of <i><tt>T</tt></i>.&nbsp; Note that this excludes
<tt>null</tt>.&nbsp;
If <i><tt>T</tt></i> is either of the types <tt>int</tt> or <tt>long</tt>,
then&nbsp; the quantification ranges over all mathematical integers, regardless
of whether they are in the ranges of possible values for Java variable
of those types.
<p><b>Fine points</b>
<p>Just as Java forbids declaration of an identifier as a local variable
within the scope of a parameter or local variable of the same name [<i>JLS</i>,
14.3.2], so ESC/Java forbids declaration of an identifier as a bound variable
within the scope of a parameter, local variable, or bound variable of the
same name.&nbsp; ESC/Java also forbids declaration of <tt>\lockset</tt>
or <tt>\result</tt> as a bound variable.&nbsp; The same restriction applies
to variables bound by <tt>\exists</tt> (<a href="#3.2.11  \exists">section
3.2.11</a>).
<p>If a specification expression <i><tt>E</tt> </i>has an application of
<tt>\forall</tt>
as a (not necessarily proper) subexpression, then <i><tt>E</tt></i> may
occur only in one of the following contexts:
<ul>
<li>
as an (entire) argument to one of the following operators:</li>

<ul>
<li>
the ESC/Java implication operator <tt>==></tt> (see <a href="#3.2.9  Implication:  ==>">section
3.2.9</a>)</li>

<li>
the Java conditional operators <tt>&amp;&amp;</tt> and <tt>|| </tt>[<i>JLS</i>,
15.22, 15.23]</li>

<li>
the Java logical operators <tt>&amp;</tt>, <tt>^</tt>, and <tt>|</tt> [<i>JLS</i>,
15.21.2]</li>

<li>
the Java boolean equality operators <tt>==</tt> and <tt>!=</tt> [<i>JLS</i>,
15.20.2]</li>

<li>
the Java logical complement operator <tt>!</tt> [<i>JLS</i>, 15.14.6]</li>
</ul>

<li>
as the (entire) body of</li>

<ul>
<li>
a parenthesized expression <tt>(<i>E</i>)</tt>,</li>

<li>
a quantified expression <tt>(\forall </tt>...<tt>; <i>E</i>)</tt> or <tt>(\exists
</tt>...<tt>;<i>E</i>)</tt>
(see section <a href="#3.2.11  \exists">3.2.11</a>), or</li>

<li>
a labeled expression <tt>(\lblpos n <i>E</i>)</tt> or <tt>(\lblneg n <i>E</i>)</tt>
(see <a href="#3.2.16  \lblneg and \lblpos">section 3.2.16</a>)</li>
</ul>

<li>
as a top-level boolean specification expression (that is, not properly
contained by another specification expression) in a pragma.</li>
</ul>
The same restriction applies to specification expressions containing applications
of <tt>\exists</tt> (<a href="#3.2.11  \exists">section 3.2.11</a>) or
of
<tt>\lblneg</tt> or <tt>\lblpos</tt> (<a href="#3.2.16  \lblneg and \lblpos">section
3.2.16</a>).&nbsp; In particular, a quantified or labeled expression may
not occur in an argument to the ternary conditional operator <tt>? :</tt>
and this restriction cannot be evaded by use of the <tt>(boolean)</tt>
cast operator.&nbsp; For example, specification expressions of the form
<blockquote><tt>((boolean)(\exists</tt> ...<tt>)) ? </tt>...<tt> : </tt>...</blockquote>
are not allowed.&nbsp; A consequence of these restrictions is that all
legal specification expressions containing quantified or labeled subexpressions
are of type <tt>boolean</tt>.
<p>Note that the preceding rule forbids quantified expressions (and labeled
expressions) within arguments to <tt>\old</tt>.&nbsp; [Future versions
of ESC/Java may liberalize this restriction, with quantifications on reference
types inside <tt>\old</tt> ranging over objects allocated in the pre-state.]
<h4>
<a NAME="3.2.11  \exists"></a>3.2.11&nbsp; <tt>\exists</tt></h4>
An expression of the form <tt>(\exists <i>T</i> <i>V</i>; <i>E</i>)</tt>
where <i><tt>T</tt></i> is a specification type (see <a href="#3.0  Specification types">section
3.0</a>), <i><tt>V</tt></i> is a nonempty comma-separated list of identifiers
(called <i>bound variables</i>), and <i><tt>E</tt></i> is a specification
expression of type <tt>boolean</tt> is a specification expression of type
<tt>boolean</tt>.&nbsp;
It denotes that <i><tt>E</tt></i> is true for some substitution of values
of type <i><tt>T</tt></i> for the bound variables.&nbsp; If <i><tt>T</tt></i>
is a reference type, the quantification ranges only over allocated objects
that are instances of <i><tt>T</tt></i>.
<p><b>Fine points</b>
<p>See <a href="#3.2.10  \forall">section 3.2.10</a> for restrictions on
bound variable names and restrictions on places where quantified formulas
may appear.
<h4>
<a NAME="3.2.12  \nonnullelements"></a>3.2.12&nbsp; <tt>\nonnullelements</tt></h4>
An expression of the form <tt>\nonnullelements(<i>A</i>)</tt> where <i><tt>A</tt></i>
is a specification expression of an array type is a specification expression
of type <tt>boolean</tt>.&nbsp; It is equivalent to
<blockquote><tt><i>A</i> != null &amp;&amp; (\forall int i; 0 &lt;= i &amp;
i &lt; A.length ==> <i>A</i>[i] != null)</tt></blockquote>
Expressions of the form above came up fairly frequently in our early experiments
with ESC/Java, and we found writing them sufficiently tedious to justify
the introduction of a special notation.
<p><b>Example</b>
<p>Consider the <tt>main</tt> method of a program:
<blockquote><tt>static public void main (String[] args) {</tt>...<tt>}</tt></blockquote>
The usual way for <tt>main</tt> to be invoked is with the value of <tt>args
</tt>derived
from the command line by the Java interpreter, in which case
<tt>args</tt>
will be non-null, and all its elements will be non-null.&nbsp; However,
it is legal for a Java program to contain explicit calls to <tt>main</tt>,
and the value of <tt>args</tt> supplied by such a call might in some cases
be either <tt>null</tt> or an array containing
<tt>null</tt> as an element.
<p>It is often helpful to annotate <tt>main</tt> as follows:
<blockquote><tt>//@ requires \nonnullelements(args);</tt>
<br><tt>static public void main (String[] args) {</tt>...<tt>}</tt></blockquote>
Given this annotation, (1) ESC/Java will assume, when checking the body
of <tt>main</tt>, that <tt>args</tt> and all its elements are non-null,
and (2)&nbsp; ESC/Java will check that any explicit calls to <tt>main</tt>
supply a non-null argument with only non-null elements.
<p><b>Fine points</b>
<p>Since an application of&nbsp; <tt>\nonnullelements</tt>&nbsp; does not
explicitly include a quantifier, it may be used as an argument to <tt>?
:</tt>&nbsp; and may occur inside an argument of <tt>\old</tt>.
<p>Note that if <i><tt>A</tt></i> is of type <tt><i>T</i>[][]</tt>, then
<tt>\nonnullelements(<i>A</i>)</tt>
implies that <tt><i>A</i>[<i>i</i>]</tt> is non-null (if <i><tt>i</tt></i>
is in bounds), but not necessarily that any <tt><i>A</i>[<i>i</i>][<i>j</i>]</tt>
is non-null.
<h4>
<a NAME="3.2.13  \fresh"></a>3.2.13&nbsp; <tt>\fresh</tt></h4>
An expression of the form <tt>\fresh(<i>E</i>)</tt> where <i><tt>E</tt></i>
is a specification expression of a reference type is a specification expression
of type <tt>boolean</tt>.&nbsp; In a postcondition, it denotes that <i><tt>E</tt></i>
is non-null and was not allocated in the pre-state of the routine call.
<br>(See also <a href="#2.3.2  ensures pragma">section 2.3.2.</a>)
<h4>
<a NAME="3.2.14  \result"></a>3.2.14&nbsp; <tt>\result</tt></h4>
Within a normal postcondition or a modification target of a non-<tt>void</tt>
method, the special identifier <tt>\result</tt> is a specification expression
whose type is the return type of the method.&nbsp; It denotes the value
returned by the method.&nbsp; <tt>\result</tt> is allowed only within an
<tt>ensures</tt>,
<tt>also_ensures</tt>,
<tt>modifies</tt>,
or <tt>also_modifies</tt> pragma that modifies the declaration of a non-<tt>void</tt>
method.
<p><b>Fine points</b>
<p>Note that although <tt>\result</tt> may occur within a modifies pragma,
it is not itself a specification designator (see <a href="#2.3.1  modifies pragma">section
2.3.1</a>).&nbsp; Thus
<blockquote><tt>modifies \result</tt></blockquote>
is never a legal pragma.&nbsp; However pragmas such as, for example,
<blockquote><tt>modifies \result.f</tt></blockquote>
or
<blockquote><tt>modifies \result[i]</tt></blockquote>
may be legal, depending on the type of <tt>\result</tt>.
<h4>
<a NAME="3.2.15  \old"></a>3.2.15&nbsp; <tt>\old</tt></h4>
In a postcondition, an expression of the form <tt>\old(<i>E</i>)</tt> where
<i><tt>E</tt></i>
is a specification expression is a specification expression of the same
type as <i><tt>E</tt></i>.&nbsp; It denotes the same thing as <i><tt>E</tt></i>
except that (1) any occurrences in <i><tt>X</tt></i> of a target field
(see <a href="#2.3.1.0  target fields">section 2.3.1.0</a>) of the routine
is interpreted according to the pre-state value of the field, and (2) if
any modification target of the routine has the form <tt><i>X</i>[<i>i</i>]</tt>
or <tt><i>X</i>[*]</tt>, then <i>all</i> array accesses within <i><tt>E</tt></i>
are interpreted according to the pre-state contents of arrays.&nbsp; An
expression of the form <tt>\old(<i>E</i>)</tt> may occur only in an <tt>ensures</tt>,
<tt>exsures</tt>,
<tt>also_ensures</tt>,
or <tt>also_exsures</tt> pragma.&nbsp; The argument
<i><tt>E</tt></i> may
not itself include any uses of <tt>\old</tt> or <tt>\fresh</tt>.
<p><b>Fine points</b>
<p>In a normal postcondition of a non-<tt>void</tt> method, the special
identifier <tt>\result</tt> (<a href="#3.2.14  \result">section 3.2.14</a>)
may occur within an argument to <tt>\old</tt>. In this context, <tt>\result</tt>
denotes, as usual, the value returned by the method, despite the fact that
the returned value may not even be allocated in the pre-state (in which
case the meaning of a field access <tt>\result.<i>f</i></tt> or an array
access <tt>\result[<i>i</i>]</tt> is unspecified).&nbsp; Similarly any
occurrence of <tt>this</tt> (explicit or implicit) in a normal postcondition
of a constructor denotes the constructed object, even within an argument
of <tt>\old</tt>.
<p>The following (correctly annotated) code example illustrates the semantics
of <tt>\old</tt>.
<blockquote><tt>class C {</tt>
<br><tt>&nbsp; static C x, oldx, y;</tt>
<br><tt>&nbsp; int f;</tt>
<br><tt>&nbsp; static int oldxf;</tt>
<br><tt>&nbsp; static int[] a, olda, b;</tt>
<br><tt>&nbsp; static int oldai;</tt>
<br><tt>&nbsp; static int i;</tt>
<p><tt>&nbsp; //@ requires x != null &amp; y != null;</tt>
<br><tt>&nbsp; //@ requires a != null &amp;&amp; 0 &lt;= i &amp; i &lt;
a.length;</tt>
<br><tt>&nbsp; //@ modifies oldx, oldxf, x, x.f, olda, oldai, a, a[i],
i;</tt>
<br><tt>&nbsp; //@ ensures oldx == \old(x)</tt>
<br><tt>&nbsp; //@ ensures oldxf == \old(x.f);</tt>
<br><tt>&nbsp; //@ ensures \old(x).f == \old(x.f) + 1;</tt>
<br><tt>&nbsp; //@ ensures (\exists C z; z == x &amp; \old(z.f) == \old(y.f));</tt>
<br><tt>&nbsp; //@ ensures olda == \old(a) &amp; oldai == \old(a[i]);</tt>
<br><tt>&nbsp; //@ ensures \old(a)[\old(i)] == \old(a[i]) + 1;</tt>
<br><tt>&nbsp; static void m() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; oldx = x;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; oldxf = x.f;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; x = y;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; oldx.f++;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; olda = a;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; oldai = a[i];</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = b;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; olda[i]++;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; i++;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
Note the distinctions between <tt>\old(x.f)</tt> and <tt>\old(x).f</tt>
and between <tt>\old(a)[\old(i)]</tt> and <tt>\old(a[i])</tt>.&nbsp; Note
also that while ESC/Java does not allow the notation <tt>x.\old(f)</tt>
to mean ``the original <tt>f</tt> field of the current value of <tt>x</tt>''
in the pragma, the same effect is achieved by the expression <tt>\old(z.f)</tt>
within the pragma
<blockquote><tt>//@ ensures (\exists C z; z == x &amp; \old(z.f) == \old(y.f))</tt></blockquote>
For further discussion of <tt>\old</tt>, including the interaction of <tt>\old</tt>
and <tt>modifies</tt>, see sections <a href="#2.3.2  ensures pragma">2.3.2</a>
and <a href="#2.3.3  A note on the interaction of modifies and \old">2.3.3</a>.
<h4>
<a NAME="3.2.16  \lblneg and \lblpos"></a>3.2.16&nbsp; <tt>\lblneg</tt>
and
<tt>\lblpos</tt></h4>
[<i>This section may be skipped on first (and second) reading.&nbsp; It
describes, incompletely, a feature of included mainly for use by the implementers.</i>]
<p>An expression of the form <tt>(\lblneg <i>n</i> <i>E</i>)</tt> or <tt>(\lblpos
<i>n
E</i>)</tt> where <i><tt>E</tt></i> is a specification expression of type
<tt>boolean</tt>
and <i><tt>n</tt></i> is an identifier (called an expression label) is
a specification expression of type <tt>boolean</tt>.&nbsp; Logically, the
<i>labeled
expression</i> <tt>(\lblneg <i>n</i> <i>E</i>)</tt> [or<tt>(\lblpos
<i>n
E</i>)</tt>] denotes the same thing as
<i><tt>E</tt></i>, but when ESC/Java
issues a warning, the warning message will mention the label
<i><tt>n</tt></i>
if, in the execution path associated with the warning, the expression
<i><tt>E</tt></i>
would evaluate to <tt>false</tt> [resp., <tt>true</tt>] at a point where
the containing pragma is ``relevant'' and in circumstances where the value
of the expression <i><tt>E</tt></i> is ``relevant'' to the pragma as a
whole.&nbsp; The details of the (heuristic) definition of ``relevant''
are beyond the scope of this manual and are subject to change.
<p><b>Example</b>
<p>Suppose file <tt>C.java</tt> contains the following code:
<blockquote><tt>class C {</tt>
<p><tt>&nbsp; //@ requires (\lblpos fee i &lt; 5) || (\lblpos fie i > 10);</tt>
<br><tt>&nbsp; //@ ensures (\lblneg foe \result != 5) &amp;&amp; (\lblneg
fum \result > 0);</tt>
<br><tt>&nbsp; int m(int i) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return i+1;</tt>
<br><tt>&nbsp; }</tt>
<p><tt>}</tt></blockquote>
Then output from the command <tt>escjava C.java</tt> includes the following
warning:
<blockquote><tt>C.java:7: Warning: Postcondition possibly not established
(Post)</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; ^</tt>
<br><tt>Associated declaration is "C.java", line 4, col 6:</tt>
<br><tt>&nbsp; //@ ensures (\lblneg foe \result != 5) &amp;&amp; (\lblneg
fum \result > 0 ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</tt>
<br><tt>Execution trace information:</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Executed return in "C.java", line 6, col 6.</tt>
<p><tt>Counterexample labels:</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fum&nbsp;&nbsp;&nbsp; fee</tt></blockquote>
The label <tt>fee</tt> comes from the positively labeled expression <tt>(\lblpos
fee i &lt; 5)</tt> in the <tt>requires</tt> pragma for method <tt>m</tt>,
and tells us that in the execution path associated with the warning,
<tt>m</tt>
is called with an argument <tt>i</tt> such that <tt>(i &lt; 5) == true</tt>.&nbsp;
The label <tt>fum</tt> comes from the negatively labeled expression <tt>(\lblneg
fum \result > 0)</tt> in the <tt>ensures</tt> pragma for <tt>m</tt>, and
tells us that in the execution path associated with the warning, <tt>m</tt>
returns a result <tt>\result</tt> such that
<tt>(\result > 0) == false</tt>.
<p><b>Fine points</b>
<p>Expression labels are in their own name space, so they never conflict
with or hide any other kinds of identifiers.
<p>Labeled expressions are allowed only in those places where quantified
expressions are allowed (see <a href="#3.2.10  \forall">section 3.2.10</a>).
<p><b>Limitation:</b>&nbsp; There are many situations in which labels are
ambiguous.&nbsp; For example, suppose file <tt>D.java</tt> contains the
code:
<blockquote><tt>class D {</tt>
<p><tt>&nbsp; int a, b;</tt>
<br><tt>&nbsp; //@ invariant (\lblpos foo a >= 0 &amp; b >= 0) || (\lblpos
bar a &lt; 0 &amp; b &lt;0);</tt>
<p><tt>&nbsp; //@ requires x != null &amp;&amp; y != null;</tt>
<br><tt>&nbsp; D(D x, D y) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = x.a;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; b = y.b;</tt>
<br><tt>&nbsp; }</tt>
<p><tt>}</tt></blockquote>
Then the command <tt>escjava D.java</tt> yields the warning:
<blockquote><tt>D.java:10: Warning: Possible violation of object invariant
(Invariant)</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; ^</tt>
<br>...
<br><tt>Counterexample labels:</tt>
<br><tt>&nbsp;&nbsp;&nbsp; bar&nbsp;&nbsp;&nbsp; foo</tt></blockquote>
There is no way to tell from this message whether ESC/Java is warning about
the case where
<tt>a</tt> has nonnegative <tt>x</tt> and <tt>y</tt> fields
and <tt>b</tt> has negative
<tt>x</tt> and <tt>y</tt> fields, or about
the case where
<tt>a</tt>'s fields are negative and <tt>b</tt>'s are nonnegative.&nbsp;
(However, for this particular example,&nbsp; the <tt>-counterexample</tt>
switch, described in <a href="#Appendix A:  Overview of how ESC/Java works">appendix
A</a>, would resolve the ambiguity.)
<h4>
<a NAME="3.2.17 owner"></a>3.2.17&nbsp; <tt>owner</tt></h4>
The standard <tt>.spec</tt> file (see <a href="#5.1.2  Specification (.spec) files">section
5.1.2</a>) for the class <tt>java.lang.Object</tt> gives every object <tt>O</tt>
a ghost field <tt>O.owner</tt> of type <tt>Object</tt>:
<blockquote><b><font face="Arial,Helvetica">ESC/Java input from file .../java/lang/Object.spec:</font></b>
<br>...
<br><tt>//@ ghost Object owner;</tt>
<br>...</blockquote>
The intended use of this field is for situations is which the programmer
wishes to specify that some field <tt>f</tt> is <i>unshared</i>.&nbsp;
For example. if a class <tt>T</tt> with an instance field <tt>f</tt> declares
the instance invariant
<blockquote><b><font face="Arial,Helvetica">ESC/Java input from file .../T.java:</font></b>
<br>...
<br><tt>//@ invariant f.owner == this</tt>
<br>...</blockquote>
then it follows that, at any point where the invariant holds, we cannot
have <tt>x.f == y.f</tt> for two distinct objects <tt>x</tt> and <tt>y</tt>
of type <tt>T</tt> (since the conditions <tt>x.f.owner == x</tt>, <tt>y.f.owner
== y</tt>, together with <tt>x.f == y.f</tt> would imply <tt>x == y</tt>).
<p><b>Example</b>
<p>Here is an example of a situation in which it is useful to specify that
a field is unshared.&nbsp;&nbsp; [<b>Note:</b>&nbsp; Understanding this
example may require more than a cursory reading.&nbsp; While we usually
relegate such material to sections marked ``<b>Fine points</b>'', the scenario
described here is of a sort that most ESC/Java users are likely to encounter
as soon as they try to check code with invariants of any complexity, specifically
invariants involving both (1) quantification (including the quantification
implicit in all instance invariants) and (2) indirect references like <tt>x.f.g</tt>
or <tt>x.a[i]</tt> (including cases where an expression like <tt>f.g</tt>
or <tt>a[i]</tt> implicitly means <tt>this.f.g</tt> or <tt>this.a[i]</tt>).&nbsp;
A few minutes working through the details with pen or pencil in hand will
lead to clear understanding, and the time will be well spent.]
<p>Consider the following class, whose instances represent stacks of objects
(to keep the example simple, we put a fixed limit of 10 on the size of
a stack):
<blockquote><b><font face="Arial,Helvetica">Input from file ObjStack.java:</font></b>
<br><tt><font size=-2>&nbsp; 1:&nbsp; </font>class ObjStack {</tt>
<br><tt><font size=-2>&nbsp; 2:&nbsp;&nbsp;</font>&nbsp; /*@ non_null */
Object [] a;</tt>
<br><tt><font size=-2>&nbsp; 3:&nbsp;&nbsp;</font>&nbsp; //@ invariant
a.length == 10;</tt>
<br><tt><font size=-2>&nbsp; 4:&nbsp;&nbsp;</font>&nbsp; //@ invariant
\elemtype(\typeof(a)) == \type(Object);</tt>
<br><tt><font size=-2>&nbsp; 5:&nbsp;&nbsp;</font>&nbsp; int n;&nbsp; //@
invariant 0 &lt;= n &amp; n &lt;= 10;</tt>
<br><tt><font size=-2>&nbsp; 6:&nbsp;&nbsp;</font>&nbsp; //@ invariant
(\forall int i; n &lt;= i &amp; i &lt; 10 ==> a[i] == null);</tt>
<br><tt><font size=-2>&nbsp; 7:</font></tt>
<br><tt><font size=-2>&nbsp; 8:&nbsp;&nbsp;</font>&nbsp; ObjStack() {</tt>
<br><tt><font size=-2>&nbsp; 9:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; n
= 0;</tt>
<br><tt><font size=-2>&nbsp;10:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; a
= new Object[10];</tt>
<br><tt><font size=-2>&nbsp;11:&nbsp;&nbsp;</font>&nbsp; }</tt>
<br><tt><font size=-2>&nbsp;12:</font></tt>
<br><tt><font size=-2>&nbsp;13:&nbsp;&nbsp;</font>&nbsp; //@ requires n
&lt; 10;</tt>
<br><tt><font size=-2>&nbsp;14:&nbsp;&nbsp;</font>&nbsp; void Push(Object
o) {</tt>
<br><tt><font size=-2>&nbsp;15:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; a[n++]
= o;</tt>
<br><tt><font size=-2>&nbsp;16:&nbsp;&nbsp;</font>&nbsp; }</tt>
<br><tt><font size=-2>&nbsp;17:</font></tt>
<br><tt><font size=-2>&nbsp;18:&nbsp;&nbsp;</font>&nbsp; //@ requires n
> 0;</tt>
<br><tt><font size=-2>&nbsp;19:&nbsp;&nbsp;</font>&nbsp; Object Pop() {</tt>
<br><tt><font size=-2>&nbsp;20:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; Object
o = a[--n];</tt>
<br><tt><font size=-2>&nbsp;21:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; a[n]
= null;</tt>
<br><tt><font size=-2>&nbsp;22:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; return
o;</tt>
<br><tt><font size=-2>&nbsp;23:&nbsp;&nbsp;</font>&nbsp; }</tt>
<br><tt><font size=-2>&nbsp;24:</font></tt>
<br><tt><font size=-2>&nbsp;25:&nbsp; </font>}</tt></blockquote>
The elements of a stack <tt>x</tt> are the first <tt>x.n</tt> elements
of the array <tt>x.a</tt>.&nbsp; To avoid retaining pointers to garbage,
we insure that the&nbsp; remaining elements of <tt>x.a</tt> are <tt>null</tt>,
as specified by the <tt>invariant</tt> pragma on line 6.
<p>If we run ESC/Java on the source above, it produces the following complaint:
<blockquote><tt>ObjStack: Push(java.lang.Object) ...</tt>
<br><tt>ObjStack.java:16: Warning: Possible violation of object invariant
(Invariant)</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; ^</tt>
<br><tt>Associated declaration is "ObjStack.java", line 6, col 6:</tt>
<br><tt>&nbsp; //@ invariant (\forall int i; n &lt;= i &amp; i &lt; 10
==> a[i] == null)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</tt>
<br><tt>Possibly relevant items from the counterexample context:</tt>
<br><tt>&nbsp; </tt>...
<br><tt>&nbsp; brokenObj&lt;2> != this</tt>
<br><tt>&nbsp; </tt>...
<br><tt>(brokenObj* refers to the object for which the invariant is broken.)</tt></blockquote>
(For a basic explanation of counterexample contexts, see <a href="#Appendix A:  Overview of how ESC/Java works">appendix
A</a>.)&nbsp; What is going on here is that ESC/Java has found a scenario
in which the
<tt>Push</tt> method fails to maintain the instance invariant
on line 6.&nbsp; The line
<blockquote><tt>brokenObj&lt;1> != this</tt></blockquote>
tells us that the object for which the invariant is broken is not the object
(<tt>this</tt>) whose <tt>Push</tt> method is called.&nbsp; The problem
is that, so far as ESC/Java can tell, there may be some object, call it
<tt>brokenObj</tt>,
such that the following conditions hold at the start of the execution of
<tt>Push</tt>:
<ul>
<li>
<tt>brokenObj != this</tt></li>

<li>
<tt>brokenObj.a == this.a</tt></li>

<li>
<tt>brokenObj.n == this.n</tt></li>
</ul>
Now consider the effect of the line
<blockquote><tt><font size=-2>15:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;
a[n++] = o;</tt></blockquote>
The evaluation of <tt>n++</tt> increases <tt>this.n</tt>, but leaves <tt>brokenObj.n</tt>
unchanged.&nbsp; On the other hand, the array store does set <tt>brokenObj.a[n]</tt>
(where <tt>n</tt> denotes the value before the increment) to <tt>o</tt>.&nbsp;
Thus, after line 16, we have
<ul>
<li>
<tt>brokenObj.a[brokenObj.n] == o</tt></li>
</ul>
so that if <tt>o != null</tt> (as may very well be the case),&nbsp; the
instance invariant on line 6 is violated for <tt>brokenObj</tt>.
<p>In fact,&nbsp; as illustrated by the example above, the correctness
of the <tt>Push</tt> method of <tt>ObjStack</tt> depends on an implicit
design decision:&nbsp; No two distinct <tt>ObjStack</tt>'s ever share the
same
<tt>a</tt> field.&nbsp; (The correctness of <tt>Pop</tt> also depends
on this design decision, though not in a way that is checked by ESC/Java
given the annotations in the example above.)&nbsp; The user can take advantage
of the <tt>owner</tt> field to communicate this design decision to ESC/Java
by adding the pragma:
<blockquote><tt><font size=-2>7:&nbsp;&nbsp;</font>&nbsp; //@ invariant
a.owner == this</tt></blockquote>
(Given this invariant, it is no longer possible to have a scenario in which
the conditions
<ul>
<li>
<tt>brokenObj != this</tt></li>

<li>
<tt>brokenObj.a == this.a</tt></li>
</ul>
both hold.)&nbsp; Having added this invariant, the user must also supply
a <tt>set</tt> pragma in order to guarantee that the constructor for <tt>ObjStack</tt>
establishes the invariant:
<blockquote><tt><font size=-2>&nbsp;9:&nbsp;&nbsp;</font>&nbsp; ObjStack()
{</tt>
<br><tt><font size=-2>10:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; n = 0;</tt>
<br><tt><font size=-2>11:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; a = new
Object[10];</tt>
<br><tt><font size=-2>12:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; //@ set
a.owner = this;</tt>
<br><tt><font size=-2>13:&nbsp;&nbsp;</font>&nbsp; }</tt></blockquote>
Without the <tt>set</tt> pragma, ESC/Java will generate a warning that
the constructor fails to establish the invariant <tt>a.owner == this</tt>.
<p><b>Fine points</b>
<p>Just as all constructors have the implicit postcondition <tt>\fresh(\result)</tt>
(see section 2.3.2), all constructors (including the implicit constructors
for arrays) have the implicit postcondition <tt>this.owner == null</tt>.&nbsp;
In the example above, this implicit postcondition guarantees that <tt>this.a.owner
== null</tt> after line 11.&nbsp; If <tt>this.a.owner</tt> could have had
some non-null value (call it <tt>brokenObj</tt>) after line 11, then the
<tt>set</tt>
pragma might cause the invariant on line 7 to be violated for <tt>brokenObj</tt>.
<p>Another way to guarantee that no two <tt>ObjStack</tt>'s share the same
<tt>a</tt>
field would be to include in the declaration of <tt>ObjStack</tt> the static
invariant
<blockquote><tt>(\forall ObjStack x, y; x != y ==> x.a != y.a)</tt></blockquote>
The instance invariant <tt>a.owner == this</tt> is not only more succinct
than the static invariant above, but also stronger.&nbsp; To see why, suppose
we had another class <tt>Foo</tt> which declared a field <tt>b</tt> and
the instance invariant <tt>b.owner == this</tt>.&nbsp; Then the invariants
<tt>a.owner
== this</tt> (for <tt>ObjStack</tt>) and <tt>b.owner == this</tt> (for
<tt>Foo</tt>)
together would imply not only
<blockquote><tt>(\forall ObjStack x, y; x != y ==> x.a != y.a)</tt></blockquote>
and
<blockquote><tt>(\forall Foo x, y; x != y ==> x.a != y.b)</tt></blockquote>
but also
<blockquote><tt>(\forall ObjStack x; (\forall Foo y: (Object)x != y ==>
x.a != y.b))</tt></blockquote>
If, for example, ESC/Java were checking code that modified a component
of the <tt>b</tt> field of some <tt>Foo foo</tt>, and if that code occurred
in a scope where the invariant on line 6 of <tt>ObjStack.java</tt> were
considered heuristically relevant (see the fine points in <a href="#2.4.1  invariant pragma">section
2.4.1</a>), then ESC/Java would need this last consequence in order to
eliminate from consideration scenarios in which the invariant on line 6
might become violated for some <tt>ObjStack brokenObj</tt> with <tt>brokenObj.a
== foo.b</tt>.
<p>See [<a href="#[LS99]">LS99</a>] for a different approach to specifying
that certain fields are unshared.
<h3>
<a NAME="3.3  Scoping, name resolution, and access control in specificat"></a>3.3
Scoping, name resolution, and access control in specification expressions</h3>
The rules for scoping, accessibility, and resolution of names in specification
expressions differ in several ways from those for Java expressions.&nbsp;
We have described most of these differences elsewhere in this manual, but
repeat them here to have them collected in one place.
<p>Applications of the ESC/Java operators <tt>\typeof</tt>, <tt>\elemtype</tt>,
<tt>\max</tt>,
<tt>\nonnullelements</tt>,<tt>\fresh</tt>,
and <tt>\old</tt> are parsed like method invocations, with the operator
taking the role of the method name.&nbsp; Of course, applications of these
operators are allowed in specification expressions even though ordinary
method invocations are forbidden, as stated in <a href="#3.1  Restrictions">section
3.1</a>.
<p>Bound variables introduced by <tt>\forall</tt> and <tt>\exists</tt>
are scoped like Java local variables, as are the variables declared to
name exceptions in <tt>exsures</tt> and <tt>also_exsures</tt> pragmas.&nbsp;
For example, in a quantified expression <tt>(\forall int k; a[k] == 0)</tt>,
the declaration <tt>int k;</tt> introduces the bound variable <tt>k</tt>,
whose scope is the <i>SpecExpr</i><tt> a[k] == 0</tt>.&nbsp; Furthermore,
just as Java forbids declaration of an identifier as a local variable within
the scope of a parameter or local variable of the same name [<i>JLS</i>,
14.3.2], so ESC/Java forbids declaration of an identifier as a bound variable
within the scope of a parameter, local variable, or bound variable of the
same name.&nbsp; Consequently, the quantified expression <tt>(\forall int
k;&nbsp; a[k] == 0)</tt> cannot occur in a scope where there is already
a parameter, local variable, or bound variable named <tt>k</tt>.
<p>The scoping rules of routine parameters, fields, <tt>this</tt>, and
<tt>super</tt>
are slightly different from those in Java.&nbsp; In particular:
<ul>
<li>
When a <i>SpecExpr</i> occurs in a modifier pragma (<a href="#2.0.1  There are four syntactic categories of pragmas.">section
2.0.1</a>) applied to a field, names in the <i>SpecExpr</i> are resolved
as if the <i>SpecExpr</i> were part of the initializer of the field.&nbsp;
Consequently, if the field is an instance variable, then <tt>this</tt>
and <tt>super</tt> can be mentioned and any unqualified field name <tt>f</tt>
is a synonym for <tt>this.f</tt>.&nbsp; While Java forbids field initializers
from using other fields that are declared later in textual order (even
though they are in scope), this restriction does not apply to ESC/Java
pragmas (compare the examples in sections <a href="#2.5.1  readable_if pragma">2.5.1</a>
and <a href="#2.7.0  monitored_by pragma">2.7.0</a> to those in [<i>JLS</i>,
8.3.2.1, 8.3.2.2]).</li>

<li>
When a <i>SpecExpr</i> occurs in a modifier pragma applied to a routine
declaration, names in the <i>SpecExpr</i> are resolved as if the <i>SpecExpr</i>
were placed at the beginning of the routine body.&nbsp; Consequently, the
names of the routine's parameters are in scope.&nbsp; Furthermore, if the
routine is an instance method, then <tt>this</tt> and <tt>super</tt> can
be mentioned, and if the routine is a constructor, then <tt>this</tt> and
<tt>super</tt>
can be mentioned in <tt>ensures</tt> pragmas.&nbsp; As usual, wherever
<tt>this</tt>
can be mentioned, an unqualified field name <tt>f</tt> is a synonym for
<tt>this.f</tt>.</li>

<li>
When a <i>SpecExpr</i> occurs in a modifier pragma applied to an abstract
method declaration, names in the <i>SpecExpr</i> are resolved as if the
method could have a body and the <i>SpecExpr</i> were placed there.&nbsp;
That is, the names of the method's parameters are in scope, <tt>this</tt>
can be mentioned, any unqualified field name <tt>f</tt> is a synonym for
<tt>this.f</tt>,
and if the abstract method declaration occurs in a class (rather than in
an interface) then <tt>super</tt> can be mentioned.</li>

<li>
In any other <i>SpecExpr</i>, the same parameters, local variables, and
fields are in scope as in the Java context where the annotation containing
the <i>SpecExpr</i> occurs; <tt>this</tt> can be mentioned (and any unqualified
field name <tt>f</tt> is a synonym for <tt>this.f</tt>) if the <i>SpecExpr</i>
occurs in a Java context where <tt>this</tt> can be mentioned; and <tt>super</tt>
can be mentioned if the <i>SpecExpr</i> occurs in a Java context where
<tt>super</tt>
can be mentioned.&nbsp; Moreover, in a <i>SpecExpr</i> that occurs in a
declaration pragma (see <a href="#2.0.1  There are four syntactic categories of pragmas.">section
2.0.1</a>) in a class, <tt>this</tt> and <tt>super</tt> can be mentioned
and any unqualified field name <tt>f</tt> is a synonym for <tt>this.f</tt>.</li>
</ul>
A <tt>ghost</tt> field <i><tt>f</tt> </i>(see <a href="#2.6.0  ghost pragma">section
2.6.0</a>) is in scope in pragmas wherever an actual Java member of the
class containing the <tt>ghost</tt> pragma declaring <i><tt>f</tt></i>
would be in scope.&nbsp; The rules for name resolution are different for
ghost variables than for ordinary variables.&nbsp; Java variables (if in
scope) hide conflicting ghost variables of the same name regardless of
their points of declaration, and regardless of whether the Java variable
is accessible.&nbsp; Ghost variables, on the other hand, hide neither Java
variables nor other ghost variables.&nbsp; For example, given the declarations
<blockquote><b><font face="Arial,Helvetica">Input form file I.java:</font></b>
<br><tt>interface I {</tt>
<br><tt>&nbsp; //@ ghost public int i;</tt>
<br><tt>&nbsp; //@ ghost public int j;</tt>
<br><tt>&nbsp; </tt><i>...</i>
<br><tt>}</tt>
<br><b><font face="Arial,Helvetica">Input from file C.java:</font></b>
<br><tt>class C {</tt>
<br><tt>&nbsp;private int i;</tt>
<br><tt>&nbsp;//@ ghost public int j;</tt>
<br><tt>&nbsp;</tt>...
<br><tt>}</tt>
<br><b><font face="Arial,Helvetica">Input from file D.java:</font></b>
<br><tt>class D extends C implements I {</tt>...<tt>}</tt></blockquote>
a reference to <tt>i</tt> in a pragma in <tt>D.java</tt> would resolve
to the real field of <tt>C</tt> rather than the ghost field of <tt>I</tt>
(and would then generate an error because that field is not accessible
in <tt>D</tt>), while a reference to <tt>j</tt> in a pragma in <tt>D</tt>
would be ambiguous (since <tt>C</tt> and <tt>I</tt> both declare ghost
fields named <tt>j</tt> and neither hides the other).
<p><b>Note:</b>&nbsp; The preceding rules about ghost variables, and the
restriction against reusing a name in scope as a ghost field name (<a href="#2.6.0  ghost pragma">section
2.6.0</a>), are intended to reduce the number of situations where a name
unambiguously means one thing in Java code and unambiguously means a different
thing in an adjacent pragma.&nbsp; Unfortunately, some such situations
still remain.&nbsp; For example, if a ghost field and a class have the
same name <tt>N</tt>, then the expression <tt>N</tt>.<tt>f</tt> might refer
to a static field of class <tt>N</tt> in Java code, while meaning <tt>this.N.f</tt>
in a nearby annotation.
<p>The rules that make names accessible in specification expressions (<i>spec-accessible</i>)
are in some cases more liberal that Java's access control rules [<i>JLS</i>,
6.6].&nbsp; In particular:
<ul>
<li>
If a variable's declaration is annotated with a <tt>spec_public</tt> (<a href="#2.5.0  spec_public pragma">section
2.5.0</a>) pragma, then the variable is spec-accessible wherever it would
have been spec-accessible if it had been declared <tt>public</tt>.</li>

<li>
A variable declared as <tt>protected</tt> is spec-accessible in the package
where it is declared and in any subclass of the class where it is declared
(without the additional restriction in [<i>JLS</i>, 6.6.2]).</li>
</ul>
Of course there are also some cases where variables--for example, ghost
variables (<a href="#2.6.0  ghost pragma">section 2.6.0</a>)--are spec-accessible
but not Java accessible simply because they are not in scope in Java.
<p>Finally, the label <i>Identifier</i> in a <tt>\lblpos</tt> or <tt>\lblneg</tt>
expression is part of a separate name space.&nbsp; The label does not become
available for use inside the <i>SpecExpr</i>.&nbsp; A label is permitted
to have the same name as an identifier already in scope or as a label in
an enclosing labeled expression.&nbsp; If a label has the same name as
an identifier already in scope, it does not hide that identifier.
<hr WIDTH="100%">
<h2>
<a NAME="4  Warnings"></a>4&nbsp; Warnings</h2>
ESC/Java issues warnings for conditions that it regards as run-time errors,
and that, so far is it can tell, might actually occur at run-time.
<p>The potential conditions that give rise to some ESC/Java warning types
(specifically <tt>Null</tt>, <tt>IndexNegative</tt>, <tt>IndexTooBig</tt>,
<tt>Cast</tt>,
<tt>ArrayStore</tt>,
<tt>ZeroDiv</tt>,
and <tt>NegSize</tt>) are conditions that would be detected by the Java
run-time system and give rise to exceptions (specifically,
<tt>NullPointerException</tt>,<tt>
IndexOutOfBoundsException</tt>,
<tt>ClassCastException</tt>,<tt> ArrayStoreException</tt>,<tt>
ArithmeticException</tt>, and <tt>NegativeArraySizeException</tt>).&nbsp;
The current ESC/Java regards these conditions as run-time errors, and generates
warnings for them even if the program actually catches the resulting exceptions.
<blockquote><b>Fine point:&nbsp; </b>In some cases multiple warnings may
arise from the same cause.&nbsp; For example, if a variable is dereferenced
in multiple arms of a <tt>switch</tt> statement but is not dereferenced
before the <tt>switch</tt> statement, and ESC/Java cannot confirm that
the variable is non-null, then it will issue a warning for the first dereference
of the variable in each arm of the <tt>switch</tt> statement.&nbsp; In
order to reduce the likelihood of flooding the user with redundant warnings,
ESC/Java will issue at most 10 warnings for any method or routine before
moving on to the next routine.&nbsp; Users can change the maximum number
of warnings per routine by setting the <tt>PROVER_CC_LIMIT</tt> environment
variable (see the <tt>escjava(1)</tt> man page).</blockquote>
Section 4.0 describes the parts of ESC/Java warning messages.&nbsp; The
remaining subsections of this section describe all the types of warnings
issued by the current ESC/Java.&nbsp; [<i>These descriptions may be skipped
on first reading, or until the reader is confronted with an ESC/Java warning
whose meaning or cause is unclear.</i>]
<p>A recommended discipline for using ESC/Java is to annotate your program
sufficiently so that ESC/Java produces no warnings, and in this process
to resort to the use of <tt>nowarn</tt> or <tt>assume</tt> pragmas only
in cases where other alternatives are impractical.&nbsp; Below we include
occasional tips about pragmas that might be added in response to particular
warnings.&nbsp; The <tt>-suggest</tt> command-line option (see
<a href="#5.1.1  The ESC/Java class path (-classpath, CLASSPATH, -bootcla">section
5.1.1</a> or the <tt>escjava(1)</tt> man page) causes ESC/Java to offer
suggestions (of varying quality) for pragmas that might be added in response
to some warnings.
<h3>
<a NAME="4.0  Parts of ESC/Java warning messages"></a>4.0&nbsp; Parts of
ESC/Java warning messages</h3>
The <i>primary part</i> of each ESC/Java warning message gives a brief
description of the kind of condition being warned of, including a parenthesized
``warning type'' name, and indicates a source code location--the ``dynamic
location'' of the warning--for the control point at which the condition
potentially occurs.
<p>For some warning types, the message additionally indicates the source
code location of (the first character of the initial keyword of) the pragma--the
warning's <i>associated pragma</i>--that causes ESC/Java to regard the
condition as a run-time error.
<p>If the warning is an <tt>Invariant</tt> warning, the message will usually
include a <i>partial counterexample context</i>, which may be of help to
the user to tell which object that might--so far has ESC/Java can determine--have
its one of its invariants violated and why.
<p>An ESC/Java warning message may include an <i>execution trace</i> listing
interesting (see the fine points below) control decisions on some execution
path that--so far as ESC/Java can determine--may plausibly lead to the
run-time error mentioned in the warning.
<p>Finally, an ESC/Java might list some labels that occur in pragmas an
are relevant to the scenario being warned about.&nbsp; (See <a href="#3.2.16  \lblneg and \lblpos">section
3.2.16</a> for some examples.)
<p><b>Example</b>
<p>Suppose the file <tt>C.java</tt> contains the following class declaration.
<blockquote><tt><font size=-2>&nbsp;1:&nbsp; </font>class C {</tt>
<br><tt><font size=-2>&nbsp;2:</font></tt>
<br><tt><font size=-2>&nbsp;3:&nbsp;&nbsp;</font> int i;</tt>
<br><tt><font size=-2>&nbsp;4:&nbsp;&nbsp;</font> int[] x;</tt>
<br><tt><font size=-2>&nbsp;5:&nbsp;&nbsp;</font>&nbsp; /*@ invariant i
> 0</tt>
<br><tt><font size=-2>&nbsp;6:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
==> x != null</tt>
<br><tt><font size=-2>&nbsp;7:&nbsp;&nbsp;</font>&nbsp; */</tt>
<br><tt><font size=-2>&nbsp;8:</font></tt>
<br><tt><font size=-2>&nbsp;9:&nbsp;&nbsp;</font>&nbsp; void m (int[] p,
int[] q) {</tt>
<br><tt><font size=-2>10:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; i = 10;</tt>
<br><tt><font size=-2>11:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; int[] t;</tt>
<br><tt><font size=-2>12:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; if (p !=
null) {</tt>
<br><tt><font size=-2>13:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
t = p;</tt>
<br><tt><font size=-2>14:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt><font size=-2>15:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
t = q;</tt>
<br><tt><font size=-2>16:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt><font size=-2>17:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; x = t;</tt>
<br><tt><font size=-2>18:&nbsp;&nbsp;</font>&nbsp; }</tt>
<br><tt><font size=-2>19:&nbsp; </font>}</tt></blockquote>
Then the output from the command
<blockquote><tt>escjava C.java</tt></blockquote>
includes one warning message.
<p>The primary part of the warning message indicates that the some invariant
might not hold when control reaches the end of the method <tt>m</tt>:
<blockquote><tt>CC.java:18: Warning: Possible violation of object invariant
(Invariant)</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; ^</tt></blockquote>
The next part of the warning message gives the associated pragma, an <tt>invariant</tt>
pragma starting on line 5:
<blockquote><tt>Associated declaration is "C.java", line 5, col 6:</tt>
<br><tt>&nbsp; /*@ invariant i > 0 ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</tt></blockquote>
The ellipsis indicates that the associated pragma may continue beyond the
part that is shown in the message.&nbsp; (In this case it extends onto
the next line of the program.)
<p>Since this is an <tt>Invariant</tt> warning, it includes a partial counterexample
context:
<blockquote><tt>Possibly relevant items from the counterexample context:</tt>
<br><tt>&nbsp; brokenObj == this</tt>
<br><tt>(brokenObj* refers to the object for which the invariant is broken.)</tt></blockquote>
Here we see that the object whose invariant might be violated is <tt>this</tt>,
that is, the object whose <tt>m</tt> method is being executed.
<p>The final part of the warning message is an execution trace, indicating
a scenario in which the right hand side <tt>c</tt> of the assignment on
line 12 might in fact evaluate to <tt>null</tt>:
<blockquote><tt>Execution trace information:</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Executed else branch in "C.java", line 14, col
11.</tt></blockquote>
<b>Fine points</b>
<p>The command-line option <tt>-plainwarning</tt> suppresses output of
partial counterexample contexts in <tt>Invariant</tt> warnings.
<p>The command-line option <tt>-counterexample</tt> causes ESC/Java to
supply counterexample contexts with all warnings.
<p>The execution trace in a warning mentions the following events on the
execution path associated with the warning:
<ul>
<li>
execution of a <tt>return</tt> statement (provided evaluation of the expression
to be returned completes normally)</li>

<li>
execution of a <tt>throw</tt> statement (provided evaluation of the exception
to be thrown completes normally)</li>

<li>
execution of a <tt>break</tt> statement</li>

<li>
execution of a <tt>continue</tt> statement</li>

<li>
commencement of any branch of an <tt>if</tt> statement (including the implicit
empty <tt>else</tt> branch)</li>

<li>
commencement of any branch of a <tt>switch</tt> statement (including the
implicit <tt>default</tt>)</li>

<li>
commencement of evaluation of either arm of a conditional ( <tt>? :</tt>
) expression</li>

<li>
short-circuit completion of evaluation of a conditional (<tt>&amp;&amp;</tt>
and <tt>||</tt>) expression</li>

<li>
exceptional completion of a routine call</li>

<li>
commencement of any iteration of a loop (see the fine points of <a href="#2.4.3  loop_invariant pragma">section
2.4.3</a> for information about ESC/Java's treatment of loops)</li>

<li>
entrance to a <tt>finally</tt> block, when the associated <tt>try</tt>
block terminates with a <tt>throw</tt>, <tt>return</tt>, <tt>break</tt>,
or <tt>continue</tt></li>

<li>
exit from a <tt>finally</tt> block, when the block is entered after a <tt>throw</tt>,
<tt>return</tt>,
<tt>break</tt>,
or <tt>continue</tt> and the body of the
<tt>finally</tt> block completes
normally (so that the <tt>throw</tt>,
<tt>return</tt>,
<tt>break</tt>,
or <tt>continue</tt> is resumed after the <tt>finally</tt> block)</li>
</ul>
ESC/Java actually associates some execution path with each warning, but
if the execution path associated with a warning includes no events of the
kinds listed above, then ESC/Java omits the line
<blockquote><tt>Execution trace information:</tt></blockquote>
from the warning message.
<p>The command-line option <tt>-notrace</tt> suppresses output of execution
traces.
<p>The command-line option <tt>-suggest</tt> causes ESC/Java to accompany
certain of its warning messages with suggestions for pragmas that may eliminate
those warnings.&nbsp; See <a href="#5.0  -suggest">section 5.0</a> for
some examples.
<h3>
<a NAME="4.1  ArrayStore warning"></a>4.1&nbsp; <tt>ArrayStore</tt> warning</h3>
An <tt>ArrayStore</tt> warning warns that the control may reach an assignment
<tt><i>A</i>[<i>I</i>]
= <i>E</i></tt> when the value of <i><tt>E</tt></i> is not assignment compatible
with the actual element type of <i><tt>A</tt></i>.&nbsp; (This condition
would result in an <tt>ArrayStoreException</tt> being thrown at run time
[<i>JLS</i>, 10.10, 15.25.1].)
<p><b>Tip:</b>&nbsp; See <a href="#3.2.4  Examples involving \TYPE, \type, \typeof, \elemtype, and <:">section
3.2.4</a> for discussion of a common cause of spurious <tt>ArrayStore</tt>
warnings and examples of annotations to avoid them.
<h3>
<a NAME="4.2  Assert warning"></a>4.2&nbsp; <tt>Assert</tt> warning</h3>
An <tt>Assert</tt> warning warns that control may reach a pragma <tt>assert
<i>E</i></tt>
when the value of <i><tt>E</tt></i> is <i><tt>false</tt></i>.
<h3>
<a NAME="4.3  Cast warning"></a>4.3&nbsp; <tt>Cast</tt> warning</h3>
A <tt>Cast</tt> warning warns that control may reach a cast <tt>(<i>T</i>)<i>E</i></tt>
when the value of <i><tt>E</tt></i> cannot be cast to the type <i><tt>E</tt></i>.&nbsp;
(This condition would result in a <tt>ClassCastException</tt> being thrown
at run time [<i>JLS</i>, 5.4, 15.15].)
<p><b>Tip:</b>&nbsp; <tt>Cast</tt> warnings often arise in connection with
the use ``container'' classes, when the programmer intends a particular
container to be used exclusively to hold elements of some particular type
<tt>T</tt>
(a proper subtype of <tt>Object</tt>) but the methods for extracting elements
are declared to return results of type <tt>Object</tt>.&nbsp; The second
example in <a href="#2.6.2  Examples using ghost variables">section 2.6.2</a>
shows how the programmer can use a <tt>ghost</tt> variable to express the
design decision that the container will hold only instances of <tt>T</tt>
(so that objects extracted from the container can always safely be cast
to type <tt>T</tt>).
<h3>
<a NAME="4.4  Deadlock warning"></a>4.4&nbsp; <tt>Deadlock</tt> warning</h3>
A <tt>Deadlock</tt> warning warns that control may reach a <tt>synchronized</tt>
statement or a call to a <tt>synchronized</tt> method that would acquire
a lock in violation of the locking order.&nbsp; That is, it warns of the
possibility that a thread might attempt to acquire a lock <i><tt>L</tt></i>
when
<blockquote><tt>\lockset[<i>L</i>] | \max(\lockset) &lt; <i>L</i></tt></blockquote>
is false.
<p>In the current ESC/Java, <tt>Deadlock</tt> warnings are disabled by
default, but can be enabled by use of the command line option <tt>-warn
Deadlock</tt>.
<p>The only way that ESC/Java can ever show that the execution of a <tt>synchronized</tt>
statement or a <tt>synchronized</tt> method body will not result in a potential
locking order violation (and thus in a potential deadlock) is by using
information supplied in pragmas.&nbsp; The usual way to supply the necessary
information is to use an axiom pragma to supply information about the locking
order, and to use a <tt>requires</tt> pragma to supply information about
the locks held on entry to any routine whose body includes a <tt>synchronized</tt>
statement or a call to a <tt>synchronized</tt> method.
<p>A <tt>Deadlock</tt> warning has no associated pragma.&nbsp; Typically
the warning results from the absence of some pragma that would supply the
information needed to show that the locking order is obeyed.&nbsp; While
a user might sometimes blame a <tt>Deadlock</tt> warning on a bug in some
specific pragma, there is no general mathematical rule for uniquely ascribing
such blame.
<h3>
<a NAME="4.5  Exception warning"></a>4.5&nbsp; <tt>Exception</tt> warning</h3>
An <tt>Exception</tt> warning warns that a routine may terminate abruptly
by throwing an exception that is not an instance of any type listed in
the routine's throws clause.
<p>Note that ESC/Java's treatment of unchecked exception classes [JLS,
11.1] is different from Java's.&nbsp; Java's compile-time checking never
requires a throws clause to mention an unchecked exception class.&nbsp;
By contrast, when ESC/Java checks the body of a routine <i><tt>R</tt></i>,
it considers the possibility of exceptions being thrown by any <tt>throw</tt>
statement in the body of <i><tt>R</tt></i> and by any call from <i><tt>R</tt></i>
to a routine with a nonempty throws clause, and it issues a warning if
(so far as it can determine) it is possible that <i><tt>R</tt></i> may
terminate abruptly with such an exception other than an instance of a type
mentioned in <i><tt>R</tt></i>'s throws clause.&nbsp; (However, ESC/Java
does not consider the possibility of exceptions being thrown other than
by <tt>throw</tt> statements or in accordance with the throws clauses of
called routines.)
<p><b>Tips:</b>&nbsp; The control point associated with an <tt>Exception</tt>
warning is the end of the routine body, rather than the point at which
the exception is first thrown.&nbsp; This is technically correct because
the potential error is not throwing the exception, but letting the exception
escape the routine body without being caught.&nbsp; However, in trying
to understand why the warning is being issued and what to do about it,
you are more likely to be interested in knowing where the problematic exception
might be thrown, as indicated by the execution trace (see <a href="#4.0  Parts of ESC/Java warning messages">section
4.0</a>) in the warning message.
<p>The Java language requires that routines declare all checked exceptions
that they might throw [<i>JLS</i>, 11.2].&nbsp; Consequently, ESC/Java's
<tt>Exception</tt>
warning is of interest only in connection with unchecked exceptions.&nbsp;
Even if your own code makes no mention of unchecked exceptions it may call
library routines whose throws clauses mention unchecked exceptions.
<p>It may tempting to take the view that unchecked exceptions are unchecked
precisely because it is not worthwhile to check for their presence at compile
time, and therefore always to run ESC/Java with the <tt>-nowarn Exception</tt>
command-line option (see the <tt>escjava(1)</tt> man page for descriptions
of ESC/Java command-line options).&nbsp; However, the whole purpose of
ESC/Java is to do more sophisticated static checking than compilers do,
and you may make better use of its capabilities by employing a less extreme
and more fine-grained treatment of unchecked exceptions.&nbsp; Suppose,
for example, that your program calls a library method with the declaration
<blockquote><tt>&nbsp; /**&nbsp; Returns the element-wise sum of a and
b.&nbsp; Throws</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a NullPointerException if
either a or b is null.</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Throws an IndexOutOfBoundsException
if a and b are</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; not of the same length.</tt>
<br><tt>&nbsp; **/</tt>
<br><tt>&nbsp; public static int[] add(int[] a, int[] b)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; throws NullPointerException, IndexOutOfBoundsException</tt>
<br><tt>&nbsp; { </tt>...
<br><tt>&nbsp; }</tt></blockquote>
and that it is your intention never to supply arguments that give rise
to exceptions (and therefore not to bother with code to detect and handle
the exceptions at run time).&nbsp; In this case, you might get some useful
checking from ESC/Java by creating a <tt>.spec</tt> file (see <a href="#5.1.2  Specification (.spec) files">section
5.1</a>) containing a declaration for <tt>add</tt> with the <tt>throws</tt>
clause removed and a <tt>requires</tt> pragma supplied in its place:
<blockquote><tt>&nbsp; /** </tt>...
<br><tt>&nbsp; &lt;esc> requires a != null &amp; b != null &amp;&amp; a.length
== b.length;</tt>
<br><tt>&nbsp; &lt;/esc></tt>
<br><tt>&nbsp; **/</tt>
<br><tt>&nbsp; public static int[] add(int[] a, int[] b);</tt></blockquote>
Alternatively, you might supply <tt>exsures</tt> pragmas specifying the
conditions under which the exceptions may be thrown:
<blockquote><tt>/** ...</tt>
<br><tt>&lt;esc> exsures (NullPointerException)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a == null | b == null;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exsures (IndexOutOfBoundsException)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a != null &amp; b !=
null &amp;&amp; a.length != b.length;</tt>
<br><tt>&lt;/esc></tt>
<br><tt>**/</tt>
<br><tt>public static int[] add(int[] a, int[] b);</tt></blockquote>
With this last specification, ESC/Java will consider execution paths in
which a call to <tt>add</tt> terminates exceptionally, but only if it cannot
verify the arguments are non-null and of equal length.
<h3>
<a NAME="4.6  IndexNegative warning"></a>4.6&nbsp; <tt>IndexNegative</tt>
warning</h3>
An <tt>IndexNegative</tt> warning warns that control may reach an array
access <tt><i>A</i>[<i>I</i>]</tt> when the value of the index <i><tt>I</tt></i>
is negative.&nbsp; (This condition would result in an <tt>IndexOutOfBoundsException</tt>
being thrown at run time [<i>JLS</i>, 11.5.1.1, 15.12.1].)
<h3>
<a NAME="4.7  IndexTooBig warning"></a>4.7&nbsp; <tt>IndexTooBig</tt> warning</h3>
An <tt>IndexTooBig</tt> warning warns that control may reach an array access
<tt><i>A</i>[<i>I</i>]</tt>
when <tt><i>I</i> >= <i>A</i>.length</tt>.&nbsp; (This condition would
result in an <tt>IndexOutOfBoundsException</tt> being thrown at run time
[<i>JLS</i>, 11.5.1.1, 15.12.1].)
<h3>
<a NAME="4.8  Invariant warning"></a>4.8&nbsp; <tt>Invariant</tt> warning</h3>
An <tt>Invariant</tt> warning warns that some object invariant may not
hold when control reaches a routine call, or that some object invariant
may not hold on exit from the current body.&nbsp; The warning is associated
with the <tt>invariant</tt> pragma that gives the potentially violated
object invariant.
<p><b>Tip:</b>&nbsp; An <tt>invariant</tt> warning is normally accompanied
by a partial counterexample context describing conditions under which,
so far as ESC/Java can determine, the indicated invariant might be violated,
for example:
<blockquote><tt>Possibly relevant items from the counterexample context:</tt>
<br><tt>&nbsp; </tt>...
<br><tt>&nbsp; \typeof(brokenObj&lt;3>) == \typeof(this)</tt>
<br><tt>&nbsp; brokenObj&lt;3> != this</tt>
<br><tt>&nbsp; brokenObj&lt;3> != null</tt>
<br><tt>&nbsp; </tt>...</blockquote>
In this display, some inflected form of the identifier <tt>BrokenObj</tt>
is used to name the object for which the invariant is broken, known as
the <i>broken object</i>.&nbsp; If, as in the example above, the displayed
formulas tell what the broken object is <i>not</i> equal to, but don't
tell what it <i>is</i> equal to, then the likely cause of the warning is
that the program modifies some field (call it <tt>f</tt>) of some object
(call it <tt>t</tt>) and that ESC/Java hypothesizes that this modification
might break the invariant for some other object, for example a hypothetical
object <tt>u</tt> such that <tt>u != t</tt> but <tt>u.f == t.f</tt>.&nbsp;
If the programmer's intention is that no such sharing of <tt>f</tt> fields
can occur, the programmer can communicate this intention to ESC/Java by
supplying an appropriate invariant near the declaration of the field, for
example:
<blockquote><tt>//@ invariant this.f.owner == this;</tt></blockquote>
For a more detailed example of the scenario outlined above, see the discussion
of the <tt>owner</tt> field and its use in <a href="#3.2.17 owner">section
3.2.17</a>.
<p><b>Fine points</b>
<p>The command-line option <tt>-plainwarning</tt> suppresses output of
partial counterexample contexts in <tt>Invariant</tt> warnings.&nbsp; This
may be useful in cases where ESC/Java's output is read by another program.
<p>In the partial counterexample context in an <tt>Invariant</tt> warning
for a constructor, the object being constructed may be named by an inflected
form of the identifier <tt>RES</tt>.&nbsp; For example, in the <tt>ObjStack</tt>
example from <a href="#3.2.17 owner">section 3.2.17</a>, we wrote:
<blockquote>Without the <tt>set</tt> pragma, ESC/Java will generate a warning
that the constructor fails to establish the invariant <tt>a.owner == this</tt>.</blockquote>
The warning might be something like:
<blockquote><tt>ObjStack.java:12: Warning: Possible violation of object
invariant (Invariant)</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; ^</tt>
<br><tt>Associated declaration is "ObjStack.java", line 7, col 6:</tt>
<br><tt>&nbsp; //@ invariant a.owner == this;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</tt>
<br><tt>Possibly relevant items from the counterexample context:</tt>
<br><tt>&nbsp; brokenObj&lt;1> == RES:9.13</tt>
<br><tt>(brokenObj* refers to the object for which the invariant is broken.)</tt></blockquote>
Here, the equality <tt>brokenObj&lt;1> == RES:9.13</tt> indicates that
the object whose invariant may be violated is the object being constructed.
<h3>
<a NAME="4.9  LoopInv warning"></a>4.9&nbsp; <tt>LoopInv</tt> warning</h3>
A <tt>LoopInv</tt> warning warns that some loop invariant may not hold
at the start of an iteration of a loop (including an iteration in which
the&nbsp;&nbsp; The pragma is associated with the <tt>loop_invariant</tt>
pragma that gives the potentially violated loop invariant.&nbsp; (For more
details of ESC/Java's treatment of loop invariants, see sections <a href="#2.4.3  loop_invariant pragma">2.4.3</a>
and
<a href="#C.0.1  Loops">C.0.1</a>.)
<h3>
<a NAME="4.10  NegSize warning"></a>4.10&nbsp; <tt>NegSize</tt> warning</h3>
A <tt>NegSize</tt> warning warns of a possible attempt to allocate an array
of negative length.&nbsp; (This condition would result in a <tt>NegativeArraySizeException</tt>
being thrown at run time [<i>JLS</i>, 15.9].)
<h3>
<a NAME="4.11  NonNull warning"></a>4.11&nbsp; <tt>NonNull</tt> warning</h3>
A <tt>NonNull</tt> warning warns of a possible attempt to assign the value
<tt>null</tt>
to a variable whose declaration is modified by a <tt>non_null</tt> pragma,
or to call a routine with an actual parameter value of <tt>null</tt> when
the declaration of the corresponding formal parameter is modified by (or
inherits) a <tt>non_null</tt> pragma.&nbsp; The warning is associated with
the <tt>non_null</tt> pragma that is potentially violated.
<p><b>Tips:</b>&nbsp; If the right hand side of the assignment indeed never
evaluates to <tt>null</tt>, you must somehow communicate the reason to
ESC/Java.&nbsp; For some ideas about this, see the tips given in connection
with <tt>Null</tt> warnings in <a href="#4.13  Null warning">section 4.13</a>.&nbsp;
Alternatively, it may be that the <tt>non_null</tt> pragma associated with
the warning is too strong and should be replaced by an annotation that
only requires the affected field or variable to be non-null under certain
conditions.&nbsp; See also the comments in <a href="#2.4.0  non_null pragma">section
2.4.0</a> about <tt>non_null</tt> vs. <tt>invariant</tt> and <tt>requires</tt>
pragmas.
<h3>
<a NAME="4.12  NonNullInit warning"></a>4.12&nbsp; <tt>NonNullInit</tt>
warning</h3>
A <tt>NonNullInit</tt> warning warns that a constructor may fail to establish
a non-null value for an instance field of the constructed object when the
declaration of that instance field is modified by a <tt>non_null</tt> pragma.&nbsp;
The warning is associated with the <tt>non_null</tt> pragma that is potentially
violated.
<h3>
<a NAME="4.13  Null warning"></a>4.13&nbsp; <tt>Null</tt> warning</h3>
A <tt>Null</tt> warning warns of a possible attempt to dereference <tt>null</tt>,
for example, by field access <tt><i>O</i>.<i>f</i></tt>, an array access
<tt><i>O</i>[<i>i</i>]</tt>,
a method call <tt><i>O</i>.<i>m</i>(</tt>...<tt>)</tt>, a <tt>synchronized</tt>
statement <tt>synchronized (O) </tt>..., or a <tt>throw</tt> statement
<tt>throw
<i>O</i></tt>,
where <i><tt>O</tt></i> evaluates to
<tt>null</tt>.&nbsp; (Any of these
would result in a <tt>NullPointerException</tt> being thrown at run time
[<i>JLS</i>, 11.5.1.1, 14.17, 15.10, 15.11, 15.12].)
<blockquote><font size=-1><b>Remark:</b>&nbsp; <i>JLS</i> doesn't say that
throwing <tt>null</tt> results in a <tt>NullPointerException</tt>, but
experimentation with<tt> javac(5)</tt> and <tt>java(5)</tt> reveals that
it does.</font></blockquote>
<b>Tips:</b>&nbsp; If the expression <i><tt>O</tt></i> is a formal parameter,
consider adding a <tt>non_null</tt> pragma to the parameter's declaration
or supplying a <tt>requires</tt> pragma stating that the parameter must
be non-null under certain conditions.&nbsp; If <i><tt>O</tt></i> is a field
access
<tt><i>P</i>.<i>g</i></tt>, consider adding a <tt>non_null</tt>
pragma to <i><tt>g</tt></i>'s declaration, supplying an <tt>invariant</tt>
pragma stating that <i><tt>g</tt></i> is non-null under certain conditions,
or (if <i><tt>P</tt></i> involves parameters of the current routine) supplying
an appropriate <tt>requires</tt> pragma.&nbsp; If <i><tt>O</tt></i> is
an array access, consider supplying a
<tt>requires</tt> or <tt>invariant</tt>
pragma using <tt>\nonnullelements</tt> (see section 3.2.12).&nbsp; If <i><tt>O</tt></i>
is a method call, consider annotating the called method with <tt>ensures
\result != null</tt> or <tt>ensures
<i>Q</i> ==> \result != null</tt> for
some appropriate condition <i><tt>Q</tt></i>. See the second example in
<a href="#2.6.2  Examples using ghost variables">section
2.6.2</a> for an example of pragmas guaranteeing that an element extracted
from a container will be non-null.
<h3>
<a NAME="4.14  OwnerNull warning"></a>4.14&nbsp; <tt>OwnerNull</tt> warning</h3>
As described in <a href="#3.2.17 owner">section 3.2.17</a>, every constructor
has the implicit postcondition <tt>this.owner == null</tt>.&nbsp; An <tt>OwnerNull</tt>
warning warns that a constructor may return an object whose <tt>owner</tt>
field is non-null.
<h3>
<a NAME="4.15  Post warning"></a>4.15&nbsp; <tt>Post</tt> warning</h3>
A <tt>Post</tt> warning warns that a routine body may fail to establish
some normal postcondition (on terminating normally) or some exceptional
postcondition (when terminating by throwing an exception of a relevant
type).&nbsp; The warning is associated with the <tt>ensures</tt>, <tt>exsures</tt>,
<tt>also_ensures</tt>,
or <tt>also_exsures</tt> pragma that gives the potentially violated postcondition.
<p><b>Tips:</b>&nbsp; If a <tt>Post</tt> warning seems mysterious, the
problem might be that the programmer intended to refer to the post-state
value of some field, but forgot to include a <tt>modifies</tt> or <tt>also_modifies</tt>
pragma naming that field as a target.&nbsp; See <a href="#2.3.3  A note on the interaction of modifies and \old">section
2.3.3</a> for further discussion of this point.&nbsp; It can also be useful
to examine the execution trace that accompanies the warning.&nbsp; For
example, you might see that the trace reported be ESC/Java involves execution
of a <tt>return</tt> statement in the middle of the method that you had
overlooked.
<h3>
<a NAME="4.16  Pre warning"></a>4.16&nbsp; <tt>Pre</tt> warning</h3>
A <tt>Pre</tt> warning warns that control may reach a routine call when
some precondition of the routine does not hold.&nbsp; The warning is associated
with the <tt>requires</tt> pragma that gives the potentially violated precondition.
<h3>
<a NAME="4.17  Race warning"></a>4.17&nbsp; <tt>Race</tt> warning</h3>
A <tt>Race</tt> warning warns of a possible attempt to access a monitored
field while not holding the requisite lock(s).&nbsp; The warning is associated
with the <tt>monitored</tt> or <tt>monitored_by</tt> pragma giving the
lock(s) that should be held.
<p><b>Bug/limitation:</b>&nbsp; If there are multiple <tt>monitored</tt>
and/or <tt>monitored_by</tt> pragmas for the same field <i><tt>f</tt></i>,
a <tt>Race</tt> warning for an access to <i><tt>f</tt></i> will mention
only one of these pragmas, and perhaps not the most relevant one.
<h3>
<a NAME="4.18  Reachable warning"></a>4.18&nbsp; <tt>Reachable</tt> warning</h3>
A <tt>Reachable</tt> warning warns that control may reach an <tt>unreachable</tt>
pragma.
<h3>
<a NAME="4.19  Unreadable warning"></a>4.19&nbsp; <tt>Unreadable</tt> warning</h3>
An <tt>Unreadable</tt> warning warns that control may reach a read access
to a variable when the expression in a <tt>readable_if</tt> pragma modifying
the variable's declaration is false.&nbsp; The warning is associated with
the <tt>readable_if</tt> pragma.
<h3>
<a NAME="4.20  Uninit warning"></a>4.20&nbsp; <tt>Uninit</tt> warning</h3>
An <tt>Uninit</tt> warning warns that control may reach a read access to
a local variable before execution of any assignment to the variable other
than an initializer in a declaration modified by an <tt>uninitialized</tt>
pragma.&nbsp; The warning is associated with the <tt>uninitialized</tt>
pragma.
<h3>
<a NAME="4.21  ZeroDiv warning"></a>4.21&nbsp; <tt>ZeroDiv</tt> warning</h3>
A <tt>ZeroDiv</tt> warning warns of a possible attempt to apply the integer
division (<tt>/</tt>) or remainder (<tt>%</tt>) operator with zero as the
divisor.&nbsp; (This condition would result in an <tt>ArithmeticException</tt>
being thrown at run time [<i>JLS</i>, 15.16.2, 15.16.3].)
<hr WIDTH="100%">
<h2>
<a NAME="5  Command-line options and environment variables"></a>5&nbsp;
Command-line options and environment variables</h2>
The operation of ESC/Java is controlled by a variety of command-line options
and environment variables.&nbsp; The primary source of information on these
is the <tt>escjava(1)</tt> man page included with the ESC/Java release
(see <a href="#Appendix B:  Installing and using ESC/Java at your site">appendix
B</a>).&nbsp; In this section, we describe a small number of options that
are of particular importance, or that seem to merit more extensive descriptions
than those on the man page.
<h3>
<a NAME="5.0  -suggest"></a>5.0&nbsp; <tt>-suggest</tt></h3>
The <tt>-suggest</tt> command-line option causes ESC/Java to accompany
certain of its warning messages with suggestions for pragmas that may eliminate
those warnings.
<p><b>Examples</b>
<p>Running ESC/Java with the command line
<blockquote><tt>escjava -suggest Bag.java</tt></blockquote>
on the version of <tt>Bag.java</tt> in <a href="#0.0  Scene 0:  We write a class declaration.">section
0.0</a> will produce such suggestions as
<blockquote><tt>Bag.java:6: Warning: Possible null dereference (Null)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; n = input.length;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>Suggestion [6,13]: perhaps declare parameter 'input' at 5,12 in
Bag.java with 'non_null'</tt></blockquote>
Running ESC/Java with the <tt>-suggest</tt> option on the file <tt>T.java</tt>
from <a href="#3.2.4  Examples involving \TYPE, \type, \typeof, \elemtype, and <:">section
3.2.4</a> will produce the following warning and suggestion:
<blockquote><tt>T.java:5: Warning: Type of right-hand side possibly not
a subtype of array element type (ArrayStore)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a[i] = x;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</tt>
<br><tt>Suggestion [5,9]: perhaps declare method 'storeObject' at 4,14
in T.java with 'requires \elemtype(\typeof(a)) == \type(T);'</tt></blockquote>
Running ESC/Java with the <tt>-suggest</tt> option on the file <tt>ObjStack.java</tt>
from <a href="#3.2.17 owner">section 3.2.17</a> will produce the following
warning and suggestion:
<blockquote><tt>ObjStack.java:16: Warning: Possible violation of object
invariant (Invariant)</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; ^</tt>
<br><tt>Associated declaration is "ObjStack.java", line 6, col 6:</tt>
<br><tt>&nbsp; //@ invariant (\forall int i; n &lt;= i &amp; i &lt; 10
==> a[i] == null);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</tt>
<br><tt>Possibly relevant items from the counterexample context:</tt>
<br><tt>&nbsp; (0 &lt;= (brokenObj&lt;2>).(n:15.6))</tt>
<br><tt>&nbsp; </tt>...
<br><tt>(brokenObj* refers to the object for which the invariant is broken.)</tt>
<p><tt>Suggestion [16,2]: perhaps declare instance invariant 'invariant
this.a.owner == this;' in class ObjStack (near associated declaration at
"ObjStack.java", line 6, col 6)</tt></blockquote>
<b>Fine points</b>
<p>ESC/Java does not supply suggestions for all warnings, and the suggestions
that it does supply are heuristically chosen and may be incorrect.&nbsp;
For example, if the contents of file <tt>C.java</tt> are
<blockquote><tt><font size=-2>&nbsp;1:&nbsp; </font>class C {</tt>
<br><tt><font size=-2>&nbsp;2:</font></tt>
<br><tt><font size=-2>&nbsp;3:&nbsp;&nbsp;</font>&nbsp; int n;</tt>
<br><tt><font size=-2>&nbsp;4:</font></tt>
<br><tt><font size=-2>&nbsp;5:&nbsp;&nbsp;</font>&nbsp; static int m(C
a, C b) {</tt>
<br><tt><font size=-2>&nbsp;6:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; if
(a != null) {</tt>
<br><tt><font size=-2>&nbsp;7:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return a.n;</tt>
<br><tt><font size=-2>&nbsp;8:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; } else
{</tt>
<br><tt><font size=-2>&nbsp;9:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return b.n;</tt>
<br><tt><font size=-2>10:&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt><font size=-2>11:&nbsp;&nbsp;</font>&nbsp; }</tt>
<br><tt><font size=-2>12:&nbsp; </font>}</tt></blockquote>
then the command <tt>escjava -suggest C.java</tt> will give a warning about
and possible null dereference on line 9, accompanied by the suggestion:
<blockquote><tt>Suggestion [9,14]: perhaps declare parameter 'b' at 5,22
in C.java with 'non_null'</tt></blockquote>
It might actually be better to declare the method <tt>m</tt> with the precondition
<blockquote><tt>//@ requires a != null | b != null;</tt></blockquote>
since it might be the intention of the programmer to support callers that
meet only this precondition and not necessarily the more stringent condition
that <tt>b</tt> always be non-null.
<p>Despite its limitations, the <tt>-suggest</tt> option can be of considerable
help to users in paring down the initial batch of mostly-spurious warnings
that ESC/Java typically produces when it is first run on a body of unannotated
code.&nbsp; (A project currently under way at Compaq SRC is exploring automated
techniques for inferring ESC/Java annotations [<a href="#[FL00]">FL00</a>,
<a href="#[FJLxx]">FJLxx</a>].)
<h3>
<a NAME="5.1  Specification (.spec) files and the ESC/Java's class path"></a>5.1&nbsp;
Specification (<tt>.spec</tt>) files and the ESC/Java's class path</h3>
This section discusses the algorithm that ESC/Java uses to find declarations
of classes, and ways in which the user can control that algorithm.
<p>In order to check the routine bodies of a class <i><tt>C</tt></i>, ESC/Java
may need various information about some other type (class or interface)
<i><tt>T</tt></i>.&nbsp;
This information, which we call the <i>specification</i> of <i><tt>T</tt></i>,
may include both information introduced by pragmas (such as <tt>invariant</tt>
and <tt>requires</tt>) and information from the Java language (such as
routine signatures and types of fields), but does not include routine bodies.
<p>If ESC/Java needs the specification for a type <i><tt>T</tt></i> and
can find only a binary (<tt>.class</tt>) file and no source file for <i><tt>T</tt></i>,
then it can produce a simple specification based on the signature and type
information included in the binary file.&nbsp; ESC/Java can also obtain
specifications from specification (<tt>.spec</tt>) files (see <a href="#5.1.2  Specification (.spec) files">section
5.1.2</a>).
<h4>
<a NAME="5.1.0  File reading modes"></a>5.1.0&nbsp; File reading modes</h4>
ESC/Java has two <i>modes</i> for reading files:&nbsp; <i>full mode</i>
and <i>spec-only mode</i>.&nbsp; In order for ESC/Java to check the routine
bodies in a file, it must read the file in full mode.&nbsp; When ESC/Java
reads a file in spec-only mode, it only obtains specifications that can
be used to check routine bodies in other files.&nbsp; ESC/Java can read
<tt>.java</tt>
files in either mode.&nbsp; It can read <tt>.class</tt> files in spec-only
mode, but not in full mode.
<p>When ESC/Java reads a source file in spec-only mode, it performs very
limited processing--in particular, very liberal syntactic error-checking--on
the bodies of routines.&nbsp; We do not specify here the exact degree to
which the error-checking is liberalized, except to state that where a routine
body would normally be expected, ESC/Java will accept (at least) any of
the following when reading a source file in spec-only mode:
<blockquote>a semicolon&nbsp; <tt>;</tt>&nbsp; (as in the Java syntax for
an <tt>abstract</tt> method declaration).
<p>an empty body&nbsp; <tt>{ }</tt>&nbsp; (note that no <tt>return</tt>
statement is required, even for a non-<tt>void</tt> method).
<p>a method body consisting of legal Java code legally annotated by ESC/Java
pragmas (that is, a body that ESC/Java would accept if it were reading
the file in full mode).</blockquote>

<h4>
<a NAME="5.1.1  The ESC/Java class path (-classpath, CLASSPATH, -bootcla"></a>5.1.1&nbsp;
The ESC/Java class path (<tt>-classpath</tt>, <tt>CLASSPATH</tt>, <tt>-bootclasspath</tt>)</h4>
Like the Java compiler (<tt>javac(5)</tt>), ESC/Java uses a class path
to look for declarations of types (classes and interfaces) that are not
declared in files named on the command line.&nbsp; For a description of
how ESC/Java uses the class path, see <a href="#5.1.3  How ESC/Java decides which files to read and in which mo">section
5.1.3</a> below.
<p>The (full) class path is the concatenation of two parts: <tt>classpath</tt>
and <tt>bootclasspath</tt>, where <tt>classpath</tt> is
<ul>
<li>
the argument of the <tt>-classpath</tt> command-line option, if any, on
the command line, or else</li>

<li>
the value of the <tt>CLASSPATH</tt> environment variable if one has been
set, or else</li>

<li>
a default value</li>
</ul>
and <tt>bootclasspath</tt> is
<ul>
<li>
the argument of the <tt>-bootclasspath</tt> command-line option, if any,
on the command line, or else</li>

<li>
a default value.</li>
</ul>
The default values of <tt>classpath</tt> and<tt> bootclasspath</tt> are
subject to change.&nbsp; At the time of writing, the default<tt> classpath</tt>
is "<tt>.</tt>" and the default <tt>bootclasspath</tt> includes a directory
of selected <tt>.spec</tt> files (see <a href="#5.1.2  Specification (.spec) files">section
5.1.2</a>) for selected library classes and interaces together with directories
for the normal Java system libraries (the same default versions used by
<tt>srcjava(1)</tt>).
<p><b>Fine point</b>
<p>If a command line contains multiple occurrences of the <tt>-classpath</tt>
option, as in
<blockquote><tt>escjava</tt> <tt>-classpath <i>P1</i> -classpath
<i>P2
sourcefiles</i></tt></blockquote>
only the last one (<i><tt>P2</tt></i> in the example) is used.&nbsp; The
same applies for multiple occurrences of
<tt>-bootclasspath</tt>.
<p><b>Tip:</b>&nbsp; The <tt>-v</tt> (verbose) command-line option makes
ESC/Java output various information including the full classpath.&nbsp;
Thus, you can learn the current default value of either <tt>classpath</tt>
or
<tt>bootclasspath</tt> at your site by setting the other to a known
value and looking for the other in the output produced with <tt>-v</tt>.&nbsp;
For example, you can learn the value of <tt>bootclasspath</tt> by typing
<blockquote><tt>escjava -classpath xxx -v | grep classpath</tt></blockquote>
on Unix systems or
<blockquote><tt>escjava -classpath xxx -v | find "classpath"</tt></blockquote>
on Windows systems.
<h4>
<a NAME="5.1.2  Specification (.spec) files"></a>5.1.2&nbsp; Specification
(<tt>.spec</tt>) files</h4>
There are times when the specification that ESC/Java can derive automatically
from a <tt>.class</tt> file is inadequate, but when it is inconvenient
or impossible for the user to add pragmas to the <tt>.java</tt> source
file.&nbsp; (For example, the user's file system may not contain a copy
of the <tt>.java</tt> file.)&nbsp;&nbsp; In such situations, the user can
supply the needed pragmas in ESC/Java specification (<tt>.spec</tt>) files,
which are similar to <tt>.java</tt> source files except that (1) ESC/Java
always uses spec-only mode when reading a specification file (so routine
bodies may always be omitted from specification files) and (2) a specification
file <tt><i>T</i>.spec</tt> may contain a declaration of only the single
type <i><tt>T</tt></i>.
<p>Since Java compilers do not look for files with extension <tt>.spec</tt>,
one can use the same class path for the Java compiler as for ESC/Java with
no danger of inadvertently pointing the compiler at a crippled source file.
<p><b>Caveat:</b>&nbsp; When ESC/Java reads a <tt>.spec</tt> file, it does
not check that the contents of that file are in any way consistent with
those of a <tt>.java</tt> or <tt>.class</tt> file that a compiler might
find on the same class path.
<h4>
<a NAME="5.1.3  How ESC/Java decides which files to read and in which mo"></a>5.1.3&nbsp;
How ESC/Java decides which files to read and in which modes</h4>
In this section we describe how ESC/Java decides which files to read and
which modes to read them in.&nbsp; The short version of the story is that
ESC/Java&nbsp; uses its class path about the same way that a Java compiler
does, except that ESC/Java prefers <tt>.spec</tt> files over <tt>.java</tt>
files.&nbsp; See the fine points below for a more complete (but not completely
complete) story.
<p><b>Fine points</b>
<p><b>[Note:</b>&nbsp; Some of the behaviors in described in the next few
paragraphs change when ESC/Java is run with the <tt>-depend</tt> command-line
option.&nbsp; See <a href="#5.1.4  -depend">section 5.1.4</a> for details.]
<p>For each filename <i><tt>F</tt></i> on the command line, ESC/Java looks
for the exact file <i><tt>F</tt></i> (with relative path names evaluated
from the current working directory). If ESC/Java can't find file <i><tt>F</tt></i>,
it issues an error message and goes on to look for the next file, if any.
If ESC/Java finds file <i><tt>F</tt></i>, then it reads file <i><tt>F</tt></i>
in full mode (as a Java source file, regardless of the filename extension),
storing the type declarations it reads in an internal cache.
<p>Once ESC/Java has read and cached the type declarations from files named
on the command line, it may then need the declarations of additional types
used (directly or indirectly) by the types already read.&nbsp; When ESC/Java
needs the declaration of a type <tt><i>P</i>.<i>T</i></tt>, it can find
it in any of the following places:
<blockquote>(0)&nbsp; already in ESC/Java's internal cache.
<p>(1)&nbsp; in a file named <tt><i>C</i>/<i>P'</i>/<i>T</i>.spec</tt>,
where <i><tt>P'</tt></i> is the relative path name whose directory-path
components are the simple-name components of <i><tt>P</tt></i> taken in
order (e.g., on Unix, <i><tt>P'</tt></i> would be the result of replacing
dots in <i><tt>P</tt></i> with slashes), and <i><tt>C</tt></i> is the first
directory on the class path (see <a href="#5.1.1  The ESC/Java class path (-classpath, CLASSPATH, -bootcla">section
5.1.1</a>) such that file <tt><i>C</i>/<i>P'</i>/<i>T</i>.spec</tt> exists.
<p>(2)&nbsp; in a file named <tt><i>C</i>/<i>P'</i>/<i>T</i>.java</tt>,
where <i><tt>P'</tt></i> is as in (1) above and <i><tt>C</tt></i> is the
first directory on the class path such that file <tt><i>C</i>/<i>P'</i>/<i>T</i>.java</tt>
exists.
<p>(3)&nbsp; in a file named <tt><i>C</i>/<i>P'</i>/<i>T</i>.class</tt>,
where <i><tt>P'</tt></i> is as in (1) above and <i><tt>C</tt></i> is the
first directory on the class path such that file <tt><i>C</i>/<i>P'</i>/<i>T</i>.class</tt>
exists.
<p>(4)&nbsp; in a <tt>.java</tt> file found by finding a file <tt><i>C</i>/<i>P'</i>/<i>T</i>.class</tt>
as in (3) above and reading the internal field that names the source file
from which it was compiled.</blockquote>
(If names of <tt>.jar</tt> or <tt>.zip</tt> files occur as class path components,
ESC/Java acts is if the class path included directories holding the expanded
contents of those files.)
<p>ESC/Java's ranking of these alternatives is, from most favored to least
favored: 0, 1, 2, 4, 3.&nbsp; Note that this means that, for example
<tt><i>C1</i>/<i>P'</i>/<i>T</i>.spec</tt>
is favored over <tt><i>C2</i>/<i>P'</i>/<i>T</i>.java</tt> even if <i><tt>C2</tt></i>
precedes <i><tt>C1</tt></i> in the class path.&nbsp; If ESC/Java doesn't
have the declaration already in its cache and needs to read it from a file,
it will read the file in spec-only mode.
<p>Whenever ESC/Java reads a <tt>.java</tt> file in order to get the declaration
of a type <i><tt>T</tt></i>, it will also read and cache any other type
declarations in that file.
<blockquote><font size=-1><b>Remark:</b>&nbsp; In accordance&nbsp; with
[<i>JLS</i>, 7.6], implementations may forbid a file <tt><i>T</i>.java</tt>
from declaring a type <i><tt>U</tt></i> other than <i><tt>T</tt></i>, when
(1) the type <i><tt>U</tt></i> is referred to by code in other compilation
units of the package in which the type <i><tt>U</tt></i> is declared, or
(2) the type <i><tt>U</tt></i> is declared <tt>public</tt>.&nbsp; ESC/Java
does not enforce this restriction.&nbsp; Note, however, that when the restriction
is obeyed,&nbsp; alternative (4) above will never arise.</font></blockquote>
During the process just described, various errors may occur.&nbsp; For
example, a file may not contain a declaration of the class suggested by
the file name.&nbsp; We do not attempt here a complete enumeration of these
conditions.&nbsp; Also, it is beyond the scope of this manual to describe
exactly which type declarations ESC/Java looks for in order to check a
given type.
<h4>
<a NAME="5.1.4  -depend"></a>5.1.4&nbsp; <tt>-depend</tt></h4>
[Note:&nbsp; If you are not an ESC/Java wizard, and don't aspire to be,
you should probably skip this section and never use <tt>-depend</tt>.]
<p>The <tt>-depend</tt> command-line option causes ESC/Java to change its
behavior from that described above in the following ways:
<ul>
<li>
ESC/Java will prefer to read <tt>.java</tt> files rather than <tt>.spec</tt>
files.&nbsp; That is, the ranking given in <a href="#5.1.3  How ESC/Java decides which files to read and in which mo">section
5.1.3</a> switches from 0, 1, 2, 4, 3 to 0, 2, 4, 1, 3.</li>

<li>
When reading a <tt>.java</tt> file (alternative 2 or 4), then ESC/Java
will read the file in full mode, rather than spec-only mode.&nbsp; This
is in contrast to the normal behavior, where only <tt>.java</tt> files
named on the command line are read in full mode.</li>

<li>
Instead of checking only classes declared in files named on the command
line, ESC/Java will also check the classes that those classes depend on
(including indirectly) provided that finds their declarations in <tt>.java</tt>
files.</li>
</ul>
<b>Caveat:</b>&nbsp; As currently implemented the <tt>-depend</tt> option
is likely to give unsatisfactory results in cases where both a <tt>.spec</tt>
file and a <tt>.java</tt> file declaring the same class can be found on
the class path.&nbsp; When run with <tt>-depend</tt> ESC/Java will prefer
to read the class declaration from the <tt>.java</tt> file so that it can
read in full mode and check the class's routine bodies.&nbsp; On the other
hand, successful checking of clients of the class will likely require use
of pragmas found only in the (ignored) <tt>.spec</tt> file and not in the
<tt>.java</tt>
file.
<hr WIDTH="100%">
<h2>
<a NAME="6  Java language support and limitations"></a>6&nbsp; Java language
support and limitations</h2>
The&nbsp; <i>Java</i><sup><font size=-2>TM</font></sup><i> Language Specification</i>
[<i><a href="#[JLS]">JLS</a></i>] defines the Java 1.0 language.&nbsp;
The ``Inner Classes Specification'' [<i><a href="#[ICS]">ICS</a></i>] specifies
the additional language features supported in Java 1.1 and Java 1.2.&nbsp;
The current version of ESC/Java accepts all Java language features described
in [<i><a href="#[JLS]">JLS</a></i>]; it also accepts all Java language
features described in [<i><a href="#[ICS]">ICS</a></i>] with the following
two exceptions:
<ul>
<li>
When ESC/Java reads a class <i><tt>C</tt></i> from file <tt><i>C</i>.class</tt>,
and one of <tt>C</tt>'s members is a class <tt>C.D</tt>, ESC/Java will
look for the file <tt>C$D.class</tt> only in the directory where it found
<tt>C.class</tt>.</li>

<li>
ESC/Java will not check any routine body that mentions an anonymous class.</li>
</ul>
Java 1.2 includes the same language features as Java 1.1, but differs from
1.0 and 1.1 in the versions of the standard libraries that it includes.&nbsp;
The current release of ESC/Java includes <tt>.spec</tt> files for a subset
of the standard libraries.&nbsp; This subset is far from complete, but
the <tt>.spec</tt> files that are included in the release are intended
to correspond to classes and interfaces that are standard for Java 1.2.
<p><b>Fine point</b>
<p>While ESC/Java accepts almost all of the language constructs described
in [<i><a href="#[JLS]">JLS</a></i>] and [<i><a href="#[ICS]">ICS</a></i>],
the semantics ESC/Java ascribes to those constructs differs in numerous
details--including, but not limited to, those mentioned in <a href="#Appendix C:  Sources of unsoundness and incompleteness ESC/Java">appendix
C</a> and other parts of this manual--from the semantics specified in [<i><a href="#[JLS]">JLS</a></i>]
and [<i><a href="#[ICS]">ICS</a></i>].&nbsp; Likewise the annotations in
the <tt>.spec</tt> files available in the ESC/Java release may fail for
various reasons to capture the semantics of the actual JDK libraries (see
<a href="#C.0.10  Class paths and .spec files">section
C.0.10</a>).
<br>
<hr WIDTH="100%">
<h2>
<a NAME="Appendix A:  Overview of how ESC/Java works"></a>Appendix A:&nbsp;
Overview of how ESC/Java works</h2>
This appendix gives a very rough sketch of ESC/Java's internal operation.
<p>The operation of ESC/Java consists of the following steps:
<p>First, ESC/Java loads, parses, and type checks the files named on the
command line, as well as any other files needed because their contents
are directly or indirectly used by files name on the command line.&nbsp;
(<a href="#5.1  Specification (.spec) files and the ESC/Java's class path">Section
5.1</a> describes where ESC/Java looks for files not named on the command
line.)
<p>Next, for each class whose routine bodies are to be checked, ESC/Java
generates a type-specific <i>background predicate</i> encoding such information
as subtype relations, types of fields, etc. in the class to be checked
and the classes and interfaces it uses.
<p>Next, ESC/Java translates each routine to be checked into a logical
formula called a <i>verification condition</i> (<i>VC</i>).&nbsp; As an
intermediate step in this translation, ESC/Java produces a command in an
intermediate language [<a href="#[LSS99]">LSS99</a>] based on Dijkstra's
guarded commands.&nbsp; The intermediate language includes commands of
the form
<tt>assert
<i>E</i></tt>, where <i><tt>E</tt></i> is a boolean
expression of the language.&nbsp; An execution of a command is said to
``go wrong'' if control reaches subcommand of the form <tt>assert <i>E</i></tt>
when
<i><tt>E</tt></i> is false.&nbsp; Ideally, when a routine <i><tt>R</tt></i>
is translated into a command
<i><tt>C</tt></i> and thence to a verification
condition <i><tt>V</tt></i>, the following three conditions should be equivalent:
<blockquote>(1) There is no way that <i><tt>R</tt></i> can be invoked from
a state satisfying its specified preconditions and then behave erroneously
by, for example, dereferencing <tt>null</tt>, violating an
<tt>assert</tt>
pragma, terminating in a state that violates its specified postconditions,
etc.</blockquote>

<blockquote>(2) There is no execution of <i><tt>C</tt></i> that starts
in a state satisfying the background predicate of <i><tt>R</tt></i>'s class
and then goes wrong.
<p>(3) <i><tt>V</tt></i> is a logical consequence of the background predicate.</blockquote>
In practice, the translation is incomplete and unsound, so there may be
semantic discrepancies between <i><tt>R</tt></i>, <i><tt>C</tt></i>, and
<i><tt>V.</tt></i>
<p>Finally, ESC/Java invokes the Simplify (<tt>Simplify(1)</tt>) theorem
prover, asking it to prove each body's verification given the appropriate
background predicate.&nbsp; If an attempted proof succeeds (or if Simplify
exceeds specified resource limits in attempting the proof, or if ESC/Java
exceeds specified resource limits generating the verification condition),
then ESC/Java reports no warnings for the body.&nbsp; If the proof fails
(other than by exceeding resource limits), Simplify produces a potential
<i>counterexample
context</i>, from which ESC/Java derives a warning message.
<p><b>Fine points</b>
<p>The command-line option <tt>-counterexample</tt> makes ESC/Java print
selected parts of each counterexample, sugared into a somewhat Java-like
syntax.&nbsp; For example, in section 3.2.17, we gave an example file <tt>D.java</tt>
and said of ESC/Java's output: ``There is no way to tell from this message
whether ESC/Java is warning about the case where
<tt>a</tt> has nonnegative
<tt>x</tt>
and <tt>y</tt> fields and <tt>b</tt> has negative
<tt>x</tt> and <tt>y</tt>
fields, or about the case where
<tt>a</tt>'s fields are negative and <tt>b</tt>'s
are nonnegative.''&nbsp; If we ran ESC/Java on
<tt>D.java</tt> with <tt>-counterexample</tt>
option, the output would include something like:
<blockquote><tt>Counterexample context:</tt>
<br>...
<br><tt>&nbsp;&nbsp;&nbsp; ((y:7.11).(a@pre:3.6) &lt; 0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; (0 &lt;= (x:7.6).(b:3.9))</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ((y:7.11).(b:3.9) &lt; 0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; (0 &lt;= (x:7.6).(a:3.6&lt;1>))</tt>
<br>...</blockquote>
from which one can infer that ESC/Java happens to be reporting the former
case.&nbsp; As you may also infer from the excerpt above, the <tt>-counterexample</tt>
option is intended mainly for expert users; to give further details about
deciphering counterexample contexts (for example, the meanings of the inflections
<tt>@pre:3.6</tt>
and <tt>:3.6&lt;1></tt> on the field name <tt>a</tt>) is beyond the scope
of this manual.
<hr WIDTH="100%">
<h2>
<a NAME="Appendix B:  Installing and using ESC/Java at your site"></a>Appendix
B:&nbsp; Installing and using ESC/Java at your site</h2>
The ESC/Java group maintains a web site at <tt><a href="http://research.compaq.com/SRC/esc/">http://research.compaq.com/SRC/esc/</a></tt>.&nbsp;
The tool may be downloaded from this site for educational and research
use.
<p>After you download the ESC/Java release according to the instructions
on the web site, all files in the release will be in a single directory
(chosen by you) at your site.&nbsp; We will write ``<i>escjavaRoot''
</i>to
denote this directory.
<p>Among the contents of <i>escjavaRoot</i> are the following files and
subdirectories:
<ul>
<li>
<i>escjavaRoot</i><tt>/bin/escjava</tt> (on Unix) or <i>escjavaRoot</i><tt>\bin\escjava.bat</tt>
(on Windows) contains the execution script for ESC/Java.&nbsp; The web
site includes instructions for setting things up so that a command of the
form ``<tt>escjava</tt> [<i>options</i>] <i>sourcefiles</i>'' will run
this script.</li>

<li>
<i>escjavaRoot</i><tt>/doc/man1/escjava.1</tt> contains the Unix <tt>man(1)</tt>
page for ESC/Java.</li>

<li>
<i>escjavaRoot</i><tt>/doc/escjava.html</tt> contains the man page for
ESC/Java in HTML format.</li>

<li>
<i>escjavaRoot</i><tt>/examples/</tt> contains some examples of source
code on which to run ESC/Java, including the <tt>Bag</tt> example from
<a href="#0  An illustrative example of using ESC/Java">section
0</a>.&nbsp; Subdirectories named after sections of this manual contain
examples taken from or pertinent to those sections.</li>

<li>
<i>escjavaRoot</i><tt>/lib/specs/</tt> contains <tt>.spec</tt> files corresponding
to selected JDK library files.&nbsp; (<b>Note:</b>&nbsp; The specifications
in these <tt>.spec</tt> files may not always match the actual semantics
of the corresponding library files;&nbsp; see <a href="#C.0.10  Class paths and .spec files">section
C.0.10.</a>)</li>
</ul>
If you have a question, comment, or bug report concerning ESC/Java or this
manual, you should start by checking the FAQ on the ESC/Java web site.&nbsp;
If the FAQ does not address the issue adequately, you can email the ESC/Java
group at <tt>&lt;escjava@research.compaq.com></tt>.&nbsp; You can also
use this address to let us know if you have produced <tt>.spec</tt> files
for additional JDK library files and would like to share them.&nbsp; (<b>Note:
</b>Restrictions
may apply in distributing annotated or modified versions of Sun's JDK files.&nbsp;
See the Sun Community Source License agreement at <a href="http://www.sun.com/software/java2/license.html)">http://www.sun.com/software/java2/license.html</a>).
<p>
<hr WIDTH="100%">
<h2>
<a NAME="Appendix C:  Sources of unsoundness and incompleteness ESC/Java"></a>Appendix
C:&nbsp; Sources of unsoundness and incompleteness ESC/Java</h2>

<h3>
<a NAME="C.0  Known sources of unsoundness"></a>C.0&nbsp; Known sources
of unsoundness</h3>
An unsoundness is a circumstance that causes ESC/Java to miss an error
that is actually present in the program it is analyzing.&nbsp; Because
ESC/Java is an extended static checker rather than a program verifier,
some unsoundnesses are incorporated into the checker by design, based on
intentional trade-offs of unsoundness with other properties of the checker,
such as frequency of false alarms (incompleteness), efficiency, etc.&nbsp;
Continuing experience, and new ideas, may lead to reevaluation of these
trade-offs, with some sources of unsoundness possibly being eliminated
and others possibly being added in future versions of ESC/Java.
<p>In this section, we have attempted to describe, or at least allude to,
all known causes of unsoundness in the current ESC/Java.&nbsp; If you become
aware of any that we have missed, please bring them to our attention (see
<a href="#Appendix B:  Installing and using ESC/Java at your site">appendix
B</a>).
<h4>
<a NAME="C.0.0  Trusting pragmas"></a>C.0.0&nbsp; Trusting pragmas</h4>
The <tt>assume</tt>, <tt>axiom</tt>, and <tt>nowarn</tt> pragmas allow
the user to introduce assumptions into the checking process.&nbsp; ESC/Java
trusts them. If the assumptions are invalid, the checking can miss errors.&nbsp;
Besides the possibility of an <tt>assume</tt>, <tt>axiom</tt>, or <tt>nowarn</tt>
pragma being outright ``wrong,'' there are the following subtleties:
<blockquote>
<li>
As mentioned in the description of the <tt>axiom</tt> pragma (<a href="#2.4.2  axiom pragma">section
2.4.2</a>) and illustrated in an example in <a href="#2.7.2  Examples illustrating race and deadlock checking">section
2.7.2</a>, axioms can mention mutable state.&nbsp; ESC/Java assumes that
all (heuristically relevant) axioms hold at the start of any routine body
being checked, but does not check that they still hold before each routine
call or at the end of the routine body being checked.</li>

<li>
Certain ESC/Java warnings (for example <tt>Null</tt> warnings) correspond
to conditions that would result in Java exceptions (for example <tt>NullPointerException</tt>).&nbsp;
If a program is written intentionally to raise and then handle such an
exception, the user might put a <tt>nowarn</tt> pragma on the line where
the exception would be raised.&nbsp; In such a case the current ESC/Java
will not check that there actually is a handler, nor will it check for
any errors that might occur in the handler, or dynamically after execution
of the handler.</li>
</blockquote>

<h4>
<a NAME="C.0.1  Loops"></a>C.0.1&nbsp; Loops</h4>
The current ESC/Java does not consider all possible execution paths through
a loop.&nbsp; It considers only those that execute at most one complete
iteration (plus the test for being finished before the second iteration),
as explained in <a href="#2.4.3  loop_invariant pragma">section 2.4.3</a>.&nbsp;
This is simple, and avoids the need for loop invariants, but it is unsound.
<p>The user can modify ESC/Java's treatment of loops by using the <tt>-loop</tt>
command-line option.&nbsp; The <tt>-loop</tt> option takes an argument
of the form <i><tt>n</tt></i>, <tt><i>n</i>.0</tt>, or <tt><i>n</i>.5</tt>,
where <i><tt>n</tt></i> is a non-negative integer literal.&nbsp; The argument
specifies the number of loop iterations ESC/Java should consider.&nbsp;
Suppose, for example, that the program being checked includes the fragment
<blockquote><tt>//@ loop_invariant <i>E</i>;</tt>
<br><tt>while (<i>B</i>) {</tt>
<br><tt>&nbsp; <i>S</i></tt>
<br><tt>}</tt></blockquote>
If you run ESC/Java with the
<tt>-loop
<i>n</i></tt> (or, equivalently,
<tt>-loop
<i>n</i>.0</tt>)
on the command line, it will consider execution paths that include up to
<i><tt>n</tt></i>
executions of
<blockquote><tt>//@ assert <i>E</i>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // but
giving a LoopInv warning</tt>
<br><tt>if (!(<i>B</i>)) break;</tt>
<br><tt>S</tt></blockquote>
plus one additional execution of <tt>assert <i>E</i></tt>.&nbsp; If you
run ESC/Java with <tt>-loop
<i>n</i>.5</tt> on the command line, it will
consider execution paths that include up to <i><tt>n</tt></i> executions
of
<blockquote><tt>//@ assert <i>E</i>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // but
giving a LoopInv warning</tt>
<br><tt>if (!(<i>B</i>)) break;</tt>
<br><tt>S</tt></blockquote>
plus one additional execution of
<blockquote><tt>assert <i>E</i>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// but giving a LoopInv warning</tt>
<br><tt>if (!(B)) break;</tt></blockquote>
In either case, code following the loop is checked only for execution paths
in which the sequences described above terminate by a <tt>break</tt> out
of the loop (including the implicit <tt>if (!(<i>B</i>)) break</tt>), the
throwing of an exception, or the execution of a <tt>return</tt> statement.&nbsp;
ESC/Java will not consider code following the loop for execution paths
that ``fall through'' to the end of the unrollings (for example, by executing
the final <tt>if (!(<i>B</i>)) break</tt> in the unrolling for <tt>-loop
1.5</tt> when <i><tt>B</tt></i> evaluates to <tt>true</tt>).
<p>The default behavior of ESC/Java is the same as that given by <tt>-loop
1.5</tt>.&nbsp; Larger values of the parameter make ESC/Java's checking
more nearly sound, but not perfectly sound.&nbsp; Larger values of the
parameter can result in significantly slower checking and increased memory
usage, especially when checking routines that include large loops bodies
and/or nested loops.&nbsp; Loops that manifestly require many iterations
to terminate normally pose a particular difficulty.&nbsp; Suppose, for
example, that the program being checked contains a fragment of the form
<blockquote><tt>for (int i = 0; i &lt; 1000; i++) {<i>S1</i>}</tt>
<br><i><tt>S2</tt></i></blockquote>
where <i><tt>S1</tt></i> never exits abruptly.&nbsp; Then the ESC/Java
will never consider executions that reach <i><tt>S2</tt></i> unless it
is run with a <tt>-loop</tt> option with an argument greater than 1000,
which would almost certainly result in impractically large verification
conditions or impractically slow checking.
<p><b>Fine point</b>
<p>In the unrollings described above, execution of a <tt>break</tt> causes
normal completion of the entire loop, and execution of <tt>continue</tt>
causes normal completion of the current unrolled copy of <i><tt>S</tt>.</i>
<h4>
<a NAME="C.0.2  Object invariants"></a>C.0.2&nbsp; Object invariants</h4>
When checking the implementation of a method, ESC/Java assumes initially
that all allocated objects satisfy their invariants.&nbsp; But when checking
a call to a method, ESC/Java imposes a weaker condition on the caller:
all actual parameters of the call and all static fields that are in scope
are shown to satisfy their invariants, but not every object in existence.&nbsp;
Since more is assumed than is proved, this is unsound.&nbsp; It seems difficult
to design a sound discipline that is not impractically strict; the current
rule is a compromise that seems useful.&nbsp; See [<a href="#[LS97]">LS97</a>]
for a more detailed discussion of the interaction of object invariants
with scoping.
<p>Another source of unsoundness in the checking of object invariants arises
because, as we mentioned in <a href="#2.4.1  invariant pragma">section
2.4.1</a>, when ESC/Java checks the body of any routine <i><tt>R</tt></i>,
it does not consider all invariants but only a heuristically chosen ``relevant''
subset.&nbsp; If an invariant is deemed irrelevant during the checking
of a routine that calls <i><tt>R</tt></i>, but deemed relevant during the
checking of <i><tt>R</tt></i>, then the invariant will not be checked (even
for parameters) at the call site, but will nonetheless be assumed to hold
initially during the verification of <i><tt>R</tt></i>.&nbsp; (If ESC/Java
cautioned the user against unenforceable object invariants of the sort
mentioned in the fine points of <a href="#2.4.1  invariant pragma">section
2.4.1,</a> the situation would be partially, but not entirely, ameliorated.)&nbsp;
Conversely, ESC/Java might consider some invariant to be irrelevant to
<i><tt>R</tt></i>,
but relevant to a caller.&nbsp; In this case, ESC/Java will not check that
the body of <i><tt>R</tt></i> preserves the invariant, but will nonetheless
assume, while checking the caller, that the invariant is preserved by the
call.
<h4>
<a NAME="C.0.3  Modification targets"></a>C.0.3&nbsp; Modification targets</h4>
When reasoning about a call to a routine, ESC/Java assumes that the routine
modifies only its specified modification targets (as given in <tt>modifies</tt>
and/or <tt>also_modifies</tt> pragmas modifying the routine and any routines
it overrides).&nbsp; But when checking the implementation of a method,
the current ESC/Java doesn't check that the implementation modifies only
the specified targets.&nbsp; Thus
<tt>modifies</tt> and <tt>also_modifies</tt>
pragmas are purely a way of describing the programmer's intent in the form
that the checker can use as an assumption.
<h4>
<a NAME="C.0.4  The also_modifies and also_requires pragmas"></a>C.0.4&nbsp;
The <tt>also_modifies</tt> and <tt>also_requires</tt> pragmas</h4>
The <tt>also_modifies</tt> and <tt>also_requires</tt> pragma are unsound
because they allow an overriding method to have a weaker specification
than the method it overrides.
<p>Suppose that a method <tt>U.m</tt> overrides a method <tt>T.m</tt>,
and suppose that some method <tt>r</tt> contains a call of the form <tt><i>E</i>.m(</tt>...<tt>)</tt>
where <i><tt>E</tt></i> has static type <tt>T</tt> but might evaluate at
run time to a value of type <tt>U</tt>.&nbsp; While checking the code containing
the call ESC/Java will use the specification of <tt>T.m</tt>, but the actual
call (even in the absence of other sources of unsoundness) might only meet
the weaker semantics specified for <tt>U.m</tt>.&nbsp; In particular:
<ul>
<li>
If <tt>U.m</tt> is declared with an <tt>also_modifies</tt> pragma, the
call might modify parts of the state that are specified as modification
targets of <tt>U.m</tt> but not of<tt> T.m</tt>, but ESC/Java will check
the implementation of <tt>r</tt> under the assumption that the call modifies
only the targets specified for <tt>T.m</tt>.&nbsp; This would be a source
of unsoundness even if ESC/Java guaranteed that <tt>U.m</tt> modifies only
its specified modification targets (which it doesn't, as just mentioned
in
<a href="#C.0.3  Modification targets">section C.0.3</a>).&nbsp; Rustan
Leino [<a href="#[Leino98]">Leino98</a>] has designed a programming methodology
that would avoid this unsoundness, but in the current ESC/Java we have
decided to leave it to the programmer to use <tt>also_modifies</tt> with
care so as to avoid introducing the unsoundnesses described in Leino's
paper.</li>

<li>
If <tt>U.m</tt> is declared with an <tt>also_requires</tt> pragma, then
ESC/Java will use the preconditions specified&nbsp; in the <tt>also_requires</tt>
pragma when it checks the implementation of <tt>U.m</tt>, but will not
enforce those preconditions at the call <tt><i>E</i>.m(</tt>...<tt>)</tt>.</li>
</ul>

<h4>
<a NAME="C.0.5  Multiple inheritance"></a>C.0.5&nbsp; Multiple inheritance</h4>
ESC/Java treats multiple inheritance of preconditions and modification
targets unsoundly.
<p>Suppose that a method <tt>C.m</tt> inherits from <tt>A.m</tt> and <tt>B.m</tt>,
where
<tt>C</tt> is a class, and either <tt>A</tt> and <tt>B</tt> are both
be interfaces that <tt>C</tt> implements, or one is an interface that <tt>C</tt>
implements and the other is a class that <tt>C</tt> extends; and suppose
that some method <tt>r</tt> contains a call of the form <tt><i>E</i>.m(</tt>...<tt>)</tt>,
where <i><tt>E</tt></i> has static type <tt>A</tt> but might evaluate at
run time to a value of type <tt>C</tt>.
<p>When checking the body of <tt>C.m</tt>, ESC/Java will assume that all
preconditions for <tt>m</tt> declared in (or inherited by) either <tt>A</tt>
or <tt>B</tt>, hold initially.&nbsp; On the other hand, when checking the
call <tt><i>E</i>.m(</tt>...<tt>)</tt> in the body of <tt>r</tt>, where
expression <i><tt>E</tt></i> has static type<tt> A</tt>, ESC/Java will
only check the preconditions of <tt>A.m</tt>, and not those of <tt>B.m</tt>.
<p>Similarly, when ESC/Java checks code after the call, it will assume
that the call modifies at most the modification targets specified for <tt>A.m</tt>.&nbsp;
This would be a source of unsoundness even if ESC/Java checked that the
body of <tt>C.m</tt> modified only its declared modification targets.
<h4>
<a NAME="C.0.6  Arithmetic overflow"></a>C.0.6&nbsp; Arithmetic overflow</h4>
ESC/Java reasons about integer arithmetic as though machine integers were
of unlimited magnitude.&nbsp; This is both an unsoundness and an incompleteness,
but it simplifies the checker and reduces the annotation burden for the
user, while still allowing ESC/Java to catch many common errors.
<p>The Simplify theorem prover used by ESC/Java (see <a href="#Appendix A:  Overview of how ESC/Java works">appendix
A</a>) includes a decision procedure for linear rational arithmetic based
on the simplex algorithm.&nbsp; If integer operations in Simplify's simplex
module result in overflows, they will silently be converted to incorrect
results.&nbsp; This is a potential source both of unsoundness and of incompleteness
(see also <a href="#C.1.0  Incompleteness of the theorem-prover">section
C.1.0</a>).
<h4>
<a NAME="C.0.7  Ignored exceptional conditions"></a>C.0.7&nbsp; Ignored
exceptional conditions</h4>
ESC/Java checks for specific conditions that could give rise to a <tt>NullPointerException</tt>,<tt>
IndexOutOfBoundsException</tt>, <tt>ClassCastException</tt>,<tt> ArrayStoreException</tt>,<tt>ArithmeticException</tt>,
or <tt>NegativeArraySizeException</tt>, and warns of those conditions as
potential errors. It ignores the all other cases where instances of unchecked
exception classes (for example, <tt>OutOfMemoryError</tt>,
<tt>StackOverflowError</tt>,
<tt>ThreadDeath</tt>,
<tt>SecurityException</tt>)
[<i>JLS</i>, 11.2, 20.22] might be thrown either synchronously or asynchronously,
except by explicit
<tt>throw</tt> statements in a routine body being checked
or in accordance with the throws clauses of routines called by a routine
being checked.
<h4>
<a NAME="C.0.8  Constructor leaking"></a>C.0.8&nbsp; Constructor leaking</h4>
There are a number of ways in which a constructor can make the new object
under construction available in contexts where its instance invariants
are assumed to hold, but without actually having established those instance
invariants.&nbsp; For example:
<ul>
<li>
A constructor may terminate abruptly by throwing <tt>this</tt> without
establishing object invariants for <tt>this</tt>.</li>

<li>
A supertype constructor may store <tt>this</tt> into a field of a global
variable, and then return to the subtype constructor, which subsequently
terminates abnormally.</li>

<li>
When a constructor of a class <i><tt>T</tt></i> is called as a supertype
constructor from a constructor of a subtype <i><tt>S</tt></i>, the supertype
constructor may establish the instance invariants of <i><tt>T</tt></i>
for <tt>this</tt><i>,&nbsp;</i> then perform a method call <tt>this.<i>m</i>(</tt>...<tt>)</tt>
that dynamically dispatches to <tt><i>S</i>.m</tt>.&nbsp; However, the
correctness of the body of <tt><i>S</i>.m</tt> might depend on instance
invariants declared in <i><tt>S</tt></i> and not established at the call
site.</li>
</ul>
For a more detailed examination of the constructor leaking problem, see
[<a href="#[LS97]">LS97</a>].
<p>In addition to the problems with invariants described above, constructor
leaking can result in unsound checking of race conditions.&nbsp; When checking
a constructor body ESC/Java does not require that any lock be held in order
to accesses a field of <tt>this</tt>, even if the field is declared with
at <tt>monitored_by</tt> or <tt>monitored</tt> (<a href="#2.7.1  monitored pragma">section
2.7.1</a>) pragma.&nbsp; The reason is that ESC/Java assumes that no other
thread yet has access to <tt>this</tt> and thus that no actual race can
result.&nbsp; If this assumption is false, for example if the constructor
stores <tt>this</tt> into a globally-accessible data structure from which
another thread can read it, unsound checking--in the form of undetected
race conditions--could result.)
<h4>
<a NAME="C.0.9  Static initialization"></a>C.0.9&nbsp; Static initialization</h4>
The current ESC/Java does not perform extended static checking of static
initializers [<i>JLS</i>, 8.5] and initializers for <tt>static</tt> fields.&nbsp;
It neither checks for the possibility that they do not give rise to errors
such as null dereferences, nor does it check that they establish or maintain
static or instance invariants.
<h4>
<a NAME="C.0.10  Class paths and .spec files"></a>C.0.10&nbsp; Class paths
and <tt>.spec files</tt></h4>
Java (<tt>javac(5), java(5)</tt>) and ESC/Java (<tt>escjava(1)</tt>), when
run with the same class path, make different choices between <tt>.spec</tt>,
<tt>.java</tt>,
and
<tt>.class</tt> files.&nbsp; The current ESC/Java doesn't check that
the contents of the file it chooses are related to the contents of the
file
<tt>javac(5)</tt> would choose.&nbsp; Consider, for example, a scenario
where a file <tt>Foo.java</tt> uses a class <tt>Bar</tt>, and where both
a <tt>Bar.java</tt> and a <tt>Bar.spec</tt> file can be found on the class
path.&nbsp; In response to the command <tt>escjava Foo.java</tt>, ESC/Java
will check the routine bodies in <tt>Foo.java</tt> under the assumption
that calls to methods of <tt>Bar</tt> have the semantics specified in <tt>Bar.spec</tt>
(ignoring the file <tt>Bar.java</tt>).&nbsp; In response to the command
<tt>escjava
Bar.java</tt>, ESC/Java will check the method bodies in <tt>Bar.java</tt>
against the specifications in <tt>Bar.java</tt> (ignoring the file <tt>Bar.spec</tt>).
In neither case is there any checking that either the specifications or
the bodies of routines in <tt>Bar.java</tt> have any connection to the
specifications of corresponding routines in
<tt>Bar.spec</tt>, or even
that <tt>Bar.java</tt> and <tt>Bar.spec</tt> declare routines with the
same names and signatures.
<p>Note in particular that the specifications in the <tt>.spec</tt> files
available for download via the ESC/Java web site (see appendix B) may disagree
agree with the actual semantics of the corresponding JDK classes and interfaces,
for any of a variety of reasons, including but not limited to the following:
<ul>
<li>
The annotations in the <tt>.spec</tt> files were added mostly in reaction
to specific situations encountered by members of the ESC/Java team in our
use of ESC/Java, rather than as part of any systematic effort to specify
any set of routines completely (or even as completely as practical given
the limitations of the ESC/Java annotation language).</li>

<li>
There may be ``version skew'' between the <tt>.spec</tt> files you download
and the JDK files in use at your site.</li>

<li>
The <tt>.spec</tt> files may have intentional semantic differences from
the corresponding JDK files for methodological reasons (see, for example,
the discussion of unchecked exceptions in <a href="#4.5  Exception warning">section
4.5</a>).</li>

<li>
The <tt>.spec</tt> files, the JDK files, or both may simply contain errors.</li>
</ul>
(See also the <a href="#Limitation of liability:">disclaimers</a> near
the beginning of this manual.)
<h4>
<a NAME="C.0.11  Shared variables"></a>C.0.11&nbsp; Shared variables</h4>
ESC/Java depends on programmers to supply
<tt>monitored</tt> and <tt>monitored_by</tt>
pragmas telling which locks protect which shared variables.&nbsp; In the
absence of such annotations, ESC/Java will not produce a warning when a
routine might access a variable without holding the appropriate lock.&nbsp;
Even when the user does specify which locks protect which variables, there
is another potential source of unsoundness:&nbsp; ESC/Java assumes that
the value of a shared variable stays unchanged if a routine releases and
then reacquires the lock that protects it, ignoring the possibility that
some other thread might have acquired the lock and modified the variable
in the interim.
<h4>
<a NAME="C.0.12  Initialization of fields declared non_null"></a>C.0.12&nbsp;
Initialization of fields declared <tt>non_null</tt></h4>
There is an unsoundness in ESC/Java's checking that constructors assign
non-null values to fields declared <tt>non_null</tt>.&nbsp; Consider the
following program:
<blockquote><tt><font size=-2>&nbsp;1:</font>&nbsp; class C {</tt>
<br><tt><font size=-2>&nbsp;2:</font>&nbsp;&nbsp; /*@ non_null */ Object
f;</tt>
<br><tt><font size=-2>&nbsp;3:</font></tt>
<br><tt><font size=-2>&nbsp;4:</font>&nbsp;&nbsp;&nbsp; C() {</tt>
<br><tt><font size=-2>&nbsp;5:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m();</tt>
<br><tt><font size=-2>&nbsp;6:</font>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt><font size=-2>&nbsp;7:</font></tt>
<br><tt><font size=-2>&nbsp;8:</font>&nbsp;&nbsp; //@ modifies this.f;</tt>
<br><tt><font size=-2>&nbsp;9:</font>&nbsp;&nbsp;&nbsp; void m() {</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; </tt>...
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt><font size=-2>&nbsp;&nbsp;&nbsp;</font>&nbsp; }</tt></blockquote>
When checking the implementation of the constructor for <tt>C</tt>, ESC/Java
will assume (based solely on the pragmas on lines 2 and 8) that the method
<tt>m</tt>
returns with <tt>this.f</tt> set to a non-null value.&nbsp; While checking
the body of <tt>m</tt>, ESC/Java will check that any assignments to <tt>f</tt>
indeed assign non-null values.&nbsp; However, if the body of <tt>m</tt>
can complete normally without assigning to <tt>this.f</tt>, then ESC/Java's
assumption that <tt>this.f</tt> is always non-null after line 6 will be
unsound.
<h4>
<a NAME="C.0.13  String literals"></a>C.0.13&nbsp; String literals</h4>
Java's treatment of string concatenation (see [<i>JLS</i>, 3.10.5]) is
not accurately modeled by ESC/Java.&nbsp; This is a source both of unsoundness
and of incompleteness.
<h4>
<a NAME="C.0.14  Search limits in Simplify"></a>C.0.14&nbsp; Search limits
in Simplify</h4>
If Simplify cannot find a proof or a (potential) counterexample for the
verification condition (see <a href="#Appendix A:  Overview of how ESC/Java works">appendix
A</a>) for a routine within a set time limit, then ESC/Java issues no warnings
for the method, even though it might have issued a warning if given a longer
time limit.&nbsp; If Simplify reaches its time limit after reporting one
or more (potential) counterexamples, then ESC/Java will issue one or more
warnings, but perhaps not so many warnings as it would have issued if the
time limit were larger.&nbsp; You can set the time limit to <i><tt>n</tt></i>
seconds, where <i><tt>n</tt></i> is a positive integer, by setting the
environment variable <tt>PROVER_KILL_TIME</tt> to <i><tt>n</tt></i>.&nbsp;
If <tt>PROVER_KILL_TIME</tt> is not set, ESC/Java sets it to 300 before
invoking Simplify.
<p>There is also a bound on the number of counterexamples that Simplify
will report for any conjecture, and thus on the number of warnings that
ESC/Java will issue for any routine.&nbsp; You can set the bound to a positive
integer
<i><tt>n</tt></i> setting the environment variable <tt>PROVER_CC_LIMIT</tt>
to <i><tt>n</tt></i>.&nbsp; If <tt>PROVER_CC_LIMIT</tt> is not set, ESC/Java
sets it to 10 before invoking Simplify.
<h4>
<a NAME="C.0.15  Integer arithmetic bug in Simplify"></a>C.0.15&nbsp; Integer
arithmetic bug in Simplify</h4>
Simplify includes a complete decision procedure for linear rational arithmetic
and some heuristics for integer arithmetic.&nbsp; We have recently learned
that one of the procedures implementing the integer arithmetic heuristics
is buggy in a way that leads to unsoundness.&nbsp; This unsoundness in
not one that we intended to design into the checker, and we are investigating
the problem further.&nbsp; (For an unrelated source of unsoundness the
discussion of arithmetic overflow in
<a href="#C.0.6  Arithmetic overflow">section
C.0.6</a>).
<h4>
<a NAME="C.0.16  Quantifiers and allocation"></a>C.0.16&nbsp; Quantifiers
and allocation</h4>
When <i><tt>T</tt></i> is a reference type, specification expressions of
the forms <tt>(\forall <i>T t</i>; </tt>...<tt>)</tt> and <tt>(\exists
<i>T
t</i>; </tt>...<tt>)</tt> (sections <a href="#3.2.10  \forall">3.2.10</a>,
<a href="#3.2.11  \exists">3.2.11</a>)
quantify over allocated instances of <i><tt>T</tt></i>.&nbsp; If a method
allocates new objects but is not annotated with a postcondition mentioning
containing an occurrence of <tt>\fresh</tt> (<a href="#3.2.13  \fresh">section
3.2.13</a>) or <tt>\old</tt> (<a href="#3.2.15  \old">section 3.2.15</a>),
ESC/Java may infer (unsoundly) that some property holds for all allocated
objects after completion of a call, when the property may in fact not hold
for objects allocated during the call.&nbsp; This unsoundness results from
a performance optimization and seems rarely to result in problems (missing
warnings) in practice.
<h3>
<a NAME="C.1  Some sources of incompleteness"></a>C.1&nbsp; Some sources
of incompleteness</h3>
An incompleteness is a circumstance that causes ESC/Java to warn of an
potential error, when it is in fact impossible for that error to occur
in any run of the program it is analyzing.&nbsp; Because ESC/Java attempts
to check program properties that are, in general, undecidable, some degree
of incompleteness in inevitable.&nbsp; In addition, ESC/Java's implementers
have been willing to accept some evitable incompleteness in order to improve
performance and keep the tool simple.&nbsp; We list here some principal
sources of incompleteness in ESC/Java, but we do not attempt a complete
enumeration of sources of incompleteness.
<h4>
<a NAME="C.1.0  Incompleteness of the theorem-prover"></a>C.1.0&nbsp; Incompleteness
of the theorem-prover</h4>
The verification conditions that ESC/Java give to the Simplify theorem
prover are in a language that includes first-order predicate calculus (with
equality and uninterpreted function symbols) along with some (interpreted)
function symbols of arithmetic.
<p>Since the true theory of arithmetic is undecidable, Simplify is necessarily
incomplete.&nbsp; In fact, the incompleteness of Simplify's treatment of
arithmetic goes well beyond that necessitated by G&ouml;del's Incompleteness
Theorem.&nbsp; In particular:
<ul>
<li>
Simplify has no built-in semantics for multiplication, except by constants.</li>

<li>
Simplify doesn't support mathematical induction.</li>
</ul>
Also, first-order predicate calculus (FOPC) is only semidecidable--that
is, all valid formulas of FOPC are provable, but any procedure that can
prove all valid formulas must loop forever on some invalid ones.&nbsp;
But it is not useful for Simplify to loop forever, since ESC/Java issues
warnings only when Simplify reports (potential) counterexamples.&nbsp;
Therefore Simplify will sometimes report a (potential) counterexample
<i><tt>C</tt></i>,
even when it is possible that more work could serve to refute <i><tt>C</tt></i>,
and even to prove the entire verification condition.&nbsp; More particularly:
<ul>
<li>
The way Simplify makes use of a universally quantified formula, say <tt>(\forall
<i>T
t</i><sub>1</sub><i>, </i></tt><i>...<tt>, t</tt></i><tt><sub>n</sub>;
<i>B</i>)</tt>,
is by selectively instantiating the body <i><tt>B</tt></i> with substitutions
for <tt><i>t</i><sub>1</sub></tt><i>,<tt> </tt>...,<tt> t</tt></i><tt><sub>n</sub></tt>
determined by matching certain ``triggering patterns'' against a set of
terms already under consideration.&nbsp; In some cases, the triggering
may be overly restrictive, preventing Simplify from finding instances that
are actually needed for the proof.</li>

<li>
After Simplify instantiates the body of a universally-quantified formula,
the terms in the instantiated body may match the triggering patterns of
other universally quantified formulas, triggering instantiations of their
bodies, and so on.&nbsp; To avoid infinite looping Simplify bounds the
depth to which such sequences of matching may cascade.&nbsp; In some cases,
Simplify may report a potential counterexample that could in fact have
been refuted by deeper matching.</li>
</ul>

<h4>
<a NAME="C.1.1  Incomplete modeling of Java semantics"></a>C.1.1&nbsp;
Incomplete modeling of Java semantics</h4>
Ideally, the verification condition for a routine <i><tt>R</tt></i> would
be a formula that was valid if and only if <i><tt>R</tt></i> were free
of the kinds of potential errors ESC/Java aims to detect.&nbsp; In fact,
the verification conditions that ESC/Java generates fall short of modeling
the full semantics of Java in many ways.&nbsp; For example:
<ul>
<li>
ESC/Java's built-in semantics for floating-point operations are extremely
weak--not strong enough to&nbsp; prove <tt>1.0 + 1.0 == 2.0</tt> or even
<tt>1.0
!= 2.0</tt>.</li>

<li>
ESC/Java's built-in semantics for strings are quite weak--strong enough
to prove <tt>"Hello world" != null</tt>, but not strong enough to prove
the assertion <tt>s == 'l'</tt> after the assignment <tt>c = "Hello world".charAt(3)</tt>.</li>

<li>
ESC/Java treats exceptions thrown by the run-time system as errors, even
in programs that include code to catch them.</li>

<li>
The ESC/Java release includes <tt>.spec</tt> files for only a few JDK libraries,
and even the <tt>.spec</tt> files supplied do not fully capture the informal
semantics of the specified routines (see also <a href="#C.0.10  Class paths and .spec files">section
C.0.10</a>).</li>

<li>
According to rules of the Java type system, if neither of two distinct
classes <i><tt>S</tt></i> and <i><tt>T</tt></i> is a subtype of the other,
then <i><tt>S</tt></i> and <i><tt>T</tt></i> have no non-null instances
in common.&nbsp; ESC/Java's modeling of the Java type system is good enough
to enforce this disjointness for explicitly-named types, but not for all
types (such as the dynamic element types of array variables).</li>

<li>
As mentioned in <a href="#C.0.6  Arithmetic overflow">section C.0.6</a>,
the Simplify theorem prover may exhibit unsoundness due to integer overflow.&nbsp;
In order to reduce the likelihood of overflow occurring in the prover,
ESC/Java treats all integer literals of absolute magnitude greater than
1000000 as symbolic values whose relative ordering is known but whose exact
values are unknown.&nbsp; Thus, ESC/Java can prove the assertions <tt>2+2
== 4</tt> and <tt>2000000 &lt; 4000000</tt> but not <tt>2000000+2000000
= 4000000</tt>.</li>

<li>
While ESC/Java recognizes the Java 1.2 expressions of the form <tt><i>T</i>.class</tt>,
where <i><tt>T</tt></i> is a Java <i>Type</i> [<i>JLS</i>, 19.4], ESC/Java's
semantics for such expressions is extremely limited.&nbsp; For example,
ESC/Java can determine that <tt>int.class</tt> is a non-null instance of
<tt>java.lang.Class</tt>,
but not that it is distinct from
<tt>short.class</tt>, or even that it
is equal to <tt>Integer.TYPE</tt>.&nbsp; The implementers of ESC/Java currently
have no plans to significantly strengthen its semantics for <tt>java.lang.Class</tt>
in the absence of clear need.&nbsp; (In particular, we have no plans for
creating any connection between Java's Reflection API [<i><a href="#[Reflection]">Refection</a></i>]
and ESC/Java's specification type <tt>\TYPE</tt>.)</li>
</ul>

<h4>
<a NAME="C.1.2  Modular checking"></a>C.1.2&nbsp; Modular checking</h4>
ESC/Java's use of modular checking modular checking causes it to miss some
inferences that might be possible through whole program analysis.
<ul>
<li>
When translating a method call <tt><i>E</i>.<i>m</i>(</tt>...<tt>),</tt>
ESC/Java uses the spec of <i><tt>m</tt></i> for the static type of <i><tt>E</tt></i>,
even if it is provable that the dynamic type of <i><tt>E</tt></i> at the
call site will always be a subtype that overrides <i><tt>m</tt></i> with
a stronger spec.</li>

<li>
ESC/Java makes no attempt to infer method specifications.&nbsp; (However,
see [<a href="#[FL00]">FL00</a>, <a href="#[FJLxx]">FJLxx</a>].)</li>
</ul>

<h2>

<hr WIDTH="100%"></h2>

<h2>
<a NAME="References"></a>References</h2>
<a NAME="[DLNS98]"></a>[DLNS98]&nbsp; David L. Detlefs, K. Rustan M. Leino,
Greg Nelson, and James B. Saxe, ``Extended Static Checking'', Compaq SRC
Research Report 159, December 1998.&nbsp; Available on the web at <a href="http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-159.html">http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-159.html</a>.&nbsp;
[Cited in the <a href="#Acknowledgments">acknowledgments</a>.]
<p><a NAME="[FJLxx]"></a>[FJLxx]&nbsp; Cormac Flanagan, Rajeev Joshi, and
K. Rustan M. Leino, ``Annotation inference for modular checkers'', to appear
in <i>Information Processing Letters</i>.&nbsp; [Cited in sections <a href="#5.0  -suggest">5.0</a>
and <a href="#C.1.2  Modular checking">C.1.2</a>.]
<p><a NAME="[FL00]"></a>[FL00]&nbsp; Cormac Flanagan and K. Rustan M. Leino,
``Houdini, an annotation assistant for ESC/Java'', Compaq SRC Technical
Note 2000-003, September 2000.&nbsp; Available on the web at http://gatekeeper.dec.com/pub/DEC/SRC/technical-notes/abstracts/src-tn-2000-003.html.&nbsp;
[Cited in sections <a href="#5.0  -suggest">5.0</a> and <a href="#C.1.2  Modular checking">C.1.2</a>.]
<p><a NAME="[ICS]"></a>[<i>ICS</i>]&nbsp; ``Inner Classes Specification'',
Sun Microsystems, on the web at <a href="http://java.sun.com/products/jdk/1.1/docs/guide/innerclasses/spec/innerclasses.doc.html">http://java.sun.com/products/jdk/1.1/docs/guide/innerclasses/spec/innerclasses.doc.html</a>.&nbsp;
[Cited in <a href="#6  Java language support and limitations">section 6</a>.]
<p><a NAME="[JLS]"></a>[<i>JLS</i>]&nbsp; James Gosling, Bill Joy, and
Guy Steele, <i>The Java</i><sup><font size=-2>TM</font></sup><i>Language
Specification</i>, Addison-Wesley, Reading, Massachusetts, 1996.&nbsp;
Also available on the web at <a href="http://java.sun.com/docs/books/jls/html/index.html">http://java.sun.com/docs/books/jls/html/index.html</a>.&nbsp;
[Cited in places too numerous to mention.]
<p><a NAME="[LBR99]"></a>[LBR99] Gary T. Leavens, Albert L. Baker, and
Clyde Ruby, ``JML: A notation for detailed design'', in Haim Kilov, Bernhard
Rumpe, and Ian Simmonds, editors, <i>Behavioral Specifications of Businesses
and Systems</i>, pages 175-188, Kluwer Academic Publishers, Boston, 1999.&nbsp;
[Cited in the <a href="#Preface">preface</a>.]

<p><a NAME="[LBR00]"></a>[LBR00] Gary T. Leavens, Albert L. Baker, and
Clyde Ruby, ``Preliminary design of JML: A behavioral interface
specification language for Java'', Technical Report 98-06j, Iowa State
University, Department of Computer Science, May 2000.&nbsp; Available
on the web at <a
href="http://www.jmlspecs.org/">http://www.jmlspecs.org/</a>.&nbsp;
[Cited in the <a href="#Preface">preface</a>.]

<p><a NAME="[Leino98]"></a>[Leino98]&nbsp; Rustan M. Leino, ``Data groups:
Specifying the modification of extended state'', in <i>Proceedings of the
1998 ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages,
and Applications</i> (OOPSLA '98), volume 33(10) of <i>ACM SIGPLAN Notices</i>,
pages 144-153, October 1998.&nbsp; Available on the web (<a href="http://www.research.digital.com/SRC/publications/copyright/acm98.html">by
permission of the ACM</a>) in PostScript at <a href="ftp://ftp.digital.com/pub/DEC/SRC/publications/rustan/krml83-oopsla98.ps">ftp://ftp.digital.com/pub/DEC/SRC/publications/rustan/krml83-oopsla98.ps</a>
and in PDF at <a href="ftp://ftp.digital.com/pub/DEC/SRC/publications/rustan/krml83-oopsla98.pdf">ftp://ftp.digital.com/pub/DEC/SRC/publications/rustan/krml83-oopsla98.pdf</a>.&nbsp;
[Cited in sections <a href="#2.3.8  also_modifies pragma">2.3.8</a> and
<a href="#C.0.4  The also_modifies and also_requires pragmas">C.0.4</a>.]
<p><a NAME="[LLPRJ00]"></a>[LLPRJ00]&nbsp; Gary T. Leavens, K. Rustan M.
Leino, Erik Poll, Clyde Ruby, and Bart Jacobs, ``JML: notations and tools
supporting detailed design in Java'', to appear in <i>Proceedings of the
2000 ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages,
and Applications</i> (OOPSLA '00).&nbsp; Also available as Department of
Computer Science, Iowa State University, TR #00-15, August 2000, on the
web in PDF at <a href="ftp://ftp.cs.iastate.edu/pub/techreports/TR00-15/TR.pdf">ftp://ftp.cs.iastate.edu/pub/techreports/TR00-15/TR.pdf</a>
and in PostScript at <a href="ftp://ftp.cs.iastate.edu/pub/techreports/TR00-15/TR.ps.gz">ftp://ftp.cs.iastate.edu/pub/techreports/TR00-15/TR.ps.gz</a>.&nbsp;
[Cited in the <a href="#Preface">preface</a>.]
<p><a NAME="[LSS99]"></a>[LSS99]&nbsp; K. Rustan M. Leino, James B. Saxe,
and Raymie Stata, ``Checking Java programs via guarded commands'', in <i>Formal
Techniques for Java Programs</i>, workshop proceedings, Bart Jacobs, Gary
T. Leavens, Peter M&uuml;ller, and Arnd Poetzsch-Heffter, editors, Technical
Report 251, Fernuniversit&auml;t Hagen, 1999. Also available as Compaq
SRC Technical Note 1999-002, on the web at <a href="http://gatekeeper.dec.com/pub/DEC/SRC/technical-notes/abstracts/src-tn-1999-002.html">http://gatekeeper.dec.com/pub/DEC/SRC/technical-notes/abstracts/src-tn-1999-002.html</a>.&nbsp;
[Cited in <a href="#2.1.2  assume pragma">section 2.1.2</a>.]
<p><a NAME="[LS97]"></a>[LS97]&nbsp; K. Rustan M. Leino and Raymie Stata,
``Checking Object Invariants'', Compaq SRC Technical Note 1997-007, January
1997.&nbsp; Available on the web at <a href="http://gatekeeper.dec.com/pub/DEC/SRC/technical-notes/abstracts/src-tn-1997-007.html">http://gatekeeper.dec.com/pub/DEC/SRC/technical-notes/abstracts/src-tn-1997-007.html</a>.&nbsp;
[Cited in sections <a href="#2.3.4  exsures pragma">2.3.4</a>, <a href="#2.4.1  invariant pragma">2.4.1</a>,
and <a href="#C.0.2  Object invariants">C.0.2</a>.]
<p><a NAME="[LS99]"></a>[LS99]&nbsp; K. Rustan M. Leino and Raymie Stata,
``Virginity: A contribution to the specification of object-oriented software",
<i>Information
Processing Letters</i>, 70 (1999), pages 99-105.&nbsp; [Cited in (fine
points of) <a href="#3.2.17 owner">section 3.2.17</a>.]
<p><a NAME="[Reflection]"></a>[<i>Reflection</i>] ``Reflection'' (section
of JDK documentation), Sun Microsystems, on the web at <a href="http://java.sun.com/products/jdk/1.1/docs/guide/reflection/">http://java.sun.com/products/jdk/1.1/docs/guide/reflection/</a>.&nbsp;
[Cited in <a href="#C.1.1  Incomplete modeling of Java semantics">section
C.1.1</a>.]
<p><a NAME="[SLS00]"></a>[SLS00]&nbsp; Silvija Seres, with K. Rustan M.
Leino and James B. Saxe, ``ESC/Java Quick Reference'', Compaq SRC Technical
Note 2000-004, October 2000.&nbsp; Available on the web
at <a href="http://gatekeeper.dec.com/pub/DEC/SRC/technical-notes/abstracts/src-tn-2000-004.html">http://gatekeeper.dec.com/pub/DEC/SRC/technical-notes/abstracts/src-tn-2000-004.html</a>.&nbsp;
[Cited in the <a href="#Preface">preface</a> and <a href="#Acknowledgments">acknowledgments</a>.]
<hr WIDTH="100%">
<br>&nbsp;
<br>&nbsp;
</body>
</html>
