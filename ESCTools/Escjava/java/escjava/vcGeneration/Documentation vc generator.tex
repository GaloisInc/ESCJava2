\documentclass[english,a4paper,10pt]{article}
\usepackage{babel}
\usepackage[latin1]{inputenc}
\usepackage{vmargin}
\usepackage{verbatim}
\usepackage{float} % pour l'option H sur les figure

\title{\textbf{Verification condition generator for escjava2}}

\usepackage{color}
\usepackage{alltt}
\newcommand{\darkgreen[1]}{\textcolor[rgb]{0.33,0.79,0.28}}
\newcommand{\violet}[1]{\textcolor[rgb]{0.77,0.21,0.82}{#1}}
\newcommand{\orange}[1]{\textcolor[rgb]{1,0.6,0}{#1}}
\newcommand{\green}[1]{\textcolor{green}{#1}}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
%\newcommand{\JavaDeclaration}[3]{\violet{#1} \green{#2} \orange{#3}; \hspace{1cm}}}
\newcommand{\JavaDeclaration}[4]{\violet{#1} \darkgreen{#3} \orange{#4}; \hspace{1cm}}

\author{Clément Hurlin\\\texttt{clement.hurlin@gmail.com}}

\date{September 2005}

\begin{document}

\maketitle

\thispagestyle{empty} % no page number

\begin{abstract}
\bigskip
\hrule
\bigskip
This document describes the operation of the verification condition generator of escjava2. First we describe how we use the old code, that was designed to produce an unsorted proof (for Simplify), to create a new ast tree, strongly typed, that can be easily used to produce proof for any prover.\\
\indent Design choices are explained, structure of classes and every tricky part of the code is supposed to be detailed here. Don't hesitate to contact me for further explanations.\\
\indent Name of .java files and classes are written in \orange{orange}. Name of methods are written in \red{red}. Name of fields are written in \blue{blue}.
\bigskip
\hrule
\end{abstract}

\tableofcontents

\newpage

\section{Old tree}
First let's explain the global design of escjava2. Each method analysed leads to the generation of a set of guarded commands. The guarded commands represents how the method is supposed to be executed. You can see them by adding the \textit{-pgc} to the \textit{escj} script. The guarded commands are then modified, in a stage called 'desugaring' by the original authors of escjava. The generation of verification conditions\footnote{verification condition will be abreviated by 'vc' by now} takes place after this phase, you can see it by adding the \textit{-pvc} flag to the escjava executable. Originally, the logic of Simplify was completly untyped\footnote{or has only one type depending on how you see it}. The new vc generator use the old proof and type it in order to be able to generate proof for many sorted logics. At the moment, the only new logic supported is the many sorted one for pvs. We can summarize it in this way : \\

\begin{figure}[H]
\begin{center}
method \\
$\downarrow$ \\
guarded commands \\
$\downarrow$  \\
verification conditions \\
\end{center}
\end{figure}

\indent So how the generation is now done ? Given the old tree of the unsorted proof, we generate a tree which is strongly typed, and where you can use dynamic call of functions to easily modify the output of the vc generator. What we call the old tree is the result of parsing the desugared vc, and creating a proof which is independant from any prover. This part of the code was written by the author of escjava, it was designed for Simplify, yet the new vc generator corrects that. Moreover every single node of the new proof ast inherits from the same class. The tricky part of the translation was to extract the information we need in the old tree (like for example, name of variable, sense of the node) and convert it to a lighter, more meaningfull tree that can be easily manipulated no matter what proof we want to generate.

\section{Structure of classes}
The entire vc generator can be divided in 3 different and independant set of classes. The only method you're supposed to call are in the \orange{VcGenerator}. It was designed as an interface to manipulate the tree of the new proof. All files that deals with the tree are prefixed with a 'T'. The last set of classes is compound of \orange{TypeInfo} and \orange{VariableInfo}. Like you can guess from their name these two classes are used to contain information variables and about types, it will be explained more in details bottom.

\subsection{\orange{VcGenerator}}
Publics method of this class are :
\begin{itemize}
\item The constructor \red{VcGenerator}(ASTNode). The constructor except storing the node you give as a parameter. This node is supposed to be the root node of the old proof tree. Then you can call any of the following method :
\item \red{generateIfpProof}(boolean dot). This method creates the new tree. The parameter is just used for outputting the dot representation of the old tree. If you give \textit{true} then the dot file will be generated. You will then be able to retrieve it by calling \red{oldVc2Dot()}.
\item \red{setOutputProof}(String). This method is used for setting the type of the proof you want to be generated. At the moment you can give :
\begin{itemize}
\item "unsortedPvs" : the vc will be created for the logic which is in ESCTools/docs/Escjava2-Logics/unsorted/current\_unsorted\_logic.pvs
\item "pvs" : the vc are generated for the many sorted logic of pvs located in ESCTools/docs/Escjava2-Logics/many-sorted/many\_sorted\_logic.pvs
\item "sammy" : this time it's for the smt many sorted logic, which will be used with smt based prover, like Sammy.
\end{itemize}
\end{itemize}

\subsection{The top abstract classes}
The new ast tree makes strong use of abstract classes and overloading of fonctions. The top class from which all node inherits is \orange{TNode}. It contains as well all static fields and functions. I explain the operation of these static field because it's quite independant from the tree itself. There is a field containing a map describing how renaming of variable is done. This map is \blue{variablesName}. Let's explain how it is encoded with a little picture : \\

\begin{tabular}{p{80pt}|p{80pt}|p{80pt}|p{80pt}|p{40pt}}
key & unsortedPvs & pvs & sammy & type \\
\hline
c-1.8 & c\_1\_8 & c\_1\_8 & c1.8 & \$integer\footnote{The names of this variable will be explain later} \\
!tmp!integer-3.22 & tmp\_integer\_3\_22 & tmp\_integer\_3\_22 & tmp!int\_3\_22 & \$array \\
\end{tabular}\\

\indent So \blue{variablesName} is a java \textit{HashMap} where key are string which represents name of variable in the old translation of vc. Object stored belongs to class \orange{VariableInfo}. So when we encounter a variable name \textit{c-1.8}, if \textit{c-1.8} isn't a key of the \blue{variablesName} field, we entered it as a key in the hashMap, and the associated object is a new \textit{VariableInfo} containing the different renaming of the variable (field \blue{unsortedPvs pvs} and \blue{sammy}). The last field of \orange{VariableInfo} objects is a pointer on a \orange{TypeInfo} object which contains the type of the variable (if known). In order not to waste memory, renaming is done only when we know what kind of proof we will have to generate. The \orange{VariableInfo} object also contains a field (the last colum of our array) named \blue{type} which is of type \orange{TypeInfo}. This field is used to store the type of the variable. The \orange{TypeInfo} class works in the same way as \orange{VariableInfo} in a \textit{HashMap} called \blue{typesName} :\\

\begin{tabular}{p{80pt}|p{80pt}|p{80pt}|p{80pt}}
key & unsortedPvs & pvs & sammy \\
\hline
\%Reference & S & ReferenceObject & ? \\
integer & int & DiscreteNumber & int \\
double & float & ContinuousNumber & ? \\
\end{tabular}\\

Keys represents the name of the type in the old tree. As the old tree wasn't typed, it was defined during the rewriting of the vc generator. After that you have the corresponding name of the type in the different logics. For example the first line means that the type 'integer' is equivalent to the type 'int' in the pvs unsorted logic and in the smt lib one, and that it's translated to 'DiscreteNumber' for the pvs many sorted logic. We add a line in this array (it means we create a new \orange{TypeInfo} object) when we encounter a new type. Of course, we don't add the same type two times (this is easily done because key must be unique). A question immeditaley raises : what are the types in the old tree ?\\

\indent We tried to use every information available in the old tree, in ordert not to be constraint when we generate the proof. The different types are :
\begin{itemize} %to do complete that
\item \%Reference
\item \%ReferenceType
\item \%Time
\item \%Type
\item boolean
\item char
\item double
\item float
\end{itemize}
As keys in the \blue{typesName} \textit{HashMap} are String, these types are stored as String. This explains why some of them are prefixed with a \%. \% is a character which cannot be used in Java for naming a variable or a type. That's why we used to prefix some of our types. Imagine that the user defined a class "Time", then we will try to add to this map with the key "Type". That's why we have to differentiate our type "Time" by prefixing it with a \% which we know can't be use as a legal identifier in Java.\\
As you can guess, when we encounter a type name in the old tree, we check if it's already present in the \blue{typesName} map. If not we add it. That's why, in order to be a little bit efficient, some types are added before any call can be made. There is a \textit{static} bloc in the \orange{TNode} class, where you can see :

%todo fixme

It means that the new object \orange{TypeInfo} is stored in the field \blue{\$Reference} and added to the \blue{typesName} during initialization of the class. As these object are stored as \textit{public static field} in the \orange{TNode} class, we can easily use it to set type of variables. Moreover when we want to add a variable which has type '\%Reference' we can set its type without having to call a function which check if this type is already in the map. You can just do \textit{this.type = TNode.\$Reference} which is a valid call because \textit{\$Reference} is a static field of \orange{TNode}. I can imagine that you may wonder why variables name begins with a \$, I don't know why too, it just makes easier to remember that they are static. So as a resume, \orange{TNode} class have fields prefixed with a \$, that store the types, and some of these types begins with a \% to differentiate them from user defined types.

\subsubsection{\orange{TNode}}
This class is the top abstract class from which all nodes inherit. That's why it contains a lot of functions and fields. The different fields are :
\begin{itemize}
\item \JavaDeclaration{static}{protected}{int}{id}This field is an identifier which allows to distinguish every single node. It's used when we create the dot graph (see below).
\item \JavaDeclaration{static}{protected}{int}{counter}This field is used to create different id for each node. It's incremented at each call to the \green{TNode} contructor.
\item \JavaDeclaration{protected}{}{boolean}{isroot} This flag indicates if the node is the root one. His utility can be discusssed\dots
\item \JavaDeclaration{}{public}{TypeInfo}{type} This field points vers the \orange{TypeInfo} representing the type of this node. It can be null as long as the tree hasn't been typed.
\item \JavaDeclaration{protected}{}{boolean}{typeSure} When we type the tree, sometimes we can't be sure about the type (for example when inspecting an \textit{AnyEQ} function) of a variable. As long as this boolean isn't set to true, the type can change if we find more informations in another part of the tree.
\end{itemize}

\subsubsection{\orange{TFunction}}

\subsubsection{\orange{TVariable}}

\subsubsection{More functions}

\section{How to generate vcs for another logic / modify the generator ?}


\section{Conclusion and possible improvement}

\end{document}
