package escjava.vcGeneration;

import java.util.HashMap;
import escjava.translate.InitialState;
import javafe.ast.Expr;

/**
 * The interface to be implemented when adding a new prover to ESC/Java.
 * 
 * <p><b>Any</b> implementing class <i>should</i> be placed in an appropriately named 
 * <i>subpackage</i> of the <i>escjava.vcGeneration</i> 
 * package. In addition, the implementing classes name should be be a capitilized 
 * version of the subpackages name with all dots removed:
 * <center>
 * For example, for subpackage <i>pvs.unsorted</i>, the implementing classes name 
 * should be <i>PvsUnsortedProver</i>.
 * </center>
 * This restriction exists so that new provers may be generically loaded and 
 * created at runtime within the <i>escjava.Main</i> class and different provers may 
 * be easily identified within an editing environment.
 * 
 * <p>With this interface, even Simplify is treated as just another prover.
 * 
 * <p>The following terminology is used consistently throughout the vcGenerator 
 * package:
 * <ul>
 * <li>by <i>prover</i> we shall mean a <i>logic</i> and 
 * an underlying proof <i>engine</i></li>
 * <li>by <i>proof</i> we shall mean  an ESC/Java 
 * VC term (targeted to some prover).</li>
 * </ul>
 */

public interface ProverType {
    
    /**
     * This method is used to provide prover based renaming of the VC file name.
     * 
     * @param label The method based label that needs to be renamed.
     * @return The renamed method label.
     */
    public String labelRename(String label);
    
    /**
     * The visitor pattern is used to map an ESC/Java VC term to a prover term.
     * 
     * <p>vcGenerator uses this method to perform the mapping.
     * 
     * <p>A typical implementation of this method will also need to extend the 
     * TVisitor class.
     */
    public TVisitor visitor();

    /**
     * This method allows a VC term (generated by using the visitor pattern), for 
     * example, to:
     * <ul>
     * <li>be wrapped up as a prover assertion (eg. a lemma or theorem for the prover)</li>
     * <li>universally quantify all free variables in the VC term</li>
     * </ul>
     * 
     * @param name name to be given to the proof assertion (eg. lemma or theorem)
     * @param declns free variables of the VC term
     * @param vc VC term generated by the visitor pattern
     * @return 
     */
    public String getProof(String name, String declns, String vc);

    /**
     * FIXME
     * 
     * @param caller 
     * @return
     */
    public String getVariableInfo(VariableInfo caller);

    /**
     * FIXME
     * 
     * @param caller 
     * @return
     */
    public String getTypeInfo(TypeInfo caller);

    /**
     * Used to initialise the variable and type maps.
     */
    public void init();

    /**
     * This method is used by untyped prover logics to add typing predicates to
     * the supplied VC term.
     * <p>Typed prover logics do not need to do anything here.
     * 
     * @param tree the VC term to which typing predicates <i>may</i> need to be added.
     * @return
     */
    public Expr addTypeInfo(InitialState initState, Expr tree);
    
    /**
     * This method allows an ESC/Java VC term to be simplified <i>before</i> 
     * it is translated to the target prover.
     * 
     * @param tree a VC term to be simplified
     */
    //FIXME To what extent is this really necessary?
    public TNode rewrite(TNode tree);

    /**
     * This methods generates the declarations for a specified prover.
     * @param s The buffer to which we want to generate the declarations to. 
     * @param variablesName The hashmap containing all the variables, usually {@link TNode#variablesName}.
     */
    public void generateDeclarations(/*@ non_null @*/StringBuffer s, HashMap variablesName);

}
