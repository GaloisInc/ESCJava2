package escjava.vcGeneration;

import java.util.HashMap;
import java.io.*;

import escjava.translate.InitialState;
import javafe.ast.Expr;

/**
 * The interface to be implemented when adding a new prover to ESC/Java.
 * 
 * <p><b>Any</b> implementing class <i>should</i> be placed in an appropriately named 
 * <i>subpackage</i> of the <i>escjava.vcGeneration</i> 
 * package. In addition, the implementing classes name should be be a capitilized 
 * version of the subpackages name with all dots removed:
 * <center>
 * For example, for subpackage <i>pvs.unsorted</i>, the implementing classes name 
 * should be <i>PvsUnsortedProver</i>.
 * </center>
 * This restriction exists so that new provers may be generically loaded and 
 * created at runtime within the <i>escjava.Main</i> class and different provers may 
 * be easily identified within an editing environment.
 * 
 * <p>With this interface, even Simplify is treated as just another prover.
 * 
 * <p>The following terminology is used consistently throughout the vcGenerator 
 * package:
 * <ul>
 * <li>by <i>prover</i> we shall mean a <i>logic</i> and 
 * an underlying proof <i>engine</i></li>
 * <li>by <i>proof</i> we shall mean  an ESC/Java 
 * VC term (targeted to some prover).</li>
 * </ul>
 */

abstract public class ProverType {
    
    /**
     * This method is used to provide prover based renaming of the VC file name.
     * 
     * @param label The method based label that needs to be renamed.
     * @return The renamed method label.
     */
    abstract public String labelRename(String label);
    
    /**
     * The visitor pattern is used to map an ESC/Java VC term to a prover term.
     * 
     * <p>vcGenerator uses this method to perform the mapping.
     * 
     * <p>A typical implementation of this method will also need to extend the 
     * TVisitor class.
     * 
     * @param out The stream to which we should write our visitor trail
     */
    abstract protected TVisitor visitor(Writer out) throws IOException;

    /**
     * This method allows a VC term (generated by using the visitor pattern), for 
     * example, to:
     * <ul>
     * <li>be wrapped up as a prover assertion (eg. a lemma or theorem for the prover)</li>
     * <li>universally quantify all free variables in the VC term</li>
     * </ul>
     * 
     * @param name name to be given to the proof assertion (eg. lemma or theorem)
     * @param declns free variables of the VC term
     * @param vc VC term generated by the visitor pattern
     */
    abstract public void getProof(Writer out, String name, TNode term) throws IOException;

    /**
     * {@link VariableInfo} represents a <b>single</b> translation/mapping between an <i>old</i> 
     * variable name and the <i>targeted</i> prover variable name.
     * 
     * <p>This method returns the target prover's variable name given one of these 
     * translations/mapplets.
     * 
     * @param caller The specific variable name translation/mapplet we are to use.
     * @return
     */
    abstract public String getVariableInfo(VariableInfo caller);

    /**
     * {@link TypeInfo} represents a <b>single</b> translation/mapping between an <i>old</i> 
     * type name and the <i>targeted</i> prover type name.
     * 
     * <p>This method returns the target prover's type name given one of these 
     * translations/mapplets.
     * 
     * @param caller The specific type name translation/mapplet we are to use.
     * @return
     */
    abstract public String getTypeInfo(TypeInfo caller);

    /**
     * Used to initialise the variable and type maps.
     */
    abstract public void init();

    /**
     * This method is used by untyped prover logics to add typing predicates to
     * the supplied VC term.
     * <p>Typed prover logics do not need to do anything here.
     * 
     * @param tree the VC term to which typing predicates <i>may</i> need to be added.
     * @return
     */
    abstract public Expr addTypeInfo(InitialState initState, Expr tree);
    
    /**
     * This method allows an ESC/Java VC term to be simplified <i>before</i> 
     * it is translated to the target prover.
     * 
     * @param tree a VC term to be simplified
     */
    //FIXME To what extent is this really necessary?
    abstract public TNode rewrite(TNode tree);

    /**
     * This methods generates the declarations for a specified prover.
     * @param out The buffer to which we want to generate the declarations to. 
     * @param variablesName The hashmap containing all the variables, usually {@link TNode#variablesName}.
     */
    abstract protected void generateDeclarations(/*@ non_null @*/Writer out, HashMap variablesName) throws IOException;
    
    /**
     * This convenience method generates the declarations for a given term. These declarations 
     * are written to the specified stream.
     * 
     * @param out the stream to which the generated declarations are written
     * @param term the term from which the declarations are to be obtained
     */
    final public void generateDeclarations(Writer out, TNode term) throws IOException {
        term.generateDeclarations(out, this);
    }
    
    /**
     * This convenience method uses the visitor pattern to generate a prover specific term.
     * Used by {@link VcGenerator#getProof(Writer, String)}.
     * 
     * @param out the stream to which the generated term is to be written
     * @param term the term we wish to convert
     */
    final public void generateTerm(Writer out, TNode term) throws IOException {
        term.accept(visitor(out));
    }

}
