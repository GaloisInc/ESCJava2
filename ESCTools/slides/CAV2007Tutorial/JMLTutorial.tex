% -*- latex -*- mode for emacs
% $Id$
\typein[\MAKEHANDOUTS]{Handouts (y/n)?}
\if y\MAKEHANDOUTS \documentclass[compress,landscape,handout]{beamer}
\else \documentclass[compress]{beamer}
\fi
%
\mode<presentation>
{
% overall themes that seem to work for this talk, pick one:
  %\usetheme[secheader]{Madrid}
  %\usetheme{Pittsburgh}
  \usetheme{Copenhagen} % or other similar themes
%
  \usecolortheme{seahorse}
  \usefonttheme{structurebold}
  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}
\mode<handout>
{
   \usepackage{pgfpages}
   \pgfpagesuselayout{4 on 1}[border shrink=5mm]
}

\usepackage[english]{babel}
\usepackage[latin1]{inputenc}

\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{beamerbaseverbatim}

% fonts
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{times}
%avant, bookman, chancery, charter, euler, helvet, mathtime, mathptm,
%mathptmx, newcent, palatino, pifont, utopia.
% Use the luximono package to get a better look for bolded keywords
\usepackage[scaled=0.95]{luximono}

% listings
\usepackage{listings}
\input{jml-listings}
\lstset{language=[JML]Java,basicstyle=\ttfamily,commentstyle=\ttfamily,
        showstringspaces=false,
        keywordstyle=\bfseries,
        keywordstyle={[2]\bfseries\color{violet!80!black}}
       }

% Customizations
\thicklines
\newtheorem*{question}{Question}
\newtheorem*{exercise}{Exercise}

% -------- frontmatter ---------------
\title[JML Tutorial]{A JML Tutorial}
\subtitle{Modular Specification and Verification \\
of Functional Behavior for Java}

\author[Gary T. Leavens] % (optional, use only with lots of authors)
{\href{http://www.cs.iastate.edu/~leavens/}{Gary T.~Leavens}\inst{1}
  \and \href{http://secure.ucd.ie/~kiniry/}{Joseph R.~Kiniry}\inst{2}
  \and \href{http://www.cs.ru.nl/~erikpoll/}{Erik Poll}\inst{3}}
\institute[ISU $\rightarrow$ UCF] % (optional, but mostly needed)
{
  \inst{1}%
  Department of Computer Science\\
  \href{http://www.cs.iastate.edu/}{Iowa State University} (moving to \href{http://www.eecs.ucf.edu}{University of Central Florida})
  \and
  \inst{2}%
  School of Computer Science and Informatics \\
  \href{http://csiweb.ucd.ie/}{University College Dublin}
  \and
  \inst{3}%
  Computing Science Department \\
  \href{http://www.cs.ru.nl/}{Radboud University Nijmegen}
}

\date[CAV 2007]{July 3, 2007 / \href{http://cav2007.org/}{CAV 2007} Tutorial / \href{http://www.jmlspecs.org}{jmlspecs.org}}

\subject{JML} % optional insertion into the PDF information catalog.

\pgfdeclareimage[height=0.5cm]{jml-logo}{jml-logo-hires}
\logo{\pgfuseimage{jml-logo}}

% Delete this, if you do not want the table of contents to pop up at
% the beginning of each section:
\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection,hideallsubsections]
  \end{frame}
}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\section*{Intro.}

\begin{frame}
\frametitle{Objectives}

You'll be able to:
  \begin{itemize}
  \item
    Explain JML's goals.
  \item
    Read and write JML specifications.
  \item
    Use JML tools.
  \item
    Explain basic JML semantics.
  \item
    Know where to go for help.
  \end{itemize}
\end{frame}

\begin{frame}
\frametitle{Tutorial Outline}
  \tableofcontents[hideallsubsections] %[pausesections]
\end{frame}

\begin{frame}
\frametitle{Introduce Yourself, Please}

\begin{question}
Who you are?
\end{question}

\begin{question}
What do you want to learn about JML?
\end{question}
\end{frame}

%\part{JML Basics}

\section[Overview]{JML Overview}

\subsection[Basics]{Basics}

\begin{frame}
\frametitle{Java Modeling Language}
\begin{columns}[t]
\column{.5\textwidth}
\begin{block}{Currently:}
\begin{itemize}
\item
Formal.

\item 
Sequential Java.

\item
Functional behavior.

\item
Java 1.4.
\end{itemize}
\end{block}

\pause

\column{.5\textwidth}
\begin{block}{Working on:}
\begin{itemize}
\item
Detailed Semantics.

\item 
Multithreading.

\item
Temporal Logic.

\item
Java 1.5 (generics).
\end{itemize}
\end{block}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{JML's Goals}
\begin{itemize}
\item
Practical, effective for detailed designs.

\item
Existing code.

\item
Wide range of tools.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Detailed Design Specification}

\begin{columns}[t]
\column{.5\textwidth}
\begin{block}{Handles:}
\begin{itemize}
\item
Inter-module Interfaces.

\item
Classes and interfaces.

\item 
Data (fields)

\item
Methods.
\end{itemize}
\end{block}

\pause

\column{.5\textwidth}
\begin{block}{Doesn't handle:}
\begin{itemize}
\item
User interface.

\item 
Architecture, packages.

\item
Dataflow.

\item
Design patterns.
\end{itemize}
\end{block}
\end{columns}
\end{frame}

\subsection[Flavor]{Flavor of JML}

\begin{frame}
\frametitle{Approach}
\begin{itemize}
\item
Hoare-style (Contracts)

\item
Method pre- and postconditions 

\item
Invariants
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{A First JML Specification}
\lstinputlisting[linerange={1-12}]{examples/ArrayOps.java}
\note{Explain notation on subsequent slides.  Stress client view.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Field Specification with \lstinline!spec_public!}
\lstinputlisting[linerange={1-2},basicstyle=\ttfamily\color{lightgray},keywordstyle={[2]\bfseries\color{lightgray}}]{examples/ArrayOps.java}
\lstinputlisting[linerange={3-3},frame=single,frameround=tttt,rulecolor=\color{violet},belowskip=0pt]{examples/ArrayOps.java}
\lstinputlisting[linerange={4-12},basicstyle=\ttfamily\color{lightgray},keywordstyle={[2]\bfseries\color{lightgray}}]{examples/ArrayOps.java}
\note{Note the annotation comments. 
You can't put a space between /* and the @, otherwise JML doesn't see it.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Object Invariant}
\lstinputlisting[linerange={1-4},basicstyle=\ttfamily\color{lightgray},keywordstyle={[2]\bfseries\color{lightgray}}]{examples/ArrayOps.java}
\lstinputlisting[linerange={5-5},frame=single,frameround=tttt,rulecolor=\color{violet},belowskip=0pt]{examples/ArrayOps.java}
\lstinputlisting[linerange={6-12},basicstyle=\ttfamily\color{lightgray},keywordstyle={[2]\bfseries\color{lightgray}}]{examples/ArrayOps.java}
\note{You can also use //@ to mark annotation comments for JML.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Method Specification with \lstinline|requires|, \lstinline!ensures!}
\lstinputlisting[linerange={1-6},basicstyle=\ttfamily\color{lightgray},keywordstyle={[2]\bfseries\color{lightgray}}]{examples/ArrayOps.java}
\lstinputlisting[linerange={7-10},frame=single,frameround=tttt,rulecolor=\color{violet},belowskip=0pt]{examples/ArrayOps.java}
\lstinputlisting[linerange={11-12},basicstyle=\ttfamily\color{lightgray},keywordstyle={[2]\bfseries\color{lightgray}}]{examples/ArrayOps.java}
\end{frame}

\begin{frame}
\frametitle{Interface Specification}
\includegraphics[width=4.25in]{if0}
\end{frame}

\begin{frame}
\frametitle{Interface Specification}
\includegraphics[width=4.25in]{if1}
\end{frame}

\begin{frame}
\frametitle{Like $\ldots$ But for Java and $\ldots$}
\begin{itemize}
\item
\textcolor{blue}{VDM}, but
\begin{itemize}
\item
OO features
\end{itemize}

\item
\textcolor{blue}{Eiffel}, but
\begin{itemize}
\item
Features for formal verification
\end{itemize}

\item
\textcolor{blue}{Spec\#}, but
\begin{itemize}
\item
Different invariant methodology
\item
More features for formal verification
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Unlike OCL and Z}

\begin{itemize}
\item
More Java-like syntax.

\item
Tailored to Java semantics.
\end{itemize}
\note{These make it easier for Java programmers.}
\end{frame}

\begin{frame}
\frametitle{Many Tools, One Language}
\includegraphics[width=4.25in]{tools-overview}
\end{frame}

\begin{frame}
\frametitle{How Tools Complement Each Other}
\begin{itemize}
\item
Different strengths:
\begin{itemize}
\item
Runtime checking --- real errors.

\item
Static checking --- better coverage.

\item
Verification --- guarantees.
\end{itemize}

\item
Usual ordering:
\begin{enumerate}
\item
Runtime checker (jmlc and jmlunit).

\item
Extended Static Checking (ESC/Java2).

\item
Verification tool (e.g., KeY, JACK, Jive).
\end{enumerate}
\end{itemize}
\end{frame}

\subsection[Importance]{Importance of JML}

\begin{frame}
\frametitle{Importance of JML}

\begin{itemize}
\item
Many tools.

\item
State of the art language.

\item
Large and open research community:
\begin{itemize}
\item
23 groups, worldwide.

\item
Over 135 papers.
\end{itemize}
\end{itemize}

See \href{http://www.jmlspecs.org}{jmlspecs.org}
\end{frame}

\begin{frame}
\frametitle{Advantages of Working with JML}

\begin{itemize}
\item
Reuse language design.

\item
Ease communication with researchers.

\item
Share customers.
\end{itemize}

Join us!
\end{frame}

\begin{frame}
\frametitle{Opportunities in Working with JML}
\framesubtitle{Or: What Needs Work}

\begin{itemize}
\item
Tool development, maintenance.

\item
Extensible tool architecture.

\item
Unification of tools.
\end{itemize}
\note{Currently the tools are in a bit of a mess.}
\end{frame}

\subsection[Finding More]{Where to Find More}

\begin{frame}
\frametitle{Where to Find More: \href{http://www.jmlspecs.org}{jmlspecs.org}}

Documents:
\begin{itemize}
\item
\href{ftp://ftp.cs.iastate.edu/pub/leavens/JML/jmldbc.pdf}{``Design by Contract with JML''}

\item
\href{http://dx.doi.org/10.1007/s10009-004-0167-4}{``An overview of JML tools and applications''}

\item
\href{http://doi.acm.org/10.1145/1127878.1127884}{``Preliminary Design of JML''}

\item
\href{http://www.jmlspecs.org/jmlrefman/jmlrefman_toc.html}{``JML Reference Manual''}
\end{itemize}

Also:
\begin{itemize}
\item
Examples, teaching material.

\item
Downloads, sourceforge project.

\item
Links to papers, etc.
\end{itemize}

\end{frame}

\section[R/W]{Reading and Writing JML Specifications}

\subsection[Lightweight]{Lightweight Specification of Functional Behavior}

\begin{frame}[fragile]
\frametitle{JML Annotations Comments $\neq$ Java Annotations}

JML annotation comments:
\begin{itemize}
\item
Line starting with \lstinline!//@!

\item
Between \lstinline!/*@! and \lstinline!@*/!,
ignoring \lstinline!@!'s starting lines.
\end{itemize}

First character must be \lstinline!@!

\note{Java annotations are not in comments.
We are experimenting with putting JML in Java annotations, but that's
not standard and doesn't work with any tools.}
\end{frame}

\begin{frame}[fragile]
\frametitle{JML Annotations Comments $\neq$ Java Annotations}
\begin{question}
What's wrong with the following?
\rm

\begin{lstlisting}
// @requires 0 < arr.length;
// @ensures this.a == arr;
public void init(Object[] arr)
\end{lstlisting}
\end{question}
\end{frame}

\begin{frame}
\frametitle{Most Important JML Keywords}

Top-level in classes and interfaces:
\begin{itemize}
\item
\lstinline!invariant!

\item
\lstinline!spec_public!
\end{itemize}

For methods and constructors:
\begin{itemize}
\item
\lstinline!requires!

\item
\lstinline!ensures!

\item
\lstinline!assignable!

\item
\lstinline!pure!
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Example: BoundedStack}

\begin{example}
Specify bounded stacks of objects.
\end{example}

\note{See the file BoundedStack.java}
\end{frame}

\begin{frame}[fragile]
\frametitle{BoundedStack's Data and Invariant}
\lstinputlisting[linerange={1-12}]{examples/BoundedStack.java}
\note{Explain notation. Stress client view.}
\end{frame}

\begin{frame}[fragile]
\frametitle{BoundedStack's Constructor}
\lstinputlisting[linerange={13-19}]{examples/BoundedStack.java}
\end{frame}

\begin{frame}[fragile]
\frametitle{BoundedStack's push Method}
\lstinputlisting[linerange={21-32}]{examples/BoundedStack.java}
\end{frame}

\begin{frame}[fragile]
\frametitle{BoundedStack's pop Method}
\lstinputlisting[linerange={34-45}]{examples/BoundedStack.java}
\end{frame}

\begin{frame}[fragile]
\frametitle{BoundedStack's top Method}
\lstinputlisting[linerange={47-54}]{examples/BoundedStack.java}
\end{frame}

\begin{frame}[fragile]
\frametitle{spec\_public and invariant}

\lstinline!spec_public!
\begin{itemize}
\item
Public visibility.

\item
Only for specification purposes.
\end{itemize}

\note{\lstinline!spec_public! actually a syntactic sugar.}

\lstinline!invariant! must be:
\begin{itemize}
\item
True at end of constructor.

\item
Preserved by each method.
\end{itemize}

\note{Helper methods are an exception to invariant preservation.}
\end{frame}

\begin{frame}[fragile]
\frametitle{requires and ensures}

\lstinline!requires! clause:
\begin{itemize}
\item
Precondition.

\item
Obligation on callers, after parameter passing.

\item
Assumed by implementor.
\end{itemize}

\lstinline!ensures! clause:
\begin{itemize}
\item
Postcondition.

\item
Obligation on implementor, at return.

\item
Assumed by caller.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Semantics of Requires and Ensures}
\includegraphics[width=4.25in]{requires}
\end{frame}

\begin{frame}
\frametitle{Semantics of Requires and Ensures}
\includegraphics[width=4.25in]{ensures}
\end{frame}

\begin{frame}
\frametitle{Semantics of Requires and Ensures}
\includegraphics[width=4.25in]{correctimpl}
\end{frame}

\begin{frame}[fragile]
\frametitle{assignable and pure}

\lstinline!assignable!
\begin{itemize}
\item
Frame axiom.

\item
Locations (fields) in pre-state.

\item
New object fields not covered.

\item
Sugar for postcondition: ``nothing else assigned''

\item
Checked statically.

\item
Synonyms: \lstinline!modifies!, \lstinline!modifiable!
\end{itemize}

\lstinline!pure!
\begin{itemize}
\item
No side effects.

\item
Implies \lstinline!assignable \nothing!

\item
Allows method's use in specifications.
\end{itemize}
\note{Note that pure is a modifier for methods, not a clause.}
\end{frame}

\begin{frame}[fragile,label=redundantly]
\frametitle{Redundant Clauses}

E.g., \lstinline!ensures_redundantly!
\begin{itemize}
\item
Alerts reader.

\item
States something to prove.

\item
Must be implied by:
\begin{itemize}
\item
\lstinline!ensures! clauses,

\item
\lstinline!assignable! clause,

\item
\lstinline!invariant!, and

\item
JML semantics.
\end{itemize}
\end{itemize}

Also \lstinline!requires_redundantly!, etc.

\note{There is a flag on jmlc to avoid checking redundant
specifications, but they are checked by default.
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Multiple Clauses}

Semantics:

\begin{lstlisting}[mathescape=true]
  requires $P$;
  requires $Q$;
\end{lstlisting}

is equivalent to:

\begin{lstlisting}[mathescape=true]
  requires $P$ && $Q$;
\end{lstlisting}

Similarly for \lstinline!ensures!, \lstinline!invariant!.

~

Note: runtime checker gives better errors with multiple clauses.

\note{For assignable, semantics is the union.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Omitted Clauses}

Defaults for omitted clauses:
\begin{itemize}
\item
\lstinline!invariant true;!

\item
\lstinline!requires true;!

\item
\lstinline!assignable \everything;!

\item
\lstinline!ensures true;!
\end{itemize}
\note{Strictly speaking, the defaults listed here are a lie.
  For lightweight specifications the defaults are all
  \lstinline!\not_specified!.  The listed defaults are
  actually the defaults for heavyweight specifications
  (that use the \lstinline!behavior! or \lstinline!normal_behavior! keywords).
  However, the tools treat them this way.
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Expression Keywords}

\begin{itemize}
\item
\lstinline!\result! ~~ = ~~ method's return value.

\item
\lstinline[mathescape=true]!\old($E$)! ~~ = ~~ pre-state value of $E$.

\item
\lstinline[mathescape=true]!(\forall T x; $P$; $Q$)!
~~ = ~~ $\bigwedge \{ Q \mid x \in T \wedge P \}$

\item
\lstinline[mathescape=true]!(\exists T x; $P$; $Q$)!
~~ = ~~ $\bigvee \{ Q \mid x \in T \wedge P \}$

\item
\lstinline[mathescape=true]!(\min T x; $P$; $E$)!
~~ = ~~ $\min \{E \mid x \in T \wedge P \}$

\item
\lstinline[mathescape=true]!(\sum T x; $P$; $E$)!
~~ = ~~ $\sum \{E \mid x \in T \wedge P \}$

\item
\lstinline[mathescape=true]!(\num_of T x; $P$; $Q$)!
~~ = ~~ $\sum \{1 \mid x \in T \wedge P \wedge Q\}$

\item
$\ldots$
\end{itemize}
\note{This is more than we need now, but stress the regular pattern of
the quantifiers, with a domain and range predicate.
The listeners of this tutorial will be able to use \lstinline!\num_of! later.
We use the backslashes to avoid reserving words in expression contexts.
The \lstinline!\num_of! quantifier actually produces a long, not int, result.
}
\end{frame}

\subsection[Exercise]{Specifying a Type}

\begin{frame}[fragile]
\frametitle{Steps for Specifying a Type for Public Clients}

\begin{enumerate}
\item
Specify data (\lstinline!spec_public! fields).

\item
Specify a \lstinline!public invariant!.

\item
Specify each public method using:

\begin{enumerate}
\item
\lstinline!requires!.

\item
\lstinline!assignable! (or \lstinline!pure!).

\item
\lstinline!ensures!.
\end{enumerate}
\end{enumerate}
\note{The invariant can be omitted if not needed, as can the requires clause.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Exercise: Specify BagOfInt (7 minutes)}

\begin{exercise}
Specify the following:

\rm
\lstinputlisting[language=Java,commentstyle=\itshape]{examples/BagOfInt.jml-refined}
\end{exercise}
\end{frame}

\begin{frame}<beamer>[fragile]
\frametitle{My Solution: BagOfInt's Data}

\lstinputlisting[linerange={2-9}]{examples/BagOfInt.jml}
\note{Why do we need n?  To allow deletion.}
\end{frame}

\begin{frame}<beamer>[fragile]
\frametitle{My Solution: BagOfInt's Constructor}

\lstinputlisting[linerange={11-17}]{examples/BagOfInt.jml}
\end{frame}

\begin{frame}<beamer>[fragile]
\frametitle{My Solution: Method occurrences}

\lstinputlisting[linerange={19-24}]{examples/BagOfInt.jml}
\end{frame}

\begin{frame}<beamer>[fragile]
\frametitle{My Solution: Method extractMin}

\lstinputlisting[linerange={26-34}]{examples/BagOfInt.jml}
\end{frame}


\subsection[Tools]{Basic Tool Use}  % demo + exercise

\begin{frame}
\frametitle{Getting the Tools}

Links to all tools:
\begin{itemize}
\item
\href{http://www.jmlspecs.org/}{jmlspecs.org}'s download page.
\end{itemize}


Individual tools:
\begin{itemize}
\item
Common JML tools
\href{http://sourceforge.net/projects/jmlspecs/}{http://sourceforge.net/projects/jmlspecs/}

\item
ESC/Java2 Eclipse plugin \newline
\href{http://jmleclipse.projects.cis.ksu.edu}{jmleclipse.projects.cis.ksu.edu}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Using jmlc, the Runtime Checker}

\begin{example}
\begin{verbatim}
$ jmlc -Q -e -o BagOfInt.java BagOfIntMain.java
$ jmlrac BagOfIntMain
\end{verbatim}
\end{example}
\note{This should be a demo, with Emacs or Eclipse.
We're using CLASSPATH=. because of the use of the unnamed package;
for other packages, we have to be careful, as with Java.
Might want to show what happens with javac first.
The -Q flag shuts jmlc up somewhat.  The -e flag turns on universes.
The -o flag changes the the ``neutral context'' semantics, which will
be part of future release of JML's common tools.
These flags are valid for JML Common Tools release 5.4.
There are manual pages for each of the tools.
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Writing Tests Using Assert}

\lstinputlisting[linerange={4-17}]{examples/BagOfIntMain.java}
\note{It's much better to use assert than to try to look at output!
You can use Java's assert too, but there are advantages to using
JML's assert, as is done here.
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Using jmlc, the Runtime Checker}

{\small
\begin{verbatim}
org...JMLInternalExceptionalPostconditionError:
 by method BagOfInt.occurrences regarding spec...s at
   File "BagOfInt.jml", line 21, character 14, when
    'jml$e' is ...ArrayIndexOutOfBoundsException: 6
   at BagOfInt.main(BagOfInt.java:2120)
Exception in thread "main" 
\end{verbatim}
% $
}
\lstinputlisting[linerange={20-24},numbers=left,numberstyle=\small]{examples/BagOfInt.jml}
\end{frame}

\begin{frame}[fragile]
\frametitle{Using jmlc with jmlunit}

\begin{example}
CLASSPATH includes:
\begin{itemize}
\item
\texttt{.}

\item
\texttt{junit.jar} (version 3.8.1)

\item
\texttt{JML/bin/jml-release.jar}
\end{itemize}

\begin{verbatim}
$ jmlunit -i BagOfInt.java
\end{verbatim}
% $

Edit \lstinline!BagOfInt_JML_TestData.java!

\begin{verbatim}
$ javac BagOfInt_JML_Test*.java
$ jmlc -Q -e BagOfInt.java
$ jmlrac BagOfInt_JML_Test
\end{verbatim}
% $
\end{example}
\note{This should be a demo.
Note you have to compile with jmlc \emph{after} compiling with javac,
since javac will compile the executable without RAC.  
Put in data for ints (3, 4, 5, 10),
arrays {3, 4, 2, 3, 3}, {0, 10, 20, 30, 10},
and bags with those arrays (case N: return new BagOfInt(...);).
Might want to show what happens with javac first.
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Using jmlc with jmlunit}

{\small
\begin{verbatim}
.....F.F.F.F.F.F.F.F.F.F.F.F.F.F........F.F.....
Time: 0.01
There were 16 failures:
1) occurrences:0(BagOfInt_JML_Test$TestOccurrences)
  junit.framework.AssertionFailedError:
    Method 'occurrences' applied to
    Receiver: {3, 4, 2, 3, 3}
    Argument i: 0
Caused by: ...JMLExitExceptionalPostconditionError:
by: method BagOfInt.occurrences regarding spec...s at
   File "BagOfInt.jml", line 21, character 14, when
    'jml$e' is ...ArrayIndexOutOfBoundsException: 5
\end{verbatim}
% $
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Using ESC/Java2}

\begin{example}
\begin{verbatim}
$ CLASSPATH=.
$ export CLASSPATH
$ escjava2 -nonNullByDefault BagOfInt.java
\end{verbatim}
% $
\end{example}
\note{This should be a demo, with Emacs or Eclipse.
To get the Eclipse demo to run on Windows, I had to tell Eclipse about the
Simplify executable location explicitly in the preferences.
See Window/Preferences/Java/EscJava2 in the Eclipse menus.
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Using ESC/Java2}

{\small
\begin{verbatim}
BagOfInt ...
  Prover started:0.03 s 15673776 bytes
    [2.013 s 15188656 bytes]

BagOfInt: BagOfInt(int[]) ...
---------------------------------------------------
BagOfInt.java:11: Warning: 
      Postcondition possibly not established (Post)
  }
  ^
Associated declaration is 
".\BagOfInt.jml", line 14, col 6:
    @ ensures (\forall int i; 0 <= i && i < n;
      ^
\end{verbatim}
}
\end{frame}

\subsection[Tips/Pitfalls]{Tips and Pitfalls}

\begin{frame}
\frametitle{Tip: Use JML Assert Statements}

\begin{columns}[t]
\column{.5\textwidth}
\begin{block}{JML}
\begin{itemize}
\item
All JML features.

\item
No side effects.
\end{itemize}
\end{block}

\column{.5\textwidth}
\begin{block}{Java}
\begin{itemize}
\item
Only Java expressions.

\item
Can have side effects.
\end{itemize}
\end{block}
\end{columns}

\note{JML features include quantifiers, and model fields.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Tip: Use JML Assume Statements}

\lstinline!assume! $P$\texttt{;}

\begin{itemize}
\item
Claims $P$ is true.

\item
Checked by the RAC like \lstinline!assert! $P$\texttt{;}

\item
Assumed by ESC/Java and static tools.
\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Assume Statements Blame Other}

\begin{lstlisting}[mathescape=true]
//@ requires $P$;
//@ ensures $Q$;
public void m() {
  $S$
}
\end{lstlisting}

similar to:

\begin{lstlisting}[mathescape=true]
public void m() {
  //@ assume $P$;
  $S$
  //@ assert $Q$;
}
\end{lstlisting}
\note{There are differences in static checkers, such as ESC/Java, and
  in error messages and exceptions from the RAC, however.
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Assume Statements Blame Other}

\begin{lstlisting}[mathescape=true]
//@ assert $P$;
o.m();
//@ assume $Q$;
\end{lstlisting}

\end{frame}

\begin{frame}
\frametitle{Pitfall: Aliasing in Java}
\includegraphics[width=4.25in]{aliasxy}
\end{frame}

\begin{frame}
\frametitle{Aliasing and Object Identity}
\framesubtitle{JML Uses Java's Indirect Model for Objects}

For objects $x$ and $y$, $x$ \texttt{==} $y$ means:
\begin{itemize}
\item
$x$ and $y$ have same address.

\item
$x$ and $y$ are aliased.

\item
Changing of $x.f$ also changes $y.f$.
\end{itemize}

Aliasing caused by:
\begin{itemize}
\item
Assignment ($x$ \texttt{=} $y$).

\item
Method calls 
\begin{itemize}
\item
Passing field $o.y$ to formal $x$.

\item
Passing both $x$ and $y$ to different formals.

\item
Etc.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Pitfall: Aliasing}

\begin{question}
What's wrong with this? \uncover<2->{How to fix it?}

\rm
\lstinputlisting{examples/Counter.java}
\end{question}
\note{The postcondition may fail.  ESC/Java shows this.
Note: in Java variables of different types can be aliased, 
due to multiple inheritance of interface types.
}
\end{frame}

\begin{frame}<beamer>[fragile]
\frametitle{Revised Counter to Fix the Problem}

\lstinputlisting{examples/Counter2.java}
\end{frame}

\begin{frame}[fragile]
\frametitle{Pitfall: Representation Exposure}

\lstinputlisting[linerange={1-14}]{examples/SortedInts.java}
\end{frame}

\begin{frame}[fragile]
\frametitle{Pitfall: Representation Exposure}

\begin{question}
What's wrong with this? \uncover<2->{How to fix it?}

\rm
\lstinputlisting[linerange={5-7}]{examples/SortedInts.java}
\lstinputlisting[linerange={16-22}]{examples/SortedInts.java}
\end{question}
\note{The invariant may not hold on entry to the method, 
due to representation exposure.
}
\end{frame}

\begin{frame}<beamer>[fragile]
\frametitle{Revised SortedInts Using Universes (jmlc)}

\lstinputlisting[linerange={1-3}]{examples/SortedInts2.java}
\note{This solution is based on the Universe type/ownership system 
from Peter M\"{u}ller's group (Werner Dietl) at ETH.}
\end{frame}

\begin{frame}<beamer>[fragile]
\frametitle{Revised Using Universes (jmlc)}

\lstinputlisting[linerange={16-29}]{examples/SortedInts2.java}
\end{frame}

\begin{frame}<beamer>[fragile]
\frametitle{Revised Using Owner (ESC/Java2)}

\lstinputlisting[linerange={1-4}]{examples/SortedInts3.java}
\end{frame}

\begin{frame}<beamer>[fragile]
\frametitle{Revised Using Owner (ESC/Java2)}

\lstinputlisting[linerange={17-31}]{examples/SortedInts3.java}
\end{frame}

\begin{frame}
\frametitle{Pitfall: Undefined Expressions}
\begin{question}
What's wrong with this? How to fix it?

\rm
\lstinputlisting[linerange={1-10}]{examples/ScreenPoint.java}
\end{question}
\note{The array out of bounds error is something that ESC/Java2
  detects, but only in the code.  Try it.
}
\end{frame}

\begin{frame}
\frametitle{Protective Version of ScreenPoint}
\lstinputlisting[linerange={1-11}]{examples/ScreenPoint2.java}
\note{See papers by Leavens and Wing on protective interface
  specifications, and papers by Chalin on the semantics of undefined
  expressions. 
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Writing Protective Specifications}

\begin{itemize}
\item
Clauses evaluated left to right.

\item
Short-circuit operators can prevent evaluation.
\begin{itemize}
\item
$G$ \lstinline!&&! $P$, $G$ \lstinline!||! $P$

\item
$G$ \lstinline!==>! $P$, $G$ \lstinline!<==! $P$
\end{itemize}

\item
Use multiple clauses (equivalent to \lstinline!&&!).
\end{itemize}
\note{\lstinline!==>! is implication, and 
      \lstinline!<==! is reverse implication. 
}
\end{frame}


\subsection[Spec Cases]{Multiple Specification Cases}

\begin{frame}
\frametitle{Multiple Specification Cases}

\begin{itemize}
\item
For different preconditions.

\item
May overlap.

\item
Used to specify exceptions.

\item
Used with specification inheritance.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Multiple Specification Cases}
\lstinputlisting[linerange={1-14}]{examples/Aging.java}
\end{frame}

\begin{frame}
\frametitle{Semantics of Multiple Cases}
\transdissolve[duration=0.5]
\includegraphics[width=4.25in]{join-both}
\end{frame}

\begin{frame}
\frametitle{Semantics of Multiple Cases}
\includegraphics[width=4.25in]{join-intersect}
\end{frame}

\begin{frame}[fragile]
\frametitle{Meaning of 'also'}
\begin{lstlisting}
  requires 0 <= a && a <= 150;
  assignable age;
  ensures age == a;
also
  requires a < 0;
  assignable \nothing
  ensures age == \old(age);
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Meaning of `also'}
\begin{lstlisting}
  requires 0 <= a && a <= 150;
  assignable age;
  ensures age == a;
also
  requires a < 0;
  assignable age;
  ensures age == \old(age)
      && \only_assigned(\nothing);
\end{lstlisting}
\note{Can only join where the frames are the same.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Meaning of `also'}

\begin{lstlisting}
  requires (0 <= a && a <= 150) || a < 0;
  assignable age;
  ensures \old(0 <= a && a <= 150)
       ==> (age == a);
  ensures \old(a < 0)
       ==> (age == \old(age)
            && \only_assigned(\nothing));
\end{lstlisting}
\note{The original is easier to read than this desugared version,
      which is the point of having multiple cases.
      This last version could of course be simplified a bit.
}
\end{frame}

\begin{frame}
\frametitle{Client's View of Multiple Cases}

Client can verify by:
\begin{itemize}
\item
Picking one spec case.
\begin{itemize}
\item
Assert precondition.

\item
Assume frame and postcondition.
\end{itemize}

\item
Picking several cases.
\begin{itemize}
\item
Compute their join.

\item
Assert joined precondition.

\item
Assume frame and joined postcondition.
\end{itemize}
\end{itemize}
\note{Conditions must be adapted to the actual parameters by substitution...}
\end{frame}

\begin{frame}
\frametitle{Implementor's View of Multiple Cases}

\begin{itemize}
\item
Verify each case, or

\item
Verify their join.
\end{itemize}
\note{Assume each precondition and assert each postcondition,
or assume the disjunction of the preconditions, and verify the
conjunction of implications.
}
\end{frame}


\begin{frame}
\frametitle{Background for Specifying Exceptions}

Java Exceptions:
\begin{itemize}
\item
Unchecked (RuntimeException):
\begin{itemize}
\item
Client avoidable (use preconditions).

\item
Implementation faults (fix them).
\end{itemize}

\item
Checked:
\begin{itemize}
\item
Clients can't avoid (efficiently).

\item
Condition simultaneous with use (permissions).

\item
Alternative returns (not found, EOF, $\ldots$).
\end{itemize}
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{When to Specify Exceptions}

Unchecked exceptions:
\begin{itemize}
\item
Don't specify them.

\item
Just specify the normal cases.
\end{itemize}

Checked exceptions
\begin{itemize}
\item
Specify them.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{JML Features for Exception Specification}

\begin{itemize}
\item
\lstinline!exceptional_behavior! spec cases.

\item
\lstinline!signals_only! clause.

\item
\lstinline!signals! clause.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Exceptional Specification Example}
\lstinputlisting[linerange={1-6}]{examples/Actor.java}
\end{frame}

\begin{frame}[fragile]
\frametitle{Exceptional Specification Example}
\lstinputlisting[linerange={8-19}]{examples/Actor.java}
\end{frame}

\begin{frame}
\frametitle{Underspecification of Exceptions}
\begin{question}
How would you underspecify this?
\end{question}
\note{That is, how to write the specification and ignore the
  exceptional case?
}
\end{frame}

\begin{frame}<beamer>
\frametitle{Underspecification of Exceptions}
\lstinputlisting[linerange={8-13}]{examples/ActorUnderspecified.java}
\end{frame}


\begin{frame}[fragile]
\frametitle{Behavior Specification Cases}

\lstinline!normal_behavior!, \lstinline!exceptional_behavior!
\begin{itemize}
\item
``Heavyweight''

\item
Say how method can terminate.

\item
Maximally permissive/useless defaults.
\end{itemize}

\lstinline!behavior!
\begin{itemize}
\item
Doesn't specify normal/exceptional.

\item
Can use to underspecify normal/exceptional.
\end{itemize}
\note{Generally, the defaults for boolean clauses are ``true''.
But for frames (assignable) the default is \lstinline!\everything!,
as that is most permissive.
And \lstinline!signals_only! has its standard default (see below).
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Lightweight Specification Cases}

\begin{itemize}
\item
Don't use a behavior keyword.

\item
Most defaults technically \lstinline!\not_specified!.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Semantics of signals\_only}

\begin{itemize}
\item
\lstinline!signals_only! $T_1, \ldots, T_n$\texttt{;}
\begin{itemize}
\item
Exception thrown to caller must subtype
one $T_1, \ldots, T_n$.
\end{itemize}

\item
Can't use in \lstinline!normal_behavior!

\item
At most one \lstinline!signals_only! clause per spec case.

\item
Default for omitted clause
\begin{itemize}
\item
if method declares \lstinline!throws! $T_1, \ldots, T_n$,
\newline
then \lstinline!signals_only! $T_1, \ldots, T_n$\texttt{;}.

\item
else \lstinline!signals_only \nothing;!.
\end{itemize}
\end{itemize}
\note{Assuming $n > 0$.
  The default only applies to lightweight spec cases and
  heavyweight exceptional_behavior spec cases.
}
\end{frame}

\begin{frame}
\frametitle{Signals Clause}

\begin{itemize}
\item
Specifies, when exception thrown,
\begin{itemize}
\item
State of exception object.

\item
Other state.
\end{itemize}

\item
Not very useful.

\item
Tip: normally omit.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Pitfalls in Exceptional Specification}
\begin{itemize}
\item
Can't return normally \emph{and\/} throw exception.

\item
So preconditions shouldn't overlap.
\end{itemize}

\begin{question}
What happens if they overlap?
\end{question}
\note{The specification will be unsatisfiable (for the overlap).
      Thanks to Erik Poll for first pointing this out.
      In many such cases you want to use a single Behavior.
      See examples/Factor.java for how to do this.
}
\end{frame}

\begin{frame}
\frametitle{Exercise Using Multiple Cases}

\begin{exercise}
Specify the $3x+1$ or ``hailstone'' function, $h$,
such that:

\begin{displaymath}
h(n) = 
\left\{
\begin{array}{ll}
(3 \times n + 1)/2, & \mbox{if $n>0$ is odd} \\
n / 2,              & \mbox{if $n>0$ is even}
\end{array}
\right.
\end{displaymath}

and $h$ is undefined on negative numbers.
\end{exercise}
\end{frame}

\begin{frame}[fragile]
\frametitle{My Answer}
\lstinputlisting[linerange={3-11}]{examples/Hailstone.java}
\note{Explain the nesting of spec cases by conjoining the outer
  requires onto each inner requires.
  Why not specify an exception?  It's not under user control.
}
\end{frame}


%\part{Advanced JML}

\section[Abstr.]{Abstraction in Specification}

\subsection[Motivation]{Motivation and Overview}

\begin{frame}
\frametitle{Abstraction in Specification}

Why use abstraction?
\begin{itemize}
\item
Ease maintainence by information hiding.

\item
Readability:
\begin{itemize}
\item
Avoid quantifiers.

\item
Repeated expressions.
\end{itemize}

\item
Specify when no fields available \\
Java \textbf{\texttt{interface}}s.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Features Supporting Abstraction}

\begin{itemize}
\item
\lstinline!model! fields and \lstinline!represents! clauses.

\item
\lstinline!pure model! methods.

\item
\lstinline!pure! methods.

\item
\lstinline!protected! invariants, spec cases, etc.

\item
\lstinline!private! invariants, spec cases, etc.
\end{itemize}
\end{frame}

\subsection[Views]{Views of Specifications}

\begin{frame}
\frametitle{Kinds of Clients}
\includegraphics[width=4.25in]{visibility-modifiers}
\note{The public clients are all most specification languages discuss.
  This and some other parts on visibility and information hiding
  are from work by Leavens and Mueller presented at ICSE 2007.
}
\end{frame}

\begin{frame}
\frametitle{Views of Specifications}
\begin{tabular}{ll}
         & Declarations in $C$ \\
Modifier & visible to code in: \\
\hline
Private          & $C$ \\
(None = package) & $C$'s package \\
Protected        & $C$'s subclasses, \\
                 & $C$'s package \\
Public           & all
\end{tabular}
\note{ESC/Java2 currently ignores visibility.
But checked by other JML tools.
}
\end{frame}

\begin{frame}
\frametitle{Privacy and Modular Soundness}
Specifications visible to module $M$:
\begin{itemize}
\item
Can only mention members visible to $M$.
\begin{itemize}
\item
For maintenance.

\item
For understandability.
\end{itemize}

\item
Must contain all of $M$'s obligations.
\begin{itemize}
\item
For sound modular verification.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Privacy and Modular Soundness}
\begin{question}
Can private fields be mentioned in public specifications?
\end{question}

\pause
\begin{question}
Can non-trivial preconditions be hidden from clients?
\end{question}

\pause
\begin{question}
What should a client assume is the precondition of \\
a method with no visible specification cases?
\end{question}

\pause
\begin{question}
If invariant \emph{Inv} depends on field $f$, \\
can \emph{Inv} be less visible than $f$?
\end{question}
\note{No to 1,2 and 4, as these violate the principles.
The answer to 3 is ``true''.
}
\end{frame}

\subsection[Model]{Data Abstraction with Model Fields}

\begin{frame}[fragile]
\frametitle{Model Fields for Data Abstraction}

Model fields:
\begin{itemize}
\item
Just for specification.

\item
Abstraction of Java fields.

\item
Value from \lstinline!represents!.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Model Field in an Interface}
\lstinputlisting{examples/Gendered.java}
\note{We use \lstinline!instance! because by default fields in Java
  interfaces are static.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Represents Clauses}
\lstinputlisting[linerange={1-5,16-19}]{examples/Animal.java}
\end{frame}

\begin{frame}
\frametitle{Correctness with Model Fields}
\includegraphics[width=4.25in]{model-correctness}
\end{frame}


\section[Subtypes]{Subtyping and Specification Inheritance}

\begin{frame}
\frametitle{Modular Reasoning}
\begin{itemize}
\item
Prove code using specifications of other modules.

\item
Sound, if each module satisfies specification.
\end{itemize}

~ 

Scales better than whole-program reasoning.
\end{frame}

\begin{frame}
\frametitle{Modular Verification Problem}
\end{frame}


\section[ESC]{ESC/Java2}

\section*{Conclusions}

%\appendix

\end{document}
