\documentclass[
pdf,
%a4,
nocolorBG,
%colorBG,
slideColor,
%accumulate,
%draft,
erik,
%frames,
]{prosper}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{alltt}
\usepackage{pstricks,pst-node,pst-text,pst-3d}
\usepackage{textcomp}
%\usepackage{colordvi}
\newcommand{\Red}[1]{{\red #1}}
\usepackage[all]{xy}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newrgbcolor{Yellowish}{0.90 0.85 0.650}

%\newrgbcolor{red}{1 0 0}
%\newrgbcolor{purple}{0.4 0 0.7}
%\newrgbcolor{lightpurple}{0.63 0.13 0.94}

%\newrgbcolor{lime}{0.73 1 0}
\newrgbcolor{green}{0.133 0.56 0} % lichter
%\newrgbcolor{green}{0.10 0.43 0}

%\newrgbcolor{knalblue}{0 0 1}
\newrgbcolor{blue}{.2 .36 .77}
%\newrgbcolor{darkblue}{0.28 0.24 0.55}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\embf}[1]{\textit{\textbf{#1}}}
\newcommand{\rmbf}[1]{\textrm{\textbf{#1}}}
\newcommand{\ttbf}[1]{\mbox{\tt \textbf{#1}}}
\newcommand{\code}[1]{{\rm \texttt{\textbf{\small #1}}}}



\myitem{1}{\mbox{{$\bullet$}}}
\newcommand{\old}     {\(\backslash\)old}
\newcommand{\vooralle}{\(\backslash\)forall}
\newcommand{\everything}{\(\backslash\)everything}
\newcommand{\nothing}{\(\backslash\)nothing}
\newcommand{\nonnull} {non\verb|_|null}
\newcommand{\result}  {\(\backslash\)result}
\renewcommand{\familydefault}{phv}
\renewcommand{\rmdefault}{phv}
\newif\ifignore

\newrgbcolor{Bluish}{0.9 0.9 1.0}
\newcommand{\doos}[1]{\psshadowbox[fillstyle=solid,
                        fillcolor=Bluish,
                        framearc=0.2,
                        framesep=2mm]
                        {#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{\embf{\blue 
       {\huge Introduction to JML
      }}}
\author{\embf{\Large{\red Erik Poll}}
       }
\institution{\embf{\large University of Nijmegen}}
\slideCaption{{\blue Erik Poll - ESC/Java2 Tutorial - June 2004 -  JML}}
%\Logo{{\blue Erik Poll}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle 

\boldmath

\ifignore
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{Test \hfill}

{\Large Large}
{\large large}
{\normalsize normal}
niks
{\small small}
{\footnotesize footnote}
{\scriptsize script}
{\tiny tiny}

{\bf bf}
{\rm rm}
{\it it}
{\sf sf}
{\sc sc}

\textit{textit}
\textrm{textrm}
\textbf{textbf}
\textsf{textsf}
\textsc{textsc}

\end{slide}
\fi


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{Outline of this talk}
\vspace*{-2ex}

What this set of slides aims to do
\begin{itemize}
\item introduction to JML
\item overview of tool support for JML (jmlrac, jmlunit, escjava)
\item explain idea of extended static checking and difference with runtime assertion checking
\item some more ESC/Java2 tips
\end{itemize}


\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{{\Large \red The Java Modeling Language JML}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\overlays{2}{
\begin{slide}{JML {\footnotesize {\black by Gary Leavens et al.}}}
\vspace*{-3ex}
{\blue Formal specification language} for Java 
\medskip
\begin{itemize}
\item
to specify behaviour of Java classes
\item
to record design \&implementation decisions
\end{itemize}
\medskip
by adding {\green assertions} to Java source code, eg
\medskip
\begin{itemize}
\item ~{\green preconditions}
\item ~{\green postconditions}
\item ~{\green invariants}
\end{itemize}

\medskip

as in Eiffel (Design-by-Contract), but more expressive.

\medskip

\fromSlide{2}{\doos{Goal: JML should be easy to use for any Java programmer.}}


\end{slide}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{JML}
\vspace*{-3ex}

To make JML easy to use:

\medskip
\begin{itemize}
\item
JML assertions are added as comments in .java file,

between {\green \texttt{\textbf{\small /*@}}} \ldots {\green \texttt{\textbf{\small @*/}}},
or after {\green \texttt{\textbf{\small //@}}},

\medskip
\item
Properties are specified as Java boolean expressions,
extended with a few operators
({\green \old, \vooralle, \result, \ldots}).

\medskip
\item
using a few keywords
({\green \code{requires},
\code{ensures},
\code{signals},
\code{assignable},
\code{pure},
\code{invariant},
\code{non\_null},
\ldots})

\end{itemize}

\end{slide}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{requires, ensures}
\vspace*{-3ex}

{\blue Pre-} and {\blue post-conditions} for method can be specified.

\begin{alltt}
\texttt{\textbf{\small
{\green /*@}{\blue requires} amount >= 0;
    {\blue ensures}  balance == \old(balance)-amount &&
              \result == balance;
{ \green  @*/}
  public int{\green debit}(int amount) \{ 
    ...
  \}
}}
\end{alltt}

Here \code{\old(balance)} refers to the value of \code{balance}
before execution of the method.


\end{slide}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{requires, ensures}
\vspace*{-3ex}

JML specs can be as strong or as weak as you want.


\begin{alltt}
\texttt{\textbf{\small
{\green /*@}{\blue requires} amount >= 0;
    {\blue ensures} {\blue true};
{ \green  @*/}
  public int{\green debit}(int amount) \{ 
    ...
  \}
}}
\end{alltt}

This default postcondition ``\code{ensures true}'' can be omitted.

\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{Design-by-Contract}
\vspace*{-3ex}

Pre- and postconditions define a {\blue contract} 
between a class and its clients:
\medskip
\begin{itemize}
\item
Client must {\green ensure precondition}
and may {\green assume postcondition}
\item
Method may {\green assume precondition}
and must {\green ensure postcondition}
\end{itemize}

\bigskip

Eg, in the example specs for \code{debit}, it is the obligation of
the client to ensure that \code{amount} is positive.
The \code{requires} clause makes this {\green explicit}.

\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{signals}
\vspace*{-3ex}

{\blue Exceptional postconditions} can also be specified.
\vspace*{-1ex}
\begin{alltt}
\texttt{\textbf{\small
{\green /*@}{\black requires} amount >= 0;
    {\black ensures}  true;
    {\blue signals (ISOException e) 
               amount > balance         &&
               balance == \old(balance) &&
               e.getReason()==AMOUNT_TOO_BIG;}
{\green   @*/}
  public int{\green debit}(int amount) \{ 
   ...
  \}
}}
\end{alltt}

\end{slide}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{invariant}
\vspace*{-3ex}
{\blue Invariants} (aka {\em class} invariants) are properties that must be maintained by all methods, eg
\begin{alltt}
\texttt{\textbf{\small{
 public class {\green Wallet} \{
  public static final short{\green MAX_BAL} = 1000;
  private short{\green balance};
  {\green /*@}{\blue invariant 0 <= balance &&
                      balance <= MAX_BAL;}
  {\green   @*/}
  ...  }}}
\end{alltt} %}

Invariants implicitly included in all pre- and postconditions.

Invariants must {\em also} be preserved if exception is thrown!
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{invariant}
\vspace*{-4ex}
\begin{alltt}
\texttt{\textbf{\small public class{\green Directory} \{
 private File[]{\green files};
{\green /*@}{\blue invariant} 
     files != null    
     &&
     ({\red\vooralle} int i; 0 <= i && i < files.length;
                   ; files[i] != null &&
                     files[i].getParent() == this);
  {\green @*/}
}}
\end{alltt} %}

Invariants document design decisions.\\
Making them {\green explicit} helps in understanding the code.
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{non\_null}
\vspace*{-4ex}

Many invariants, pre- and postconditions are about references not being null.
{\blue non\_null} is a convenient short-hand for these.

\begin{alltt}
\texttt{\textbf{\small public class Directory \{

  private{\green /*@}{\blue non\_null}{\green @*/} File[] files;

  void createSubdir({\green{/*@}}{\blue non\_null}{\green @*/} String name)\{
   ...
  Directory{\green /*@}{\blue non\_null}{\green @*/} getParent()\{
   ...
}}
\end{alltt} %}

\end{slide}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{assert}
\vspace*{-3ex}

An {\blue \texttt{\textbf{\small assert}}} clause specifies
a property that should hold at some point in the code, eg.
\begin{alltt}
\texttt{\textbf{\small if (i <= 0 || j < 0) \{
      ...
  \} else if (j < 5) \{
     {\green //@}{\blue assert i > 0 && 0 < j && j < 5;}
      ...
  \} else \{
     {\green //@}{\blue assert i > 0 && j > 5;}
      ...
  \}  }}
\end{alltt}

\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{assert}
\vspace*{-3ex}

JML keyword \code{assert} now also in Java (since Java 1.4).

\medskip

Still, assert in JML is more expressive, for example in

\begin{alltt}
\texttt{\textbf{\small  ...
  for (n = 0; n < a.length; n++) 
       if (a[n]==null) break;
{\green /*@}{\blue assert (\vooralle int i; 0 <= i && i < n; 
                            a[i] != null);                }
  {\green @*/} }}
\end{alltt} 



\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{assignable}
\vspace*{-3ex}

{\blue Frame properties} limit possible side-effects of methods.


\begin{alltt}
\texttt{\textbf{\small {\green /*@}   requires amount >= 0;
     {\blue assignable} balance;
         ensures balance == \old(balance)-amount;
{ \green  @*/}
  public int{\green debit}(int amount) \{ 
    ...
}}
\end{alltt}
Eg. \code{debit} will {\em only} assign to field \code{balance}.

NB this does {\em not} follow from the post-condition.

\medskip

Default assignable clause: \code{assignable \everything}.

\end{slide}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{pure}
\vspace*{-3ex}

A {\blue method without side-effects} is called {\blue pure}.

\begin{alltt}
\texttt{\textbf{\small
  public{\green /*@}{\blue pure}{\green @*/} int getBalance()\{...

  Directory{\green /*@}{\blue pure non\_null}{\green @*/} getParent()\{...

}}
\end{alltt}

Pure method are implicitly \code{assignable \nothing}.

\medskip

Only pure methods can be used {\em in} specifications.

\end{slide}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\overlays{4}{\begin{slide}{Tools for JML}
\vspace*{-2ex}

\begin{itemize}
\fromSlide{2}{\item$\!$ {\red parsing} and {\red typechecking}} 
\fromSlide{3}{\item$\!$ {\red runtime assertion checking}:\\
      {\blue test} for violations of assertions {\blue during execution}\\
      {\green jmlrac}}
\fromSlide{4}{\item$\!$ {\red extended static checking}:\\
      {\blue prove} 
      that contracts are never violated
      {\blue at compile-time}\\
      {\green ESC/Java2}\\

      This is program verification, not just testing}
\end{itemize}
\end{slide}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{Runtime vs static checking}
\vspace*{-3ex}

One of the assertions below is wrong:
\begin{alltt}
\texttt{\textbf{\small  if (i <= 0 || j < 0) \{
      ...
   \} else if (j < 5) \{
       //@ assert i > 0 && 0 < j && j < 5;
       ...
   \} else \{
       //@ assert i > 0 && j > 5;
       ...
   \}  
}}\end{alltt}


Runtime assertion checking {\blue {\em may}} detect this.

ESC/Java2 {\blue {\em will}} detect this.

\end{slide}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\overlays{4}{
\begin{slide}{jmlrac}
\vspace*{-3ex}
{\blue jmlrac compiler} by Gary Leavens et al. at Iowa State Univ.

\begin{itemize}
\item
translates {\blue JML assertions}
into {\blue runtime checks}:
\begin{quote}
during execution, {\em all} assertions are tested and
any violation of an assertion produces an Error
\end{quote}
\fromSlide{2}{\item$\!$
{\blue cheap \& easy} to do as part of
existing testing practice}
\fromSlide{2}{\item$\!$
{\blue better testing}, because {\green more properties} are tested, at {\green more places} in the code}
\end{itemize}
\fromSlide{3}{Of course, an assertion violation can be {\em error in code} {\green or} {\em error in specification}.}

\medskip
\fromSlide{4}{
The {\blue jmlunit} tool combines jmlrac and {\green unit testing}}

\end{slide}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{jmlrac example}
\vspace*{-3ex}

jmlrac can generate complicated test-code for free.  Eg for
\begin{alltt}
\texttt{\textbf{\small{\green /*@} ...
    {\blue signals (Exception) 
                 balance == \old(balance);}
 {\green  @*/}
  public int{\green debit}(int amount) \{ ...
}}
\end{alltt} %}
it will test that {\green if \code{debit} throws an exception,
the balance hasn't changed, and all invariants still hold}.

\bigskip

{\scriptsize jmlrac even checks \code{\vooralle} if the domain of 
quantification is finite.}

\end{slide}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\overlays{5}{
\begin{slide}{ESC/Java2}
\vspace*{-3ex}

{\blue Extended static checker}
by Rustan Leino et. al at Compaq.
\begin{itemstep}
\item$\!$
{\blue {\em tries} to {\em prove} correctness of specifications,}\\
{\green at compile-time, fully automatically}
\item$\!$
\Red{\em not sound}: ESC/Java may warn about correctly specified code
\item$\!$
\Red{\em not complete}: ESC/Java may accept incorrectly specified code
\item$\!$
 but {\blue finds lots of potential bugs quickly}
\item
good at proving absence of runtime exceptions
{\scriptsize (eg Null-, ArrayIndexOutOfBounds-, ClassCast-)}
and verifying relatively simple properties.
\end{itemstep}

\end{slide}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\overlays{1}{\begin{slide}{More JML tools}

\vspace*{-2ex}
\begin{itemize}
\item$\!$ {\blue javadoc-style documentation}:  {\green jmldoc}
\item
Other red {\blue verification} tools:
\begin{itemize}
\item$\!$ {\green LOOP tool + PVS} (Nijmegen)
\item$\!$ {\green JACK} (Gemplus/INRIA)
\item$\!$ {\green Krakatoa tool + Coq} (INRIA)
\end{itemize}
These tools (also) aim at {\blue interactive} verification of complex
properties,
whereas
ESC/Java2 aims at {\blue automatic} verification of relatively simple
properties.
\item runtime {\blue detection of invariants}: {\green Daikon} (Michael Ernst, MIT)
\item$\!$ {\blue model-checking} muli-threaded programs: {\green Bogor} (Kansas State)
\end{itemize}

\end{slide}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{{\Large \red More ESC/Java tips \\ to be added to David's ?}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{Modular reasoning (1)}
\vspace*{-3ex}

ESC/Java2 reasons about every method individually.\\
So in

\begin{verbatim}
class A{
  byte[] b;

  public void n() { b = new byte[20]; }

  public void m() { n();
                    b[0] = 2;
                    ... }
}
\end{verbatim}

ESC/Java2 warns that \code{b[0]} may be a null dereference here,
even though you can see that it won't be.
\end{slide}

\begin{slide}{Modular reasoning (1)}
\vspace*{-3ex}
To stop ESC/Java2 complaining: add a postcondition


\begin{verbatim}
class A{
  byte[] b;

  //@ ensures b != null && b.length = 20;
  public void n() { a = new byte[20]; }

  public void m() { n();
                    b[0] = 2;
                    ... }
}
\end{verbatim}
So: properties of method that you rely on have to be made explicit.

And: subclasses that override method have to preserve these.

\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{Modular reasoning (2)}
\vspace*{-3ex}

Similarly, ESC/Java will complain about {\tt b[0] = 2} in

\begin{verbatim}
class A{
  byte[] b;

  public void A() { b = new byte[20]; }

  public void m() { b[0] = 2;
                    ...  }
}
\end{verbatim}
Maybe you can see that this is a spurious warning,
though this will be harder than in the previous example:
you'll have to inspect {\em all} constructors and {\em all} methods.

\end{slide}


\begin{slide}{Modular reasoning (2)}
\vspace*{-3ex}

To stop ESC/Java2 complaining here: add an invariant

\begin{verbatim}
class A{
  byte[] b;
  //@ invariant b != null && b.length == 20;
          // or a weaker property for b.length ?

  public void A() { b = new byte[20]; }

  public void m() { b[0] = 2;
                    ...  }
}
\end{verbatim}


So again: properties you rely on have to be made explicit.

And again: subclasses have to preserve these properties.

\end{slide}






\end{document}

