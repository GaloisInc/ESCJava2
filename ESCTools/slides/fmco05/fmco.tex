% $Id$
\documentclass{llncs}

\usepackage{verbatim}
% in fancyvrb, you can split input and number lines...
\usepackage{fancyvrb}
\usepackage{color}

\renewcommand{\textfraction}{0.15}
\renewcommand{\floatpagefraction}{0.66}

\def\old{\texttt{\char'134old}}
\def\result{\texttt{\char'134result}}
\def\everything{\texttt{\char'134everything}}
\def\nothing{\texttt{\char'134nothing}}

 \pagestyle{plain} % turn on pagenumbering - remove in final version
\begin{document}

\title{Beyond Assertions: 
       Advanced Specification and Verification with JML and ESC/Java2}

\author{Erik Poll\inst{1}
        \and Patrice Chalin\inst{2}
        \and David Cok\inst{3}
        \and Joe Kiniry\inst{4}
        \and Gary T. Leavens\inst{5} 
       }


\institute{Radboud University Nijmegen, the Netherlands
           \and 
           Concordia University, Montr\'eal, Qu\'ebec, Canada
           \and
           Kodak Eastman Company, R\&D Laboratories, Rochester, New York, USA
           \and
           University College Dublin, Ireland
           \and
           Iowa State University,  Ames, Iowa, USA 
          }

% ``Notes-to-authors''
% \newcommand{\NTA}[1]{\begin{quotation}\textsf{#1}\end{quotation}}
% \newcommand{\NTA}[1]{[NTA\footnote{#1}]}
%
\newcommand{\GMARGIN}[1]{\marginpar{\textcolor{blue}{\sf\scriptsize #1}}}
\newcommand{\MARGIN}[1]{\marginpar{\sf\scriptsize #1}}
\newcommand{\COMMENT}[1]{{\sf\scriptsize  #1}}
%\newcommand{\MARGIN}[1]{}
%\newcommand{\COMMENT}[1]{}

\newcommand{\figref}[1]{\figurename~\ref{#1}}
\newcommand{\secref}[1]{Section~\ref{#1}}

\newcommand{\extracite}[1]{} % {\cite{#1}}

\maketitle

\begin{abstract}
Many state-based specification languages, including the Java Modeling Language
(JML), contain at their core specification constructs familiar to most
computer science and software engineering undergraduates: e.g., assertions,
pre- and postconditions, and invariants.  Unfortunately, these constructs are
not sufficiently expressive to permit formal modular verification of programs
written in modern object-oriented languages like Java. The necessary extra
constructs for specifying an object-oriented module include the less familiar
frame properties, datagroups, and ghost and model fields.  These constructs
help specifiers deal with potential problems, including unexpected side
effects, aliasing, class invariants, inheritance, and lack of information
hiding.
%
This tutorial focuses on these constructs, explaining their meaning while
illustrating how they can be used to address the stated problems.
\end{abstract}

\section{Introduction}

Textbooks on program verification
\extracite{Apt-Olderog97,Francez92,Loeckx-Sieber87} typically explain the
notions of pre- and postconditions, loop invariants, and so on for toy
programming languages.
%
The goal of this paper is to explain some of the more advanced concepts that
are necessary in order to allow the formal modular verification of
(sequential) programs written in a popular mainstream object-oriented
language: Java.
%
The Java Modeling Language (JML)
\cite{STTT05,Leavens-Baker-Ruby06,Leavens-etal05a}, a Behavioral Interface
Specification Language (BISL) \cite{Wing90a} for Java, will be our
notation of choice for expressing specifications.

The reader is assumed to be familiar with the basics of Design by
Contract (DBC) \cite{Meyer97} or Behavioral Interface Specifications (BISs)
and the central role played by assertions in these approaches.
%
Readers without this background may wish to consult one of several
books or articles offering tutorials on the subject
\cite{Hoare69,Liskov-Guttag01,Mitchell-McKim02,Meyer92a,Meyer97,Morgan94}.
%
A tutorial that explains these basic ideas using JML is also available
\cite{Leavens-Cheon05}.

% Note that, as a tutorial, this paper does not present any new results.
% However, we believe that the ideas are of interest to the wider
% community of people interested in formal methods for object-oriented
% languages.

\subsection{Tool Support}
%
\MARGIN{Purpose (as far as I can tell --PC): mention tools support; introduce
  ESC/Java2 and motivate the need for the advanced features talked about in
  this paper (viz. without them static verification cannot be effective).}
%
% \MARGIN{FYI: I'm not sure why the content of this section is as it is.
%   I've revised it while kept the original focus on RAC vs. SV. Maybe we should
%   just talk about ``tool support'' in general :).  I can probably guess that
%   the section was originally motivated by the actual tutorial material in
%   which jmlc and ESC/Java2 are discussed, but we talk about neither of these
%   specifically in the paper, ... right? Well actually, we do talk about
%   ESC/Java2, but not jmlc. In any case I will leave the content as is for
%   now. --PC}

Tools useful for checking that JML annotated Java modules meet their
specifications, fall into two main categories:%
%
\footnote{Of course, there are several other kinds of tool available for use
  with JML \cite{STTT05}.}
%
\begin{itemize}
  \item runtime assertion checking (RAC) tools, and
  \item static verification (SV) tools.
\end{itemize}
%
\MARGIN{Trim this sentence on origins? If we do, maybe remove reference to
  Rosenblum a few lines down? --PC}
These also represent two complementary forms of assertion checking, the
foundations of which were laid out before the 1950's in the pioneering work
of Goldstine, von Neumann and Turing \cite{Jones03}.
%
% RAC:
Runtime assertion checking involves the testing of specifications during
program execution; any violations result in special errors being reported.
%
The idea of checking \emph{contracts} at runtime
goes back to (at least) Rosenblum's work on APP
\cite{Rosenblum92,Rosenblum95}\MARGIN{A candidate for citation trim? --PC}
and was popularized by Eiffel \cite{Meyer97}.
The main RAC tool for JML is \texttt{jmlc} \cite{Cheon-Leavens02b}.
% Jass:
RAC support for JML is also planned for the next release of the Jass tool
\cite{Bartetzko-etal01}.

In static verification,
logical techniques are used to prove that no violations of
specifications can happen at runtime.
The adjective \emph{static\/} emphasizes that verification
happens by means of a static analysis of the code, i.e., without running it.
%
%% There are two main kinds of static verifiers:
%% \begin{itemize}
%%   \item Extended Static Checking (ESC) tools that perform efficient and fully
%%     automatic checking at the cost of being potentially unsound and
%%     incomplete,
%%   \item full program verification (PV) tools that are designed to be sound and
%%     complete, at the expense of requiring much more human intervention and
%%     insight during the verification process.
%% \end{itemize}
%
Program verification tools supporting JML include: e.g., JACK \cite{JACK}, KeY
\cite{KeY}, Krakatoa \cite{Krakatoa}, LOOP \cite{LOOP}, and Jive
\cite{Jive00}.  In this paper we will focus on ESC/Java2 \cite{Cok-Kiniry04},
the main extended static checker for JML.
% the successor tool to ESC/Java \cite{Flanagan-Et-Al02}.

RAC and SV tools have complimentary strengths.
As compared to runtime assertion checking, static verification can give
stronger guarantees and it can give them earlier.
% at an earlier stage in the software development life cycle. 
However, these advantages come at a price:
%
SV tools generally require fairly complete specifications, not only for the
module being checked, but also for the modules and libraries that it depends
on. Furthermore, in order to be effective, and keep false positives to a
minimum, SV tools require specifications to make use of some of the advanced
features described in this paper.

\subsection{Outline}

The remainder of the paper is organized as follows.
The basic notation used in JML for method contracts
and invariants is covered in \secref{Sec:basics}.
\secref{Sec:assignable} explains frame properties, and \secref{Sec:model} model fields.
The treatment of behavioral subtyping is given in \secref{Sec:behsubtyping}.
\secref{Sec:ghost} explains ghost fields.
\secref{Sec:ownership} introduces the JML notations that deal with
ownership and aliasing.  
Finally, conclusions and related work are given in \secref{Sec:conclusion}.

\section{JML Basics: Pre- and Postconditions, and Invariants}
\label{Sec:basics}

%% \MARGIN{Erik: Explain \texttt{non\_null}, giving forward ref to
%% \figref{Example:alarmclock} where it is used. PC: this has not been done yet.
%% Maybe it can merely be mentioned with the alarm clock example?}
%
% Intro: Clock examples.
%
This section examines the specification and implementation of
various kinds of clock.  In doing so, we review basic concepts like
method contracts and class invariants and introduce their JML notation.

\subsection{Method contracts}

% intro: requires, ensures.
%
We begin with the specification of a \texttt{TickTockClock} as given in
\figref{Example:TickTockClock}.
\begin{figure}[tbp]
%
\VerbatimInput[numbers=left]{TickTockClock.java}
%
\vspace*{-2ex} % to fit this on one page
\caption{JML specification for \texttt{TickTockClock}.
  The datagroup \texttt{\_time\_state}, the
  associated \texttt{assignable} clauses and \texttt{in} clauses are
  explained later, in Section~\ref{Sec:assignable}.} 
\label{Example:TickTockClock}
\end{figure}
This example specification illustrates basic
method contracts formed from:
%
\begin{itemize}
  \item preconditions (introduced by the \texttt{requires} keyword), and
  \item postconditions (\texttt{ensures}).
\end{itemize}
An example of such a contract is found in the specification of the
method \texttt{getHour()} on lines 17--19.  The JML specification for
this method is written in front of the method itself, and is found in
stylized Java comments 
% special annotations, which look like Java comments 
that begin with an at-sign (\texttt{@}).

% NOTE: this doesn't seem to be quite the right time to introduce the notion
% of non-null types because, in fact, the given clock spec doesn't make use of
% reference types :). --PC
%
%% Ignoring some details for the moment,\footnote{
%% E.g., that declarations of reference types are non-null by default in JML.
%% % The omitted details are that JML, by default, asserts that formal
%% % parameters and the result of a method are not null.
%% }

% Implicit pre- and post-conditions.
% 
\GMARGIN{implicit clauses}
%
A method contract without an explicit \texttt{requires} clause has
an implicit precondition of ``$true$''.  Thus, such a
method imposes no requirements on its callers.  This default means
that the \texttt{requires} clause written for \texttt{getHour()} could
have been omitted entirely.
Similarly, the default postcondition 
when none is explicitly given in an \texttt{ensures} clause is also
``$true$'', which says that the method makes no guarantees to
its caller.
In \figref{Example:TickTockClock}, the constructor (on lines 12--15)
and the method \texttt{getMinute()} (on lines 21--22) are
examples of class members with implicit requires clauses.

Note that the assertion expressions appearing in the \texttt{requires} and
\texttt{ensures} clauses are written using a Java-like syntax.
%
\GMARGIN{\old}
\GMARGIN{\result}
%
In postconditions of (non-\texttt{void}) methods, \result\ can be used to refer to the 
value being returned by the method.
The only other JML specific operator used in this clock specification is the
\old$()$ operator, which is used in the \texttt{ensures} clauses of
\texttt{tick} (on lines 30--32).  The 
expression \old$(e)$ refers to the value of $e$ in the method's pre-state,
i.e.\ the state just before the method was invoked.

% \GMARGIN{multiple clauses}
Preconditions and postconditions can be split over multiple \texttt{requires}
and \texttt{ensures} clauses, as illustrated for the postcondition of 
\texttt{getSecond()} (on lines 24--25).  Multiple \texttt{ensures}
clauses, or multiple \texttt{requires} clauses, are equivalent to
a single clause consisting of the conjunction (\texttt{\&\&}) of their
respective assertions.

Method contracts, like the contract of \texttt{tick()} on lines 28--38
of \figref{Example:TickTockClock}, can be written as one or
more \emph{specification cases} combined with the keyword \texttt{also}.
Each specification case is a mini contract in itself, having a precondition
and postcondition (either explicit or implicit)--as well as other clauses
which will be covered below.
Use of specification cases allows developers to structure their
specifications and to, literally, break it up into (generally) distinct cases.

The contract for \texttt{tick()},
which is somewhat contrived for illustrative purposes,
highlights to clients that its behavior 
essentially has two cases of interest: i.e., either 
\begin{itemize}
  \item the clock seconds are less than 59 and the seconds are incremented by one,
    or
  \item the clock seconds are at 59 and they will be wrapped back to 0.
\end{itemize}
%
We note in passing that the specification of \texttt{tick()} is incomplete, as
it might appear during the development of the \texttt{TickTockClock} class.
Informal comments, line the one on line 37 can be useful in
remembering what remains to be formalized, or in escaping from
formalism, although they do not help in verification. 

\subsection{Purity}
%
In the DBC approach, only query methods can be used in assertion expressions
because they are required to be side-effect free \cite{Meyer97}.
% 
The corresponding concept in JML is known as method \emph{purity}; i.e. only methods
declared as \texttt{pure} can be used in assertion expressions. 
E.g., since the method \texttt{getSecond()} is declared \texttt{pure}, it is
legal to make use of it in the postcondition of \texttt{tick()}.

Notice that the \texttt{TickTockClock} constructor is declared as \texttt{pure}, 
despite the fact 
that it assigns to the fields \texttt{hour}, \texttt{minute} and \texttt{second}.
Such instance field assignments are permitted inside the bodies of constructors
because they are benevolent side-effects---i.e., that have no observable effect
on clients.
%
On the other hand, a constructor would not be permitted to assign to a static
field.
%
Purity, and particularly variants in the strength (restrictiveness) of its
definition are a subject of active research--e.g., a stronger notion of purity
than that of JML has been proposed by Darvas and M\"uller
\cite{DarvasMuller05}.

\subsection{Lightweight vs. heavyweight}

JML actually has two kinds of specification case: lightweight and heavyweight.
%
The specification cases of the \texttt{tick()} method are lightweight.
%
\GMARGIN{heavyweight} 
%
Examples of heavyweight specification cases are those given for the
\texttt{setTime()} method of the \texttt{SettableClock} class given in
\figref{Example:SettableClock}.
%
A heavyweight specification case is easily recognized by the use of a
``behavior'' keyword at the beginning of the case.
%
The contract of \texttt{setTime()} illustrates the two kinds of heavyweight
specification case most often used.
%
\GMARGIN{\texttt{normal\_behavior}}
The first specification case uses the \texttt{normal\_behavior} keyword and it
describes the intended behavior of the method when it returns normally.
%
\GMARGIN{\texttt{exceptional\_behavior}}
%
The second specification case uses the \texttt{exceptional\_behavior} keyword and it
describes the indented behavior of the method when it raises an exception.
%
The latter case will be described at greater length in \secref{Sec:Exceptions}.
Notice that the heavyweight specification cases of \texttt{setTime()} start
with \texttt{public}.
%
\GMARGIN{visibility}
%
This means that the specification cases are visible to clients, and hence, for
example, will be included as a part of client visible documentation generated
using JmlDoc \cite{STTT05}. It also means that these specification cases cannot
refer to \texttt{private} or \texttt{protected} fields.

\begin{figure}[tbp]
%
\VerbatimInput[numbers=left]{SettableClock.java}
%
\vspace*{-2ex} % to fit this on one page
\caption{JML specification for \texttt{SettableClock}}
\label{Example:SettableClock}
\end{figure}
%
\GMARGIN{lightweight}
%
Contracts built from lightweight specification cases have fewer keywords and
mandatory clauses.  In particular, the visibility of a lightweight
specification case cannot be given explicitly since, by definition, its
visibility is the same as 
the visibility of the method it is attached to.
%
The method contracts in \texttt{TickTockClock} are all examples of 
lightweight method specifications.

%\subsection{Completeness of specifications}
%%
%\MARGIN{PC: Do we really want to include this?}
%%
%The reader will have noticed that the specification of \texttt{tick()} is
%incomplete, since it does not show that \texttt{tick()} should also advance
%the minute and hour at the end of a full minute and hour, respectively.  One
%could write a more elaborate postcondition that is complete, but in practice
%there may be good reasons why one may not want to write complete
%specifications; \COMMENT{e.g.\ it can be too hard, too much work, or simply not
%considered interesing}.

\subsection{Exceptions and exceptional postconditions}
\label{Sec:Exceptions}

JML distinguishes two kinds of postcondition: 
\begin{itemize}
  \item normal postconditions, expressed
    by means of \texttt{ensures} clauses, that have to hold when a method
    terminates normally, and
    \item exceptional postconditions, expressed by means of \texttt{signals}
      clauses, that have to hold when a method terminates with an exception.
\end{itemize}
%
The exceptional specification case of \texttt{SettableClock.setTime()} is
interpreted as follows: if \texttt{hour} and \texttt{minute} are not within
their valid ranges, then the method will raise an \texttt{IllegalArgumentException} 
(and the system state will be left unchanged).

Notice that in the \texttt{TickTocClock} class,
there are no Java \texttt{throws} clauses.
Still, Java permits the constructor and any of the methods of this class to throw a 
\texttt{RuntimeException}--one commonly raised runtime exception is 
\texttt{NullpointerException}.
%
JML is more strict when it comes to declaring runtime exceptions: 
whereas Java allows any constructor or method to throw a runtime exception, JML only 
allows this if the exception is listed in the method's throws clause,
or in the method contract's \texttt{signals\_only} clause.
\texttt{SettableClock.setTime()} illustrates use of the latter.
%
Therefore, constructors or methods without an explicit throws clause
have an implicit exceptional postcondition of \texttt{signals (Exception) false}.
%
Hence, the specification in \figref{Example:TickTockClock} 
rules out the generation of any runtime exceptions, making the specification a lot stronger 
than it might appear at first sight.

\subsection{Instance and static invariants (and the callback problem)}

A JML \texttt{invariant} clause declared with a
\texttt{static} modifier is called a \emph{static invariant}.
%
Static invariants express properties which must hold of the static
attributes of a class.
%
An assertion that appears in a non-static \texttt{invariant} clause is called
a \emph{instance invariant} or an \emph{object invariant}.
%
Note that while this terminology is contrary to the literature, it is more
accurate with respect to the nomenclature of Java.  In this paper, an
unqualified use of the term ``invariant'' will refer to an ``object
invariant''.

The semantics of object invariants is more involved than most specifiers
expect, especially for newcomers to the field of object-oriented specification.
Hence, while this issue has been widely known for quite some time
\cite{Szyperski98} we believe it is worth a brief explanation.
%
Intuitively, an object invariant
\begin{itemize}
  \item  has to be established by constructors--i.e., it is implicitly
    included in the postcondition of constructors;
  \item can be assumed to hold on entry to methods, but methods must also
    re-establish it. Hence, the invariant is implicitly included in the
    preconditions, and (normal and exceptional) postconditions of methods.
\end{itemize}

This intuition may suggest that the notion of object invariant is not really
necessary, but rather that it just provides a convenient shorthand.  This is a
common misconception.
%
There is more to the notion of invariant than the intuition above.
%
For example, suppose that the \texttt{tick} method called another method
at a program point where its invariant is broken, such as the call to
\texttt{canvas.paint()} in the following:
\begin{verbatim}
  public void tick() {
    second++;
    // object invariant might no longer hold
    canvas.paint();
    if (second == 60) { second = 0; minute++; }
    if (minute == 60) { minute = 0; hour++; }
    if (hour == 24)   { hour = 0; }
  }
\end{verbatim}
It would then be reasonable for the canvas to invoke, e.g., the
\texttt{getSecond()} method of the current clock object, performing a so-called 
callback. \GMARGIN{callback}
% Unfortunately, the canvas is not permitted to do so ...
However, since the invariant of this clock object is broken, its behavior is
unconstrained, in particular because the preconditions of all methods (which
implicitly include the object invariant) are all false.

To avoid such problems, the invariant not only has to be re-established at the
end of each method, but also at those program points where a method is invoked.
These program points--i.e., all program points
at which a method invocation starts or ends--are called the \emph{visible
states}. The visible state semantics for invariants says that all invariants
of all object have to hold at these visible states.
\MARGIN{Do we have a reference to give here? --PC}
%
This semantics is very strong and in many cases,
overly restrictive.  Less restrictive, but still sound, approaches are still a
hot topic of ongoing research. A more thorough discussion of this problem
and a proposed solution are offered by M\"{u}ller, Poetzsch-Heffter and
Leavens \cite{Mueller-Poetzsch-Heffter-Leavens05}; alternative solutions are
explored elsewhere
\cite{Huizing-Kuiper00,JacobsLeinoPiessensSchulte05,Middelkoop05}.

\section{Frame properties}
\label{Sec:assignable}

\COMMENT{Section~\ref{Sec:assignable} explain the use of \emph{assignable clauses} to
specify \emph{frame properties}, and explains the need for \emph{datagroups}
(both as a way to abstract away from implementation details and to allow
subclasses some freedom) still using the example in Fig~\ref{Example:TickTockClock}.}

JML provides \texttt{assignable} clauses to specify frame properties
of methods, i.e.\ to specify the possible side-effects of a method.
The notion of \emph{datagroup} as a means to abstract from private implementation 
details in frame conditions and to provide the flexibility that we want
to have in an object-oriented language.
This section explains these notions, and the need for them.

We should stress that although these clauses are needed when doing
program verification, they are \emph{not} needed to do runtime assertion checking. 
If one is only interested in runtime assertion checking, one need not know 
that \texttt{assignable} clauses exist.
(A tool for runtime assertion checking could try to enforce \texttt{assignable} 
clauses, but typically won't because of the high overhead this involves.)

\smallskip

In traditional specifications that give pre- and postcondition for methods
(or procedures) one often uses the convention that any variables not mentioned 
in the postcondition of a method have not been changed.  This approach is 
\emph{not} workable for realistic object-oriented programs, as explained below.

Suppose we wanted to follow this approach for consider the specification 
of the method \texttt{tick()} in Fig.~\ref{Example:TickTockClock}.
Because this method modifies three fields, namely
\texttt{second}, \texttt{minute} and \texttt{hour}, 
the postcondition will have to mention all these fields.
An  \texttt{assignable} clause specifies that a method may change to certain 
fields, without having to specifying how.
So \texttt{tick} could be specified as follows
\begin{verbatim}
   /*@ assignable hour, minute, second;
     @ ensures getSecond() == \old(getSecond() + 1) % 60;
     @*/
  public void tick() { ... }
\end{verbatim}
If no \texttt{assignable} clause is given for a method, it has the
default frame condition \texttt{assignable \everything;}
A pure method is a method with a frame condition \texttt{assignable \nothing}.

Object-oriented language such as Java require some means for abstraction in 
assignable clauses.
The specification for \texttt{tick} given above leaves a lot to be desired.
Firstly, note that this specification exposes implementation details,
namely the three private fields.
Secondly, the specification is overly restrictive for any future subclasses.
By the principle of \emph{behavioural subtyping}, discussed in more detail
in Section~\ref{Sec:behsubtyping}, the implementation of \texttt{tick} in any future
subclass of \texttt{Clock} has to meet the specification given in \texttt{Clock}.
This means that it can only assign to the three fields of \texttt{Clock},
which is far to restrictive in practice.
To give a concrete example, suppose we introduce a subclass \texttt{ClockWithDate} 
of \texttt{Clock} that, in addition to keeping the time, also keeps track of the 
current date.  Clearly such a subclass will introduce additional fields, to record 
the date, and the \texttt{tick} will have to modify these fields when the end
of a day is reached,  but the specification of \texttt{tick} above won't allow 
these fields to be changed, as they are not listed in the \texttt{assignable} clause.

Datagroups \cite{Leino98} provide a solution to 
this problem. The idea is that a datagroup is an abstract piece of an object's
state, that can still be extended by future subclasses.
The specification in Fig.~\ref{Example:TickTockClock} declares a (public) datagroup
\texttt{\_time\_state} and declares that the three (private) fields belong
to this datagroup. This datagroup is used to specify \texttt{tick}.
This avoid exposing any the private implementation details, and
any subclasses of \texttt{Clock} may extend the datagroup with
additional fields it introduces.

Datagroups can be nested, by using the \texttt{in} clause to say that
one datagroup is part of another one. The JML specifications for
\texttt{java.lang.Object} (which are apart of the (incomplete) JML 
specifications developed for the Java API that are distributed along with 
some the tools) declare a JML datagroup \texttt{objectState}. As this datagroup
is inherited by all other classes, as a convention one can use this datagroup 
to describe for a class what constitutes the `state' of an object of that class.
By that convention, the datagroup \texttt{\_time\_state} would be declared
to belong to \texttt{objectState}.

\section{Model fields}
\label{Sec:model}

\COMMENT{This section explain the use of a model field as abstract values,
using the example in Fig~\ref{Example:model}}

\begin{figure}[tbp] \label{Example:model}
%
\verbatiminput{Clock.java}
%
\vspace*{-2ex} % to fit this on one page
\caption{Example JML specification illustrating the use of model fields. Interesting changes wrt. the earlier specification are marked.}
\end{figure}

\MARGIN{We can point out the danger of the model field being
subject to an integer overflow, and explain Patrice's solution
to this.}

Model fields are closely related to the notion of data abstraction proposed in 
\cite{Hoare72}.  A model field is a specification-only field that provides an 
abstraction from the concrete state of an object.  Using a model field, a 
specification can abstract away from the concrete representation used in 
the implementation.

The specification in Fig.~\ref{Example:model} illustrates this.
It abstracts away from the particular concrete representation of time
by three fields \texttt{hours}, \texttt{minute} and \texttt{second},
by using a model field \texttt{\_time} that represents the number of seconds
past midnight.
This allows a brief but complete specification of the method \texttt{tick()}.

The \texttt{represents} clause relates the model field to the concrete representation,
in this case given by the three fields  \texttt{hours}, \texttt{minute} and 
\texttt{second}. So the \texttt{represents} clause defines called the 
representation function. In general, one can also have a representation relation.
Note that the \texttt{represents} is private, as it refers to the private
fields that make up the concrete implementation, but that the model field
is public, so that it is visible to public clients.

For every model field there is an associated datagroup, so that the 
model field can also be used in \texttt{assignable} clauses.
In fact, a datagroup can be viewed as a degenerated model field, namely
a model field of some unit type.

A difference between model fields for objects and the traditional notion of
abstract value for abstract data types is that an object can have several
model fields, providing abstractions of different aspects of the object.
For instance, in the specification of the subclass \texttt{AlarmClock}
of \texttt{Clock} in Fig.~\ref{Example:alarmclock} uses 
two model fields, one for the current time, which it inherits from
it parent class \texttt{Clock}, and one for the alarm time.

Model fields are especially useful in the specification of Java interfaces,
as interfaces do not contain any concrete representation we can refer
to in specifications. We can declare model fields in a Java interface
to use in its specifications, and then every calls that implements 
the interface can define its own \texttt{represents} clause relating
this abstract field to its concrete representation. Similarly, a subclass
of \texttt{Clock} could choose to provide a different representation
of time and then override the \texttt{represents} clause. For example,
the example \texttt{DigitalDisplayClock} in \figref{Example:alias}
does this.

For a more extensive discussion of model fields see \cite{Cheon-etal05}.
\cite{Cok05} discusses how model fields are treated in ESC/Java2;
more recent work on handling model fields in verification is \cite{LeinoMuller06}.

\section{Behavioural subtyping and specification inheritance}
\label{Sec:behsubtyping}

JML enforces the principle of \emph{behavioural subtyping}: any class
has to meet the specifications of its superclasses.
This ensures Liskov's Substitution Principle \cite{LiskovWing94},
i.e.\ that using an object of a subclass in a place where an object of 
the superclass is expected does not cause any surprises, and hence that 
the introduction of new subclasses does not break any existing code.

For example, consider the class \texttt{AlarmClock} in Figure~\ref{Example:alarmclock}.
Because \texttt{AlarmClock} is a subclass of \texttt{Clock}, it also
inherits all the specification of \texttt{Clock}, i.e.\ 
all invariants specified for \texttt{Clock} also apply to \texttt{AlarmClock},
and that any method in \texttt{AlarmClock} has to meet the specification
for that method given in  \texttt{Clock}.
So, for example, all methods in \texttt{AlarmClock} have to maintain the
\texttt{Clock} invariant th
For example, the method \texttt{tick()}, which is overridden in \texttt{AlarmClock},
has to meet the specification given for it in \texttt{Clock}. 
Note that any methods which are not overridden have to be re-verified, to ensure 
that they maintain any additional invariants of the subclass.

\begin{figure}[tbp] \label{Example:alarmclock}
%
\verbatiminput{AlarmClock_interfaceless.java}
%
\vspace*{-2ex} % to fit this on one page
\caption{Example JML specification illustrating the concepts of 
specification inheritance -- the class also has to satisfy all
the specification given in the parent class \texttt{Clock} -- and 
ghost fields -- the ghost field \texttt{\_alarm\_going\_off}
keeps track of some additional state--.}
\end{figure}

\begin{figure}[tbp] \label{Example:alarminterface}
%
\verbatiminput{AlarmInterface.java}
%
\vspace*{-2ex} % to fit this on one page
\caption{Interface of the alarm used in \texttt{AlarmClock}}
\end{figure}

When it comes to method specifications, behavioural subtyping requires
that preconditions of a method in a subclass can only  be weakened,
whereas postconditions of a method in a subclass can only  be strengthened.
One way to achieve this is to allow subclass to give a new specification
for a method -- effectively overriding the one in the superclass --
and then proving that (i) the precondition in the superclass implies the
precondition in the subclass and that (ii) the postcondition in the subclass
implies the postcondition in the superclass.

Instead, JML uses the principle of \emph{specification inheritance} 
for method specifications \cite{Dhara-Leavens96}: any method specification
in the subclass is ``conjoined'' with the specification, if any, for that
method in the superclass, in such a way that the conditions (i) and (ii) above 
are automatically met.

The process of conjoining specs can be a bit subtle.  If sub- and superclass
give the same precondition for a method, then the conjoined specification will
have the conjunction of the postconditions and the intersection of the frame
properties.  If different preconditions are given in the sub- and superclass it
becomes trickier: the precondition of the conjoined spec will be the
disjunction of the preconditions, and the postcondition of the conjoined spec
is slightly weaker than the conjunction of the postcondition, as the each
postcondition only has to apply in case the corresponding preconditions did.
See \cite{Dhara-Leavens96} for details.

\MARGIN{An example of this?}
\MARGIN{Or refer to the desugaring paper?}

% The flexibility of object-oriented programming -- notably the notion
% of late binding -- makes it more complicated to understand programs:
% at compile time it is not clear which implementation of a
% method will be executed for a given method invocation in the code.
% This also complicates program verification.
% 
% This in turn is crucial for modular verification of code,
% where we do not have to reverify exiting code when we add a new subclass.

% We want to verify code in a modular manner,  meaning that
% that the addition of some new subclass does not necessiatate
% the re-verification of all code, but just the verification
% of the new subclass.


\section{Ghost fields}
\label{Sec:ghost}

\MARGIN{Erik: Maybe the example in this section is too involved?}

Like model fields, ghost fields are specification-only fields,
so they cannot be referred to in Java code.
The difference is that whereas a model field provide an abstraction
of the existing state, a ghost field provide some additional state,
which may -- or may not -- be related to the existing state.
Unlike a model field, a \texttt{ghost} field can therefore
be assigned a value. This is done by a special \texttt{set} statement
that has to be given in a JML context.
Before we discuss the difference between model and ghost fields
in more detail, first an example of the use of a ghost field.

% {\scriptsize A more interesting example of a ghost field is 
% Typical use pattern for ghost fields: 
% recording some information in an auxiliary field that is convenient
% for specification (eg. to specify constraints on invocation
% order of methods)  or necessary for verification (eg in loops you
% sometimes need this).
% 
% Classical example familiar from Hoare logics: ghost variable needed 
% to express some loop invariant.}
% 
% \subsection{Example ghost field: a specification-only constant}
% 
% In the specification of \texttt{Clock} using the model
% field \texttt{time}, given in Figure~\ref{Example:model} it would
% be nice to introduce a constant for the value \texttt{24*60*60}.
% We could introduce a final static field \texttt{SECONDS\_PER\_DAY} for
% this value.
% However, given this constant is only needed in specifications,
% % and not in the code, we can introduce this constant as a ghost field, 
% to be precise as a final static ghost field.
% The only difference between such a final static ghost field 
% and a normal final static field is that the former can only
% be used in specifications.
% % 
% \subsection{Example ghost field: a boolean \texttt{alarmTimeSet}}
% 
% \COMMENT{Erik: I propose dropping this example, as it
% requires a more infrastructure in the AlarmClock example, eg to
% turn alarm on/off}
% % 
% Suppose that the informal specification of \texttt{AlarmClock} says that
% \texttt{enableAlarm} should only be invoked after the alarm time has
% been set using \texttt{setAlarmTime}. Note that the implementation
% does not check this or enforce this: it is the responsibility of the
% caller to ensure this\footnote{One could argue about whether this is 
% good programming practice, but we ignore this issue here.}
% Indeed, that the state of the \texttt{AlarmClock} does not
% even record if the alarm time has been set, so there is no
% way the current implementation could check or enforce it.
% 
% To express the informal requirement above in JML we will need to 
% record in the state an on \texttt{AlarmClock} whether or not 
% \texttt{AlarmClock} has been invoked.
% This can be done by extending the state of \texttt{AlarmClock}
% with an additional boolean ghost field \texttt{alarmTimeSet}, 
% as illustrated in Figure~\ref{Example:alarmclock}.
% The spec of the constructor says that \texttt{alarmTimeSet} 
% is initially false, the spec of \texttt{enableAlarm} requires 
% that \texttt{alarmTimeSet} is true, and the spec of
% \texttt{setAlarmTime} says that  this field will be set to true.
% 
% The JML runtime assertion checker and ESC/Java2 can now point out any 
% violations of the informal requirement, at runtime and compile time, 
% respectively.
% 
% \begin{figure}[tbp]
% %
% \verbatiminput{AlarmClockGhostOne.java}
% %
% \caption{\label{example}JML specification using a ghost field 
% \texttt{alarmTimeSet} to impose a restriction on the invocation 
% order of methods for client code.}
% \label{ghost}
% \end{figure}
% 
% \subsection{Example ghost field: a boolean \texttt{alarmOn}}
% \MARGIN{Erik: an alternative example might be adding a boolean ghost field 
% in the \texttt{AlarmInterface}; maybe the earlier example can then be dropped?}
% 
% Our third example of the use of a ghost field is more interesting, as
% it points a possible bug in the implementation, or at least an 
% ambuity in the informal specification.

\medskip

Suppose that we want to convince ourselves that the implementation of 
\texttt{AlarmClock} will not invoke the method \texttt{alarm.on()}
twice in a row, or the method \texttt{alarm.off()} twice in a row,
but that it will always call \texttt{alarm.on()} alternately. 
(One could add JML contracts to \texttt{AlarmInterface} to ensure this,
but we will postpone doing this until later.)

The state of an \texttt{AlarmClock} object does not record if the associated
\texttt{alarm} is going off or not (except maybe implicitly, in that the alarm is 
going off for 60 seconds after the alarm time). The state of an \texttt{AlarmClock}
does therefore not record which method it has last invoked on \texttt{alarm}.
For the purpose of understanding the behaviour of the \texttt{AlarmClock}, 
and possibly capturing this understanding in additional JML annotations,
it can useful to add a extra boolean field to the state, which records if 
the associated alarm is going off.
This is illustrated in Figure~\ref{Example:alarmclock}.
A boolean ghost field \texttt{\_alarm\_going\_off} is declared, 
and two assignments to this field are included in the method \texttt{tick()},
which ensure that the field is true when the alarm is going off and false
otherwise\footnote{A subtle issue here is that \texttt{\_alarm\_going\_off} 
has to be included in the datagroup associated with \texttt{\_time}. This is 
because --  by the principle of specification inheritance -- the method 
\texttt{tick()} is only allowed to have side effects on \texttt{\_time}.
Because \texttt{tick()} assigns to \texttt{\_alarm\_going\_off}, the field
has to be included in this datagroup.}.

% \begin{figure}[tbp]
% %
% \verbatiminput{AlarmClockGhostTwo.java}
% %
% \caption{\label{example}Example JML specification using ghost field \texttt{alarmOn} to record if alarm is going off}
% \label{ghosttwo}
% \end{figure}

One can now try to capture the informal requirement that ``if an alarm time
has been set, and the alarm is enabled, then the alarm will go off for
one minute at the specified alarm time'', by formulating one or more
suitable invariants relating the new ghost field \texttt{alarmOn} to
the `real' state of the \texttt{AlarmClock}. There are many way to express
such a relation, for instance using the following invariants:
\begin{verbatim}
 invariant alarmTime+60 <= 24*60*60 ==> 
     ( _alarm_going_off 
       <==> _alarmTime <= time && time <= _alarmTime+60);

 invariant alarmtime+60 > 24*60*60 ==> 
     ( _alarm_going_off 
       <==> 
       ( (_alarmTime <= time && time <= 24*60*60)
        ||
        (0 <= time && time <= (_alarmTime+60) % 24*60*60) 
     ) );
\end{verbatim}
Verification by ESC/Java2 will immediately point out that these invariants
can be violated,
namely by invocations of \texttt{setTime} and  \texttt{setAlarmTime}.
This highlights a potential weakness in the implementation;
relying on the comparison of the current time and the alarm time
in the decision to turn the alarm off might result in unwanted behaviour. 
The alarm could be turned on twice in a row, or turned on twice in a row.
Also, the alarm could go off for longer than 60 seconds, if one of these times 
are changed while the alarm is going of.  

\MARGIN{Erik: we could change the spec of
AlarmInterface, with a boolean model/ghost field, to forbid this. Of course,
if the alarm is aliased, we still have a problem.}

An improvement in the implementation would be to count down the number of 
seconds the alarm still have to go off, as use this as a basis for switching 
off the alarm, rather than relying on a comparison of the current time 
and the alarm time.

\begin{verbatim}
  /** The numbers of second that the alarm will still be on.
    * If zero, the alarm is off.
    */
  /*@ private invariant -1 <= alarmSecondsRemaining 
    @                     && alarmSecondsRemaining <= 60;
    @*/
  /*@ private invariant (alarmSecondsRemaining > 0)
    @                   == _alarm_going_off;
    @*/
  private int alarmSecondsRemaining = 0; //@ in _time;

  ...

  public boolean tick() {
  super.tick();
  if (alarmSecondsRemaining > 0) {
      alarmSecondsRemaining--;
      if (alarmSecondsRemaining == 0) {
          bell.off();
          //@ set _alarm_going_off = false;
      }
  }
  if (getHour() == alarmHour & getMinute() == alarmMinute &
      getSecond() == 0) {
      bell.on();
      alarmSecondsRemaining = 60;
      //@ set _alarm_going_off = true;
  }
\end{verbatim}
Now that we have such a close correspondence between the
ghost field \texttt{alarmOn} and the field
\texttt{alarmSecondsRemaining}, one could choose to replace
the ghost field by a model field:
\begin{verbatim}
 //@ public boolean model _alarm_going_off; //@ in _time;
 //@ private represents _alarm_going_off 
 //@                    == (alarmSecondsRemaining >= 0);
\end{verbatim}
However, for conceptual clarity, the ghost field is probably better.

Of course, one could choose to turn the ghost field into a real field,
so that it can be used in the implementation.
This would make the implementation simpler to understand.

\subsubsection*{Ghost vs model fields}

To recap, the crucial difference between a ghost and a model field 
is that a ghost field extends the state of an object, whereas
a model field is an abstraction of the existing state is an object.
A ghost field can be assigned to, in annotations, using the
special \texttt{set} keywords.
A model field cannot be assigned to, but it changes value automatically
whenever some of the state that it depends on changes, as laid down
by the representation relation.

% Note that for clients of a class there should be no difference between
% a model and a ghost field. However, this is only the case provided the 
% class is well-encapsulated, i.e. there is no way for the client
% to change the value of the model field by-passing the class's interface.
% Aliasing can be a problem here.
% 
% Typical use pattern for model fields (1): 
% introducing a model field in an interface spec, and then relating it to 
% the concrete implemenation is a class implementing this interface.
% 
% Typical use pattern for model fields (2): 
% introducing a model field in a class spec, as convenient abbreviation,
% and then relating it to the concrete implemenation.
% 
% After spotting a correspondence between the ghost field and
% the implementation, you may replace it by a model field.

\section{Aliasing}
\label{Sec:ownership}

\begin{figure}[tbp] \label{Example:alias}
%
\verbatiminput{DigitalDisplayClock.java} % was Clock_using_array_universes.java
%
\vspace*{-3ex} % to fit this on one page
\caption{An implementation using an array, which uses the universe type 
system \cite{Mueller-Poetzsch-Heffter-Leavens03} to ensure that references
to this array are not leaked outside the current object.}
\end{figure}

\begin{figure}[tbp] \label{Example:brokenalias}
%
\verbatiminput{BrokenDigitalDisplayClock.java} % was Clock_using_array_universes.java
%
\vspace*{-2ex} % to fit this on one page
\caption{An subclass of \texttt{DigitalDisplayClock} which breaks encapsulation
of the private array \texttt{time}, both by its constructor, which imports
a potentially aliased reference, and the method \texttt{expose}, which exports
a reference to \texttt{time}.}
\end{figure}

The potential of aliasing is a major complication in program verification,
and indeed a major source of bugs in programs. 
To illustrate the issue, \figref{Example:alias} shows a subclass 
\texttt{DigitialDisplayClock} 
of \texttt{Clock}, which uses an integer array \texttt{time} of length 6 
to represent time.  For the correct functioning of the clock it will be 
important that this array is not aliased. If the array, code outside of
this class could for instance break the invariants for the array.
Indeed, the fact that the (private) invariant depends on the array \texttt{time}
already suggest that it needs to be alias-protected.

By inspecting the entire code of the class, it is easy to convince
oneself that references to this array are not leaked.
However, this does not guarantee that a subclass does not introduce
ways to leak references to \texttt{time}.
For example, the subclass \texttt{BrokenDigitalDisplayClock} in 
\figref{Example:brokenalias} breaks the guarantee that \texttt{time}
will not be aliased.

There has been a lot of work on ways to equip programming languages
with some form of alias control, aka encapsulation or confinement.
JML includes support for the universe type system
\cite{Mueller-Poetzsch-Heffter-Leavens03} as a way to specify
and enforce constraints on aliasing. This is illustrated in 
\figref{Example:alias}: the array \texttt{time} is declared
as a \texttt{rep}-field -- rep being short for representation -- forbidding
references to the field to be aliased outside the object.
The typechecker incorporated in the JML runtime assertion checker
will for instance warn that the class \texttt{BrokenDigitalDisplayClock}
in \figref{Example:brokenalias} is not well-typed, as it  breaks 
the guarantee that \texttt{time} will not be aliased outside this class.
Verification with ESC/Java2 does not yet take the universes into account.

% In modular verification of code, as ESC/Java2 does, one tries to
% verify the correctness of code irrespective of any future subclasses.
% Suppose that we are verifying
% \begin{verbatim}
% public class SomeOtherClass{
%  /*@ non_null @*/ int[] a = 
%  //@ invariant a.length > 1;
% 
%  //@ ensures a[0];
%  public void set(){ a[0] = 7;}
%
% }
% \end{verbatim}
% The spec of \texttt{set} is trivially satisfied.
% But how can we be sure that this method does not break the invariant
% of some \texttt{ClockUsingArray} object, whose \texttt{time} field
% is aliased to \texttt{a}? This would require a whole program analysis,
% taking into account all subclasses of \texttt{DigitalDisplayClock}.

\section{Conclusions}
\label{Sec:conclusion}

Just pre- and postconditions do not suffice to specify object-oriented
programs.  This paper illustrates some of the core ingredients of the JML
specification language, notably frame conditions, datagroups, model and
ghost fields, and support for alias control, which we believe are important
in any approach to the specification of object-oriented programs.

Closely related work to the JML specification language for Java is the
Spec\# specification language for C\# \cite{SpecSharp}. This work also aims
at specification for a real object-oriented programming language with tool
support for runtime assertion checking and for static verification, the
latter with the Boogie program verifier.  Spec\# and JML share many of the
same core constructs, including the ones listed above, although precise
details may vary.  In particular, Spec\# provides a novel methodology to 
cope with object invariants \cite{BoogieInvariants}.

Indeed, we should point out that the debate on what is the right set of 
primitives for the specification of object-oriented programs, and what 
are the precise semantics of these primitives, is still far from finished.
Even for some of the core ingredients discussed in this paper the precise
semantics, and the precise way of handling them in tools, is still subject
of active research, as should be clear to the many references in this paper 
to very recent work.

\bibliographystyle{alpha}
\bibliography{fmco}

\end{document}
