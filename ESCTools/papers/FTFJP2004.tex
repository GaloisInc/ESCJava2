\documentclass{sig-alternate}
\usepackage{url}
\usepackage{verbatim}
\usepackage{graphicx}
\input{boxed-figure-new}
\input{obey}

\newif\ifpdf
\ifx\pdfoutput\undefined
   \pdffalse     % no PDFLaTeX
\else
  \pdfoutput=1  % PDFLaTeX
   \pdftrue
\fi

\ifpdf
\usepackage[pdftex,bookmarks=false,
            plainpages=false,naturalnames=true,
            colorlinks=true,pdfstartview=FitV,
            linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\else
\usepackage[dvips]{hyperref}
\fi

% macros for program code
%%\input{program-code}

\newcommand{\INCLUDECOMMENT}[1]{\textrm{$\langle$ {#1} $\rangle$}}

\begin{document}

\renewcommand{\floatpagefraction}{0.9} 
\renewcommand{\textfraction}{0.1}

%%% The following for acm style
\conferenceinfo{FTFJP}{Oslo, Norway}
\CopyrightYear{2004} 

\title{Reasoning with specifications containing method calls in JML and first-order provers}
%\subtitle{}

\numberofauthors{2}
\author{
\alignauthor David R. Cok\\
       \affaddr{457 Hillside Avenue}\\
       \affaddr{Rochester, NY   14610}\\
       \affaddr{USA}\\
       \email{cok@frontiernet.net}
\alignauthor Joseph Kiniry\\
       \affaddr{Security of Systems Group}\\
       \affaddr{Computing Science Department}\\
       \affaddr{University of Nijmegen}\\
       \affaddr{Toernooiveld 1}\\
       \affaddr{6525 ED Nijmegen}\\
       \affaddr{The Netherlands}\\
       \email{kiniry@cs.kun.nl}
}

\date{30 March 2004}

\toappear{Submitted to the Formal Techniques for Java-like Programs 
workshop at ECOOP 2004}
%%% The following for llncs style
%\pagestyle{headings}  % switches on printing of running heads
%\addtocmark{XXXXXXXXX} % additional mark in the TOC
%

%\mainmatter
%\title{Reasoning with specifications containing method calls in JML}
%\titlerunning{YYYYYYY}


%\author{David R. Cok\inst{1} \and Joseph Kiniry\inst{2}}

%\institute{457 Hillside Avenue\\
%                               Rochester, NY   14610\\
%                       USA \\
%                       {\tt cok@frontiernet.net} \\
%       \and
%               Security of Systems Group\\
 %              Computing Science Department\\
 %                      University of Nijmegen\\
%                       Toernooiveld 1\\
%                       6525 ED Nijmegen\\
%                       The Netherlands\\
%                       {\tt kiniry@cs.kun.nl}
%}

%\authorrunning{Cok and Kiniry}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\date{27 March 2004}

\newcommand{\myhref}[2]{\ifpdf\href{#1}{#2}\else\htmladdnormallinkfoot{#2}{#1}\fi}

\maketitle
\begin{abstract}
Program verification requires translating the constructs of a specification 
into a suitable logic for an underlying theorem prover.   Providing modularity
and comprehensibility by allowing 
annotations containing method calls and other abstractions is as important in 
specifications as it is in the program itself.  However, method invocations do not
map neatly into the first-order logics that are often used for assuring the correctness
of specifications.  The ESC/Java2 tool
has been able to achieve a practical solution to this difficulty within the design constraints
of its parent tool, ESC/Java.  Furthermore, the techniques used are applicable to other
specification constructs such as quantifiers and model variables.

\end{abstract}

%%\category{D.2.4}{Software Engineering}
%%                {Software/Program Verification}
%%                [Formal methods, Programming by Contract]
%%\category{F.3.1}{Logics and Meanings of Programs}
%%                {Specifying and Verifying and Reasoning about Programs}
 %%               [assertions, invariants, logics of programs,
%%                pre- and post-conditions, specification techniques]


%%\keywords{JML, ESC/Java, ESC/Java2, static analysis, verification, annotation languages, program specification} 

\section{Introduction}

Research in program verification is proceeding along many fronts: 
increasing sophistication of annotation languages, increasing
understanding of the nuances of programming language semantics as they
relate to verification challenges, increasing sophistication of 
provers, and increasing experience in using implemented systems on
industrial-scale problems.  Early treatments ignored complicated
aspects such as object references and method calls, which are
integral to realistic software systems.  Allowing
the use of methods in specifications provides a level of abstraction 
and conciseness that
promotes reading, writing and understanding specifications and will 
likely assist in their automated verification as well.  

ESC/Java \cite{ESCJava,Flanagan-etal02} is one such system;
it is successful at checking 
annotated programs, but its
absence of method calls in specifications limits those annotations to
low-level representations.  In this paper we discuss the implementation
of an extension to ESC/Java that allows the use of routine calls in
specifications.  With that accomplished, several other programming
language constructs can also be handled by the underlying prover.
The approach described here is applicable to any source code translator
that must interface with a prover that operates in a generic first-order 
logic (as opposed to a logic specifically designed to handle programming language
constructs).

Sections 2, 3, and 4 describe the Java Modeling
Language, the ESC/Java2 project, and the Simplify prover; these systems
are the context in which the solution described here was implemented 
and tested.  Section 5 describes our solution for translating method calls.
Applications to other specification language features are described in section 6.
Section 7 describes some outstanding issues,
and we end with a description of related work in section 8.


\section{The Java Modeling Language}

The Java Modeling Language (JML) has by now been described in several publications
\cite{jmlpapers,Leavens-Baker-Ruby99b,Leavens-Baker-Ruby02} and we will not repeat that full description here.  This language is suitable for
describing the issues at hand and is used in the implementation of the solution.
 The advances described in this paper
can be illustrated using simple preconditions and postconditions.  
\setlength{\partopsep}{0in}\setlength{\parskip}{0in}\setlength{\itemsep}{0in}\setlength{\topsep}{0in}
\begin{itemize}
\setlength{\partopsep}{0in}\setlength{\parskip}{0in}\setlength{\itemsep}{0in}\setlength{\topsep}{0in}\item A \texttt{requires} keyword followed by a predicate declares a precondition for a routine.
\item A \texttt{ensures} keyword followed by a predicate declares a postcondition for a routine.
\end{itemize}
Specifications are included in the text of a Java program by placing them in 
specially formatted comments, as shown in the Figures.
The syntax of the specification predicates follows Java closely.  It excludes any operations 
that have side effects, such as the increment operator
 \texttt{++}.  Other operations, such as arithmetic and 
comparison operators, have the same syntax and semantics as in Java.  In particular, 
predicates may include method calls, if those methods are designated \texttt{pure},
indicating that the method has no side-effects. 

\section{ESC/Java2}

The ESC/Java2 tool~\cite{CokKiniry04}, an extension of ESC/Java,
 implements the translation of Java programs and JML specifications into
the target logic.   
ESC/Java
 was a pioneering tool in the
application of static program analysis and verification technology to
annotated Java programs.  The tool and its built-in
prover operate automatically with reasonable performance and need
only program annotations against which to check a program's source
code.  The annotations needed are easily read, written and understood
by those familiar with Java and are partially consistent with the syntax
and semantics of the separate Java Modeling Language (JML)
project~\cite{jmlpapers,Leavens-etal00}.  Consequently, the original
ESC/Java was a research success
and was also successfully used by other groups for a variety of case
studies (e.g.,~\cite{Hub03,HOP04}).

The ESC/Java2 project extends ESC/Java
and its long-term utility by addressing a number of issues.
\setlength{\partopsep}{0in}\setlength{\parskip}{0in}\setlength{\itemsep}{0in}\setlength{\topsep}{0in}
\begin{itemize}
\setlength{\partopsep}{0in}\setlength{\parskip}{0in}\setlength{\itemsep}{0in}\setlength{\topsep}{0in}\item ESC/Java2 provides ongoing distribution and maintenance.
As companies were bought and research groups
disbanded, there was no continuing development or support of 
ESC/Java; the tool was untouched for over two years and its
source code was not available. 
\item ESC/Java2 fully parses current JML and Java 1.4, so it is
compatible with the variety of tools that now work with JML specifications
~\cite{jmlpapers}.

\item ESC/Java2 checks more of JML than did ESC/Java.
For example, frame conditions were not checked in ESC/Java, but errors in frame
conditions could cause the prover to reach incorrect conclusions.
Also, the annotation language lacked the ability to use methods in
annotations, limiting the annotations to statements only about
low-level representations.
\end{itemize}

The engineering goals of ESC/Java were to be automatic and useful in finding bugs
and violations of program specifications.  It was not designed to be complete nor
entirely sound.  ESC/Java2 has continued that spirit, though some unsound aspects have
been corrected.

\section{SIMPLIFY and the target verification condition language}

ESC/Java2 (following the parent tool ESC/Java) translates program source code into guarded commands, then into a single-assignment representation, and 
finally
into verification conditions (VCs).  These conditions are passed to an accompanying prover which
judges them to be valid or invalid and may produce counterexamples to demonstrate
invalidity.  With an appropriately general definition of the syntax and semantics of the verification
condition language, various provers could be used and compared.  ESC/Java2 uses the
Simplify \cite{nelson80,simplify} prover, which accepts verification conditions expressed in a
first-order logic (including universal and existential quantification) with equality and untyped total
functions, extended with a simple theory of arithmetic.


Simplify includes interacting decision procedures
 that cooperate to assess the satisfiability of a 
set of input formulas.
In the context of a programming language, the prover has knowledge of numerical and
boolean values and operators on those values.  A base set of axioms describes the behavior 
of types and the subtype relationship and of arrays.  Object identity corresponds to a simple
equality relationship among untyped, uninterpreted constants.  Object fields are modeled as
arrays: a field named \texttt{f} is considered an array, and a field reference \texttt{o.f} is
translated as the array reference \texttt{f[o]}.  Other constructs are modeled as function terms.

\section{Translating method calls}

\subsection{Issues with method calls within annotations}

The problem at hand is to translate expressions containing method calls into the target logic described above.  An assertion in the target logic concerning some equivalent of a method call is of no value in reasoning, however, unless there are other logical assertions that provide some 
information to the prover about that translation of the method call.  That information resides in
the specifications of the method being called.  Thus, we need to translate the specifications
of the called method
in a manner similar to that used to translate the calling expression.

In some cases there exists an expression whose value is the result of the method call.  For
instance, if a method's specifications have a postcondition of the form
\begin{center}\texttt{ensures \char'134 result == ... ; }\end{center}
then one could extract such an expression, at least under the preconditions for which the
postcondition holds.  (The JML symbol \texttt{\char'134 result} represents the result returned by a method.)  
That expression could then be substituted for the method call itself,
after appropriate substitution of actual for formal arguments.  This procedure does not work
in general however.  There may not be such an expression available.  There may be more than
one such
expression available, requiring a prescient choice of the best one to substitute for the method call.
Alternatively, the expression being substituted may contain other method calls that
will themselves require substitution; the substitution procedure may not terminate if there is
any recursive use of method calls in the annotations.  Even without recursion, the depth of
rewriting can create very large verification conditions (easily consuming 256M on the ordinary
but realistic sets of specifications contained in the JML library, in our experiments).

However, since the logic does allow terms containing uninterpreted functions, defining a new
uninterpreted function for each method is not a difficulty.  A naive translation of methods to
function terms would translate a method call of \texttt{sort()} into a function term with no
arguments, namely, \texttt{(sort)}.  This procedure encounters the following complications.
\setlength{\partopsep}{0in}\setlength{\parskip}{0in}\setlength{\itemsep}{0in}\setlength{\topsep}{0in}
\begin{itemize}
\setlength{\partopsep}{0in}\setlength{\parskip}{0in}\setlength{\itemsep}{0in}\setlength{\topsep}{0in}
\item
As will be obvious to any Java programmer, the argument list of the method does not 
actually contain all of the relevant arguments to the method.  If the method is not static, the
argument list must include the receiver object (\texttt{this}) as well.  Not quite as obviously,
functions representing constructors of inner classes must also include a reference to the
enclosing class as an argument.  Thus a method call 
\texttt{sort()} must be translated as \texttt{(sort this)}.
This allows a natural distinction between method calls \texttt{sort()}, \texttt{a.sort()}, and
\texttt{b.sort()}.  These are translated into the terms \texttt{(sort this)}, \texttt{(sort a')}, and
\texttt{(sort b')}, where \texttt{a'} and \texttt{b'} are the translations of
the programming language expressions \texttt{a} and \texttt{b}, respectively.  
Aliasing is naturally handled as well, since if it is established, for example, that
\texttt{(EQ this a')}, then \texttt{(EQ (sort this) (sort a'))} will immediately follow.

\item
Secondly, the method implementation may use fields
of the receiving object that are not listed in the argument list.  The values of instance fields
may be considered to be implicitly included via the \texttt{this} argument, but their values then
depend on the current program state.  

\item
Most importantly, the semantics of equality among function terms is not appropriate to the
reference semantics of an object-oriented language such as Java.  Two function terms in the
logic are equal if they have the same function symbol, the same number of arguments, and the
arguments are pairwise equal.  This definition of equality is fine for the immutable
values of Java's primitive types, but not for reference values.  Reference values 
referring to the
same object in different program
states will test equal even though their internal states may be different, since
the logic used here does not contain a global memory model.

\end{itemize}

\subsection{The translation procedure}

The translation scheme we adopted is to include as an argument of the 
method a value indicating the
program state in which the method is being evaluated.  A different state constant is defined
for the pre-state and the post-state if the method is not \texttt{pure}; a common state
constant can be used if the method is \texttt{pure}.  This state constant is uninterpreted.
That is we do not use it in any context other than to distinguish different program states 
in method calls.
Thus we keep the relative simplicity of the single-assignment translation into a first-order
logic without embedding a memory model and 
a full state-based representation of the programming language into the 
logic.
This may limit the conclusions that may be drawn about relationships among 
program states, but has
been simple to apply and thus far suitably effective in practice.

The translation, then, consists of the following steps:
\setlength{\partopsep}{0in}\setlength{\parskip}{0in}\setlength{\itemsep}{0in}\setlength{\topsep}{0in}
\begin{itemize}
\setlength{\partopsep}{0in}\setlength{\parskip}{0in}\setlength{\itemsep}{0in}\setlength{\topsep}{0in}
\item Select a unique identifier for each method declaration in the program (e.g. by using its
textual location in a specific file).
\item Define a unique state constant (distinct from all other constants) for each unique program
state within the method's implementation.  (The translation to a single-assignment form
takes care of this semi-automatically.)
If the method is \texttt{pure}, the pre-state constant and the post-state
constant are identical.  A new state is created after every operation with a side-effect.  
In
practice state constants are only needed for those program points where an annotation occurs
that is translated with
a method call.
\item Where a method call is used in an annotation expression, translate that method call
into the logic as a function call.  Use the unique identifier for the static
type of the method as the function name.  Include as arguments the translations of (a) the
state constant for this  program state, (b) the receiver object (if the method is not static),
and (c) each of the usual arguments of the method.
\item The specifications of the called method must be turned into assumptions.  They 
are first desugared by combining preconditions and postconditions
into stand-alone implications of the form (\cite{Raghavan-Leavens03} describes the details): \\
{\centering \texttt{ensures } {\em precondition}\texttt{ ==> }{\em postcondition}; }.\\
Any instance of \texttt{\char'134 result} is replaced by an instance of the method call, with
formal names for its arguments.  The expression is enclosed in a universal quantification over
its formal parameters.  Thus (in a class named \texttt{Z})\\
\texttt{requires i != 0;}\\
\texttt{ensures \char'134 result == i+1; }\\
\texttt{/*@ pure */ public int next(int i);}\\
in a state with state constant \texttt{stateX} creates the axiom 
\texttt{ (\char'134 forall Z object; (\char'134 forall int i;  \\ i != 0 ==> 
             next(stateX,object,i) == i + 1; ))} . \\
Since we do not extract values (e.g. of fields) out of a program state, we do not quantify over
the state constant.  Instead we repeat the assumption above in each context where the method
is called and translate any free variables in the context of that call.
\item JML allows annotations to appear in the body of a method as well, using \texttt{assert}
statements for example.  These are translated in the same way as postconditions; they simply
use a different state constant.  Since loops are unrolled by ESC/Java, they can be
handled without special treatment.
\end{itemize}

For example, the somewhat contrived code of Fig.~\ref{fig:TEX} is translated into guarded 
commands as shown in Fig.~\ref{fig:TRA}.  Though not shown here, if 
there is
more than one instance of the same method call within a given program state, those calls are
translated in the same way, enabling the prover to identify their return values as equal.  Similarly, if
a method call in the postcondition is contained within an \texttt{\char'134 old}, indicating it is to
be evaluted in the pre-state, then it will be translated using the state constant for the pre-state.

\begin{BFIGURE}
\verbatiminput{Example.java}
\caption{A somewhat contrived example to illustrate the translations of method calls.
To avoid needing an explanation of
 details of guarded commands and the translation that are not relevant to this discussion, this
is an approximation of the relevant part of the generated guarded command.}
\label{fig:TEX}
\end{BFIGURE}

\begin{BFIGURE}
\verbatiminput{Translation.txt}
\caption{A sketch of the translation of method Example.accumulateMin.}
\label{fig:TRA}
\end{BFIGURE}

[[[ Experience; example of what is not possible to conclude; Why an implication in the post-condition. ]]]

\section{Application to other \\ annotation constructs}

With translation of method calls to an underlying first-order logic enabled in ESC/Java2, 
several other specification constructs can be readily translated and used in static checking as 
well.  These are described briefly in this section.
 
\subsection{Constructor calls}

Constructor calls can be treated as calls of static methods.  That is, they do not depend on an
implict \texttt{this} argument, though, if they are constructors of a Java inner class, they will depend 
on an implicit argument representing an instance of the enclosing class.  Since some of the 
arguments may be reference values, the translated function must also have a state constant
as an argument.  The axioms about the constructed value are formed from the postconditions
of the constructor declaration.

Constructors are different than methods in that they dynamically allocate new objects on the 
heap.  Thus the result is a reference value not equal to any previous reference value.  ESC/Java2
(following ESC/Java) provides axioms concerning allocation that ensure this behavior, but 
those are beyond the scope of this paper.

\subsection{Array allocation}

Translating expressions such as \texttt{new int[9]} that allocate new arrays is quite straightforward.
These expressions do not depend on the current state nor on any implicit receiver argument.
Consequently a function whose arguments are simply the type and number of the array 
elements is all that is needed.
Just as for constructors, axioms regarding allocation are required, 
so that the value produced by a new array
expression is known to be different than any previously produced reference value.

A new array expression has no explicit pre-conditions or post-conditions, but there are some implicit axioms:
the result of the new array allocation is not null, is freshly allocated,
 and has a specific dynamic type, 
a specific length, and each
element is equal to a zero-equivalent value (e.g. integer 0, boolean \texttt{false}, or
reference \texttt{null}).

\subsection{Quantified expressions}

JML includes in its expression syntax various generalized quantified expressions.  Besides
the usual universal (\texttt{forall}) and existential (\texttt{exists}) quantified expressions, JML
also defines the quantifiers \texttt{\char'134 min}, \texttt{\char'134 max}, \texttt{\char'134 numof},
\texttt{\char'134 sum}, and \texttt{\char'134 prod}.  For example, the value of the expression
\begin{center} \texttt{(\char'134 min int i; i <= 0 \&\& i < 10; p(i))} \end{center}
is the smallest value of \texttt{p(i)} for \texttt{i} in the given range.  Similarly, \texttt{\char'134 max}
produces the largest of a given set of \texttt{int} values;  \texttt{\char'134 numof} yields the number
of true values in a set of boolean values; the values of the
 \texttt{\char'134 sum} and \texttt{\char'134 prod}
expressions are the sum and product, respectively, of the set of given values.

The translation of each of these consists of syntactically replacing the expression with a
function call (unique to that syntactic location).  Implicit receiver and state arguments are needed
as described previously.  If the quantifier is within the scope of another quantified
expression, there will also need to be function arguments for any bound variable used
in the replaced expression.

One must also introduce axioms concerning the value of this introduced function, 
corresponding to the value of the original quantified expression.  For example, the
axioms associated with
\begin{center} ( \texttt{\char'134 min} {\em decl}; {\em range-predicate}; {\em expr}) \end{center}
are 
\begin{center} ( \texttt{\char'134 exists} {\em decl}; {\em range-predicate}) \texttt{==>} \\
( \texttt{\char'134 exists} {\em decl}; {\em range-predicate}; \texttt{MIN() ==} {\em expr}) \end{center}
and
\begin{center} ( \texttt{\char'134 exists} {\em decl}; {\em range-predicate}) \texttt{==>} \\
( \texttt{\char'134 forall} {\em decl}; {\em range-predicate}; \texttt{MIN() <=} {\em expr}), \end{center}
with suitable universal quantification and 
where \texttt{MIN()} is replaced by the actual skolem function call expression.


\subsection{Model variables}

Model variables are declarations of fields within annotation comments that are not treated
as fields of the object.  Rather a model variable is associated with a representation, typically in 
terms of the internal state of the object.  The model variable may be used in annotations
as an abstract representation, or {\em model}, of some quantity related to the object at hand.
For example, Java's \texttt{java.util.Collection} interface, which has no implementation, might 
nonetheless declare a model variable such as
\begin{center} \texttt{public model instance non\_null JMLObjectBag theCollection;} \end{center}
(using one of JML's mathematical library classes).  
Here any implementation of the \texttt{Collection} interface is modeled as an immutable value
of the \texttt{JMLObjectBag} class.  
Then, even in the absence of an implementation of the method, a routine such as 
\texttt{isEmpty()} could use the model variable in the specification
\begin{center} \texttt{ensures \char'134 result <==> theCollection.isEmpty();} \end{center}

Model variables in JML may have a functional representation, a
predicate representation, or no representation at all.  Work on
translation of model variables in JML for the LOOP tool occurred
concurrently with the work in this paper and is discussed
in~\cite{BreunessePoll03}.  We came to a similar solution and offer
some additional observations here.

\subsubsection {Functional representations}

A functional representation is denoted in JML by the syntax
\begin{center} //@ \texttt{represents x <- }{\em ... expression ... } ; \end{center}
There is a specific value, provided by the expression, for the model variable (in a given program 
state).   This expression could be simply substituted for occurrences of the model variable, as
stated by \cite{BreunessePoll03}.  However, this is successful only in simple cases.  If there
is heavy use of model variables, the nested substitutions can be quite deep.  Furthermore,
JML allows multiple redundant representations, requiring a choice of which to use.  Finally,
direct or mutual recursion would prohibit simple substitution.  In our implementation in
ESC/Java2, we found that representing functional model variables by method
calls was the better
solution.

\subsubsection{Predicate representations}

JML also allows the values of model variables to be specified with a predicate representation:
\begin{center} \texttt{represents x \char'134 such\_that }{\em ... predicate ... } ; \end{center}
In this case the predicate does not necessarily give an executable expression for the
model variable and may not even constrain the model variable to a single value.  As
\cite{BreunessePoll03} points out, if there are no possible values satisfying the predicate, 
inconsistency in the generated axioms can result, if appropriate care is not taken.

In this case, we represent the model variable by a method call, with state and receiver arguments
as discussed above; the \texttt{such\_that} predicate becomes an assumption.

\subsubsection{Model variables with no representation}

A model variable, particularly in an abstract class or interface, may have no representation
at all.  It may be used in the specification of various methods, but its representation would be
supplied by derived classes that implement the interface.  An example of such an interface is
in Fig.~\ref{fig:norep}.  In this situation, we still translate the model variables as method calls,
but now there are no axioms generated from the represents clauses.  Instead, only the
pre- and post-conditions provide information about the behavior of the variable.

\begin{BFIGURE}
\verbatiminput{NoRep.java}
\caption{The specification and code for the interface \texttt{NoRep},
demonstrating a model variable with no representation.}
\label{fig:norep}
\end{BFIGURE}

Representation-less model variables do pose a difficulty in the translation and checking of model bodies.  If the model variable is \texttt{assignable} for a given method, then its value may 
change in the course of execution of the body of that method.  But without a representation,
there is no way to reason about its value during any (symbolic) execution of the 
body.~\footnote{JML's  \texttt{in} clause, not discussed here, does provide information
on which other fields of the class contribute to the value of a model variable and consequently
at which program points the value of a model variable might change.}

\subsubsection{Unmodified model variables}

There is a special case of using model variables that allows a simplification in their translation.
If a model variable is not listed~\footnote{including not listed via a JML datagroup} in a
method's \texttt{assignable} clauses, then its value may not change during the course of the
body of the method.  Thus for that method's body and the checking of its pre- and
post-conditions, the model variable may be treated as a constant.  The value of the model 
variable can be constrained by the value of its representation evaluated in the pre-state
(or any state) of the method.

\section{Outstanding issues in using \\ method calls in annotations}

Although the translation for method calls described above is implemented 
and has had favorable experience, there remain some open issues and opportunities 
for improvement.  Two of those are discussed here.

\subsection{Immutable values}

The complication of introducing state constants as additional arguments is a result of the underlying logic using uninterpreted values for reference quantities in the programming language.
Since these reference values refer to mutable objects, one must retain a state value to 
indicate which state of the object is meant.  If all of the arguments were primitive type values
such as integers and booleans, then a state value would not be needed.  These values of
non-reference types are immutable: if two values compare equal, they will always have the same
properties in any program state. 

Some reference types are also immutable.  For example, values of \texttt{java.lang.String} that
compare equal (with \texttt{==}) will always have identical properties even in future program
states.  One requirement for the values of a type to be immutable is that no method of the type
modify the internal state of the object; this condition is assured to hold if all methods of the 
type and any subtype are
\texttt{pure}.  However, it is also at least
necessary for immutability
that the internal representation not contain mutable objects and
that the representation not be exposed  in a way that the internal state could be modified by 
some external means.

Reasoning with immutable objects is potentially simpler and more efficient than with typical
mutable objects.  For example, JML includes a library of classes representing mathematical 
concepts useful in specifying classes \cite{Leavens-etal03a}; 
reasoning might be more straightforward if it could be 
established that instances of these classes are immutable.  For this to be possible, we need 
a set of sufficient conditions for immutability that can be statically checked, a proof of 
soundness regarding immutability, and a demonstration by a working implementation
of the utility of immutable classes in program verification.

%%% No room for a discussion of constancy

\subsection{Exceptions}

The evaluation of the expression in a model variable's represents
clause might result in exceptional behavior (that is, in the throwing
of a Java exception).  In an environment where the truth or falsity of
assertions must be determined by the reasoning engine, a semantics for
specifications with exceptional termination must be established.  For
example, what should be the behavior of a verification system on
encountering the program of Fig.~\ref{fig:exc}?  Consider just the
precondition of method \texttt{p}: should the program checker issue a
warning that there is a potential dereference of a null reference, or
should it simply presume an implicit precondition that \texttt{o !=
  null}?

\begin{BFIGURE}
\verbatiminput{Exc.java}
\caption{The specification and code for a class in which methods used in specifications throw exceptions.}
\label{fig:exc}
\end{BFIGURE}

Various approaches to handling exceptional expressions are described
in previous publications.  In~\cite{Cheon-Leavens02b}, Cheon takes a
contextual approach appropriate to checking assertions at run-time.
In~\cite{Leavens-Baker-Ruby02}, it is proposed that an arbitrary,
unknown value be substituted for an expression that terminates
abruptly.  This has the effect (perhaps surprising to the Java
programmer) that \texttt{(o == null || o.a == 0)} and \texttt{(o.a ==
  0 || o == null)} have the same value.  The LOOP project formalized
exceptions differently~\cite{BergPJ00a}, in the end recommending that
operators such as \texttt{||} be interpreted precisely as in Java and
that specifications be fully guarded so that no exceptional
termination will occur.

The choice of semantics for exceptional expressions obviously affects
the tools that would implement any static checking, but also affects
the convenience of reading and writing specifications and the success
of achieving the goal of defining specifications (in JML, at least) so
that they are unsurprising to Java programmers.

\section{Background: Related work}

There are by now a number of research tools that translate Java into
verification conditions appropriate to some logical reasoning engine.
There are numerous tools that insert assertion checking code into
compiled Java programs, and others that do model checking, but we are
aware only of the following tools that do static checking of
assertions:
\setlength{\partopsep}{0in}\setlength{\parskip}{0in}\setlength{\itemsep}{0in}\setlength{\topsep}{0in}
\begin{itemize}
\setlength{\partopsep}{0in}\setlength{\parskip}{0in}\setlength{\itemsep}{0in}\setlength{\topsep}{0in}
\item Krakatoa~\cite{krakatoa03a} uses the Why VC generator
  tool~\cite{Why} and the Coq prover~\cite{Why} and translates all
  statements with reference to a current program state.
\item The LOOP tool~\cite{Jacobs04,JacobsPoll01a} translates
  JML-annotated Java into PVS~\cite{OwreRRSS96} theories using a
  denotational semantics for Java.  The resulting automatically
  generated proof obilgations about the program are discharged
  interactively and automatically using several different logics
  including a weakest-precondition logic and a Hoare logic.
\item The ChAsE tool~\cite{CH03} is an extension of ESC/Java that
  checks frame conditions.
\item Jive~\cite{MeyerMuellerPoetzsch-Heffter00} translates a subset
  of Java into proof obligations for PVS; it supplies an interactive
  tool for managing the proofs.
\item JACK~\cite{JACK} generates proof conditions directly for several
  provers including the Atelier B prover, Simplify, Coq, and PVS.
  Most, but not all, of the proof obligations are handled
  automatically.
\item The KeY tool~\cite{Key2003} is integrated into a UML-based CASE
  tool and uses OCL as its annotation language.  It uses its own prover
  for dynamic logic and has little automation.
\end{itemize}

ESC/Java2, Krakatoa, KeY and ChAsE are publicly available.  Only
ESC/Java2 targets a generic first-order prover and seeks to be
completely automatic, supporting all of Java and JML.  On the other
hand, the original designers of ESC/Java did not intend for it to be
sound or complete, but made engineering compromises in order to be
automatic and reasonably useful to programmers not familiar with proof
techiques or interactive proof tools.

JACK is not publicly available and is highly automated, but currently
covers a much smaller portion of Java and JML than ESC/Java2.

ESC/Java2 does not utilize a full state-based logic, employing program
states only where needed.  Krakatoa uses a reference to the state of
the heap throughout its translation; though this is an accurate model
of Java semantics, it can be complex to use in actual proofs.  The
separation of values in ESC/Java2 by using separate arrays for each
field helps to automatically resolve some aliasing problems and
simplifies reasoning.

The LOOP tool has a comprehensive representation of Java's memory
model and the program translation and all work in PVS focus directly
on this model.  The LOOP tool permits one to specify and reason about
specifications that use pure methods. To do so, one either uses the
specifications alone, in a manner similar to that which is described
in this paper, or one uses the implementations of the methods and 
symbolically executes them within PVS.

Though there are similar aspects among these approaches, the solution
used by ESC/Java2 for translating method calls demonstrates a
straightforward translation in the context of a general purpose logic
and prover.  In doing so it maintains the design philosophy and
usefulness of the original ESC/Java tool.

\section{Acknowledgments}

Joseph Kiniry is supported by the NWO Pionier research
project on Program Security and Correctness and the VerifiCard
research project. 


%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
%\bibliographystyle{plain}

\bibliography{PASTE2004}  
% To create the self-contained file - comment out the line above and include the
% contents of the .bbl file here


% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
%APPENDICES are optional

%\balancecolumns


% That's all folks!
\end{document}
