\input texinfo   @c -*-texinfo-*-
@c %**start of header

@setfilename jml_homework.info
@settitle JML and ESC/Java Homework Exercises $Revision$
@c Other commands that globally affect the document formatting: 
@c synindex, footnotestyle
@afourwide
@paragraphindent 0
@c firstparagraphindent 0
@c %**end of header
@c =============================================================================

@c =============================================================================
@c %**summary and copyright

This document contains a set of homework exercises for those that wish
to learn JML and ESC/Java.  It was begun by Joseph R. Kiniry
<kiniry@@cs.kun.nl> in May 2004 for the tutorial ``Design by Contract
and Automatic Verification for Java with JML and ESC/Java2'' presented
at ECOOP 2004 in Oslo, Norway in June 2004.  This is edition $Revision$.

@copying
The JML and ESC/Java Homework Exercises are licensed under the Creative
Commons Attribution-NonCommercial-ShareAlike 2.0 license.  See
http://creativecommons.org/licenses/by-nc-sa/2.0/

Copyright @copyright{} 2004 Joseph R. Kiniry

@quotation
You are free:
@itemize
@item
to copy, distribute, display, and perform the work
@item
to make derivative works
@end itemize

Under the following conditions:
@itemize
@item
Attribution. You must give the original author credit.
@item
Noncommercial. You may not use this work for commercial purposes.
@item
Share Alike. If you alter, transform, or build upon this work, you may
distribute the resulting work only under a license identical to this
one.
@end itemize

For any reuse or distribution, you must make clear to others the license
terms of this work.

Any of these conditions can be waived if you get permission from the
author.

Your fair use and other rights are in no way affected by the above.

This is a human-readable summary of the Legal Code.

See http://creativecommons.org/licenses/by-nc-sa/2.0/legalcode
@end quotation

@end copying

@c %**end of summary and copyright
@c =============================================================================

@c =============================================================================
@c %**title, contents, and copyright

@titlepage
@title JML and ESC/Java Homework Exercises
@subtitle Learning JML and ESC/Java Through Example
@subtitle Edition $Revision$, May 2004
@subtitle These exercises use JML version 5.0rc1 and ESC/Java2 version 2.0a6
@author Joseph R. Kiniry <kiniry@@cs.kun.nl>

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying

Published by the Nijmegen Institute for Computing and Information
Science at the University of Nijmegen as technical report NIII-R04XX.
See http://www.cs.kun.nl/research/reports/
@end titlepage

@c metadata used in HTML
@documentdescription
Homework Exercises, Java Modeling Language, JML, ESC/Java, ESC/Java2,
Extended Static Checking, Extended Static Checker, Design by Contract,
Java, Verification, jUnit, Unit Testing, Model Checking, BISL,
Behavioral Interface Specification Language, Kiniry
@end documentdescription

@c Output the table of contents at the beginning.
@contents

@c %**end of title, contents, and copyright
@c =============================================================================

@c =============================================================================
@c %**top node and master menu

@c We recommend including the copying permissions here as well as the
@c segments above.
@ifnottex
@node Top, Introduction, (dir), (dir)
@top JML and ESC/Java Homework Exercises

@insertcopying
@end ifnottex

This set of homework problems focus on the use of JML in runtime
assertion checking (with @t{jmlc} and @t{jmlrac}) and static
verification with ESC/Java2.

@menu
* Introduction::                An introduction to these homework exercises.
* Core::                        Understanding the core concepts of JML.
* Using::                       Ways to use JML and ESC/Java2.
* Copying::                     Your rights and freedoms.
* Index::                       Complete index.

@end menu

@c %**end top node and master menu
@c =============================================================================

@c =============================================================================
@c %**body

@node Introduction, Core, Top, Top
@unnumbered Introduction

@cindex Introduction

The Java Modeling Language (JML) is a behavioral interface specification
language that can be used to specify the behavior of Java modules. It
combines the ``Design by Contract'' approach of Eiffel and the
model-based specification approach of the Larch family of interface
specification languages with some elements of the refinement calculus.

The JML tool suite comes with a typechecker (@t{jml}), a compiler
(@t{jmlc}), a runtime assertion checker (@t{jmlrac}), a Javadoc-based
documentation generator (@t{jmldoc}), a set of unit test tools
(@t{jml-junit}, @t{jmlunit}, @t{jtest}), and a specification skeleton
generator and specification comparison tool (@t{jmlspec}).

The JML tool suite is primarily the development of the JML project at
Iowa State University, led by Gary Leavens.  http://www.jmlspecs.org/

Several other tools understand (often subsets of) JML:
@itemize
@item
The Extended Static Checker for Java (ESC/Java version 1).
http://research.compaq.com/SRC/esc/
@item
The Open Source Extended Static Checker for Java (ESC/Java version 2, or
ESC/Java2 for short) from the SoS Group at the University of Nijmegen
and David Cok.
http://www.cs.kun.nl/sos/research/escjava/
@item
The LOOP compiler from the SoS Group at the University of Nijmegen.
http://www.cs.kun.nl/sos/
@item
The Daikon invariant detector from the Program Analysis Group at MIT.
http://pag.lcs.mit.edu/daikon/
@item
The ChAsE frame axiom checker from Lemme project at INRIA Sophia-Antipolis.
http://www-sop.inria.fr/lemme/verificard/modifSpec/index.html
@item
The JACK tool from Gemplus.
http://www.gemplus.com/smart/r_d/trends/jack.html
@item
The Bogor tool from the SpEx project at Kansas State University.
http://spex.projects.cis.ksu.edu/
@end itemize

This set of homework problems focus on the use of JML in runtime
assertion checking (with @t{jmlc} and @t{jmlrac}) and static
verification with ESC/Java2.

@c =============================================================================
@node Core, Using, Introduction, Top
@unnumbered Core JML Constructs

@cindex Core JML Constructs

The following sections discuss all of the core constructs of JML with
examples and exercises.  It is suggested that each exercise be completed
in sequence, as the exercises build upon each other in the order
presented.  @i{I.e.}, @ref{Problem-2,,Problem two} builds on the
knowledge that you gained in @ref{Problem-1,,Problem one}.

It is assumed that the reader has a basic understanding of the
following notions: @emph{assertion}, @emph{invariant},
@emph{specification}, @emph{signature}, @emph{class}, and @emph{type}.

@c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@menu
* Assertions::                  Understanding basic assertions.
* Assumptions::                 Making basic assumptions explicit.
* PrePost::                     Core concepts of method specifications.
* Modifies::                    Reasoning about and with frame axioms.
* Heavyweight::                 Expressive and easy to understand specifications.
* Invariants::                  Core concepts of class specifications.
* Loops::                       Reasoning about loops.
* Aliasing::                    Reasoning in the face of aliasing adversity.
* Models::                      Specifying and reasoning with models.
@end menu

@c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@node Assertions, Assumptions, Core, Core
@unnumberedsec Assertions

@cindex Assertions

An assertion is a predicate that @emph{must always} be true.  Assertions
are typically used for debugging and (localized) documentation purposes.

In JML, an assertion statement has the form
@display
@var{assert-statement} ::= @code{assert} @var{expression} [ @code{:} @var{expression} ] @code{;}
@end display

The first expression is the predicate that must be true.  The second
(optional) expression must be of type @code{String}.  The value of this
expression is printed by some tools when the assertion fails.  (add
xrefs)

Beginning in Java 1.4, an @code{assert} keyword was introduced.  The
syntax of the Java assert statement is the same as that of JML.  (add
xref)

Java's semantics does not restrict either subexpression in its assert
statement, so you can write assert statements that have side-effects
such as
@example
        int x;
        x++;
        assert (x++ == 2) : new String("This is a bad idea.");
@end example

This is a very bad idea, as it means that the behavior of your program
changes whether you are testing your assertions or not.

JML's assert statement does not permit side effects in either
subexpression.

Using runtime checking (with @t{jmlc} and @t{jmlrac}), JML and Java
assert statements are tested at runtime.  Using ESC/Java, JML assert
statements are proven at compile-time.  

In ESC/Java2, Java assert statements are treated one of two ways.  They
are either
@itemize
@item
Treated as Java assert statements using the @code{-eajava} or
@code{-javaAssertions} (synonymous) switches, or
@item
Treated as JML assert statements using the @code{-eajml} or
@code{-jmlAssertions} (synonymous) switches.
@end itemize
In the former case, a failed assertion has the semantics of 
@example
        throw new AssertionError(second expression);
@end example

Thus, you are @strong{not} reasoning about another potential runtime
exception, as all subtypes of @code{Error} are ignored by ESC/Java. (add
xref)

@strong{Problem 1.} @anchor{Problem-1} Annotate the following code
with Java assertions as indicated.  The expression @code{P(a0,a1,...)}
means ``replace this expression with a predicate that is true of the
variables @code{a0} and @code{a1} and ...''.  Write the strongest
predicate possible, given the context of the assertion.  Execute the
class to check your answers.

The provided @t{Makefile} in the @t{problems} directory can be used to
compile, run, and verify all problems.

@example
@include problems/JavaAssertions.java.texinfo
@end example

@strong{Problem 2.} @anchor{Problem-2} Annotate the following code
with JML assertions as indicated.  Write the strongest predicate
possible, given the context of the assertion.  After you have written
the assertions, first execute the class using @code{jmlrac} to check
your answers, then attempt to verify your answers using
@code{escjava2}.

@example
@include problems/JmlAssertions.java.texinfo
@end example

@c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@node Assumptions, PrePost, Assertions, Core
@unnumberedsec Assumptions

@cindex Assumptions

You will notice that nearly all of the assertions that you wrote for
Problems @ref{Problem-1,,one} and @ref{Problem-2,,two} cannot be
checked with ESC/Java2 as the @code{JavaAnnotations} and
@code{JmlAnnotations} classes are currently written.  While @emph{you}
might know that each assertion is true, given the context of the
program and the body of the @code{main()} method, there is no
information that ESC/Java2 can use to reach this same conclusion.

Because ESC/Java2 performs verification in a @emph{modular} fashion,
the @emph{assumptions} you based your assertions upon in each method,
which in turn were based upon what you read in the @code{main()}
method's body, are unknown to ESC/Java2.

More precisely, to reason about the correctness of the method
@code{n(int, Object, String)}, ESC/Java2 only uses the signature and
body of @code{n()} and everything they depends upon.  This set of
dependencies is large.  It including all the types mentioned in
@code{n()}, the signature and specification of any methods @code{n()}
might be overriding, and all invariants of the class
@code{JmlAssertions} that relate to fields mentioned in @code{n()}.
(More details about method specifications and class invariants will be
covered shortly.)

Notice that, to reason about @code{n()}, @emph{nothing} needs to be
known about the body of the @code{main()} method of
@code{JmlAssertions}.  Thus, all of the assumptions you made by
reading the body of @code{main()} are unknown to ESC/Java2.

The next two problems will focus on making assumptions explicit.  The
JML keyword @code{assume} is used to specify assumptions precisely.
@code{assume} is used very much like @code{assert}, except instead of
stating what @emph{must} be true at a certain point in a program (as
one does with an @code{assert}), an @code{assume} statement says what
@emph{is} true at a certain point in a program.

In JML, an assume statement has the form
@display
@var{assume-statement} ::= @var{assume-keyword} @var{predicate} [ @code{:} @var{expression} ] @code{;}
@end display
The assume statement thus has the exact same structure of the assert
statement, but means exactly the opposite.

@strong{Problem 3.} @anchor{Problem-3} Annotate your code from
@ref{Problem-2,,Problem two} with JML assumptions.  Try to write down
the @emph{minimal} set of assumptions that ensure all of your
assertions verify correctly with ESC/Java2.

For the following discussion we will refer to the answer key found in
the class @code{JmlAssertionsAndAssumptionsKey}, duplicated here for
reference.

@example
@include problems/JmlAssertionsAndAssumptionsKey.java.texinfo
@end example

Note that the assumptions in this class are not the only ones that are
correct.

Stronger assumptions (that is, logically stronger predicates) that
imply these weaker assumptions are correct also, though are not as
weak as possible.

For example, if one were to write
@example
  //@@ assume p != null && t != null;
@end example
to provide an assumption to fulfill the assertion
@example
  //@@ assert p != null;
@end example
the assertion would verify.  But the assumption is stronger than
necessary, since the information about the variable @code{t} is
superfluous.  The assumption can be made @emph{weaker} by simply
removing the term @code{t != null} because @t{A && B ==> A}.  I.e.,
@example
  //@@ assert p != null && t != null ==> p != null;
@end example
is always a true assertion, regardless of the values of @code{p} and
@code{t}.

The locations of the assumptions can also vary to some degree.  Many
cannot, in particular, those having to do with assertions located at
the very beginning of method bodies cannot be moved any "earlier"
because there is no earlier statement.  Moving the assumption
@emph{outside} of the method body, for example into the @code{main()}
method, has no effect due to the nature of modular verification, as
discussed earlier.  (add xref)

On the other hand, assumptions in the middle of a method can often be
moved around with some latitude.  For example,  the statement
@example
  //@@ assume i == 257;
@end example
in the method @code{o(int, Object, String)} could be moved earlier in
the method.  In fact, because the variable @code{i} is not referenced
anywhere earlier in the method, the assumption could (in theory) be
moved all of the way to the beginning of the method.

One problem with ESC/Java2 highlighted by this exercise is its
incomplete support for arithmetic, and bitwise operations in
particular.  You will find that nearly all assertions having to do
with the results of bitwise operations cannot be verified.

Consider the following method:
@example
  static void nn(Object p, Object t) @{
    int i = 1, j = 1;
    i = i | 0x100;
    //@@ assert i == 257;
    //@@ assert 0 <= i && i <= 1000;
    //@@ assert i == (1 | 0x100);
  @}
@end example
While all three assertions are true, only the third one (the most
complicated one, in some respects!) can be verified by ESC/Java2.
This weakness is due to the fact that the theorem prover used by
ESC/Java2 (called ``Simplify'') does not deal with bitwise operations
(see Bug #965748 at SourceForge for more information).  Thus, one
cannot reason about any variables involved in bitwise operations at
this time.

Assume statements are not to be used lightly.  In fact, as a general
rule, one should use assumes only as an absolute last resort.  It is
entirely too easy to introduce subtle inconsistencies to
specifications with assume statements.  If such an inconsistency
exists, then the related methods will verify immediately because they
have a false premise.

E.g., this method verifies:
@example
  void m() @{
    //@@ assume i == 0 && i == 1;
    //@@ assert true == false;
  @}
@end example

@page

@c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@node PrePost, Modifies, Assumptions, Core
@unnumberedsec Preconditions and Postconditions

@cindex Preconditions and Postconditions

A @emph{specification} of the class and its methods describes the
manner in which the class is correctly used.  To write such a
specification, one uses two primary concepts: @emph{method contracts}
and @emph{class invariants}.  The problems of this section will focus
on the former; invariants will be dealt with later. (add xref).

A @emph{method contract} consists of two basic assertions: a
@emph{precondition} which states under which circumstances the method
is guaranteed to behave correctly, and a @emph{postcondition} which
states what is true when the method completes executing.

The assume statements written for the preceding problems that were
``pushed'' to the beginning of the method are preconditions; they
state some of the conditions necessary for their method to terminate
properly.

The process of writing preconditions is a tricky business.
Preconditions must be ensured by the @emph{caller} of the method,
therefore everything stated in the precondition must be checkable by
the caller, prior to making the call.  Thus, one can only
(legitimately) express assertions in precoditions that are ``at least
as visible'' as the method they are guarding.

@strong{Problem 3.} @anchor{Problem-3} Annotate the following code
with @emph{preconditions} only.  Consider what are the
@emph{necessary} conditions for the method bodies to (a) not fail
abnormally (e.g., throw NullPointerExceptions,
ArrayIndexOutOfBoundExceptions, etc.), @emph{and} (b) perform their
job correctly (e.g., not compute an incorrect value, given your
intuition of the purpose of the method).

@c Additionally, frequently in Java APIs various exceptions are thrown
@c in response to particular 

@c use of \old in postconditions


@page

@c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@node  Modifies, Heavyweight, PrePost, Core
@unnumberedsec Frame Axioms

@cindex Frame Axioms

@c class C {
@c   static int i;

@c   public void l() {
@c     //@ assume i == 0;
@c     m();
@c     //@ assert true == false;
@c   }

@c   //@ behavior
@c   //@ requires i == 0;
@c   //@ modifies C.*;
@c   //@ ensures i == 1;
@c   public void m() {
@c     i++;
@c   }
@c }

@page

@c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@node Heavyweight, Invariants, Modifies, Core
@unnumberedsec Heavyweight Specifications

@cindex Heavyweight Specifications

@page

@c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@node Invariants, Loops, Heavyweight, Core
@unnumberedsec Invariants

@cindex Invariants

@page

@c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@node Loops, Aliasing, Invariants, Core
@unnumberedsec Reasoning about Loops

@cindex Reasoning about Loops

@page

@c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@node Aliasing, Models, Loops, Core
@unnumberedsec Aliasing

@cindex Aliasing

@page

@c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@node Models,  , Aliasing, Core
@unnumberedsec Models

@cindex Models

@c =============================================================================
@node Using, Copying, Core, Top
@unnumbered Using JML and ESC/Java2

@cindex Using JML and ESC/Java2

@c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@menu
* Annotating Code::             Annotating preexisting code.
* Annotating APIs::             Annotating APIs.
* Designing by Contract::       Design by Contract with JML for Java.
@end menu

@page

@node Annotating Code, Annotating APIs, Using, Using
@unnumberedsec Annotating Preexisting Java Code

@cindex Annotating Existing Java Code
@cindex Code Annotation

@page

@c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@node Annotating APIs, Designing by Contract, Annotating Code, Using
@unnumberedsec Annotating Preexisting APIs

@cindex Annotating Existing APIs
@cindex API Annotation

@page

@c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@node Designing by Contract,  , Annotating APIs, Using
@unnumberedsec Designing by Contract

@cindex Designing by Contract
@cindex Design by Contract

@c =============================================================================
@node Copying, Index, Using, Top
@unnumbered Copying

@cindex Copying

@insertcopying

@c %**end of body
@c =============================================================================

@c =============================================================================
@c %**end of document

@node Index,  , Copying, Top
@unnumbered Index

@printindex cp

@bye
