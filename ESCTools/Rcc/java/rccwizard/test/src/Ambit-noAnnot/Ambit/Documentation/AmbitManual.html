<HTML>
<HEAD></HEAD>
<BODY BACKGROUND="Ambit.watermark.gif">

<DIV ALIGN=CENTER><H2>Ambit Manual</H2></DIV>

<H3>User interface</H3>

<P>The user interface consists of two scrollable text areas and three buttons.
</P>

<UL>
  <LI>The top text area is for input of Ambit expressions (type them in or
  use cut-and-paste). 
  <LI>The bottom text area is for output. 
  <LI>The &quot;Run&quot; button causes the parsing and execution of whatever
  appears in the input area. Execution happens in an initially empty top-level
  ambient called &quot;root&quot;. No result is shown automatically. 
  <LI>The &quot;Show&quot; button, usually used after &quot;Run&quot;, shows
  the state of the &quot;root&quot; ambient. If the program is still running,
  &quot;Show&quot; shows a snapshot of the root ambient (possibly an inconsistent
  one). 
  <LI>The &quot;Reset&quot; button clears the output area and resets the
  root ambient to empty. It preserves the contents of the input area. Multiple
  &quot;Run&quot; can be executed before a &quot;Reset&quot;, in which case
  all the results accumulate in the &quot;root&quot; ambient. 
</UL>

<P>The normal interaction sequence is: edit input area, &quot;Run&quot;,
&quot;Show&quot;, &quot;Reset&quot;, repeat. </P>

<H3>Process expressions</H3>

<P>A process expression P is either: </P>

<H4>Basic process expressions </H4>

<UL>
  <DL>
    <DT>new n_1 ... n_k. P 
    <DD>Introduction of new names n_1...n_k in the scope P. P extends to the
    right up to the next non-nested &quot;|&quot;, if any. 
    <DT>- 
    <DD>the inactive process (often omitted) 
    <DT>P | P' 
    <DD>the parallel execution of two expressions. &quot;|&quot; has the weakest
    precedence. rec x. P the recursive execution of P; whenever x is encountered,
    a copy of the original P is executed again. P extends to the right up to
    the next non-nested &quot;|&quot;, if any.
    <DT>n[P]
    <DD>an ambient named n running P inside of it &quot;P&quot; can be omitted,
    meaning &quot;-&quot;. 
    <DT>do t. P
    <DD>a capability-based action (e.g. a move action) followed by P. P extends
    to the right up to the next non-nested &quot;|&quot;, if any. &quot;. P&quot;
    can be omitted, meaning &quot;. -&quot;. 
    <DT>say t 
    <DD>output the value resulting from t into the current ambient's ether,
    then stop. 
    <DT>ask x. P 
    <DD>input a value from the current ambient's ether, bind it to x within
    P, and then run P. P extends to the right up to the next non-nested &quot;|&quot;,
    if any. &quot;. P&quot; can be omitted, meaning &quot;. -&quot;. 
    <DT>(P) 
    <DD>an expression in paretheses. 
  </DL>
</UL>

<H4>Additional process expressions </H4>

<UL>
  <DL>
    <DT># 
    <DD>a process that kills its ambient 
    <DT>&quot;...&quot;. P 
    <DD>writes a character string to the console (e.g. for debugging) then
    does P. If the string is empty, writes the current state of the whole computation.
    P extends to the right up to the next non-nested &quot;|&quot;, if any.
    &quot;. P&quot; can be omitted, meaning &quot;. -&quot;. 
    <DT>wait i.j. P 
    <DD>wait for i.j seconds (a real number), then do P. P extends to the right
    up to the next non-nested &quot;|&quot;, if any. &quot;. P&quot; can be
    omitted, meaning &quot;. -&quot;. 
    <DT>be t. P 
    <DD>rename the current ambient with the name obtained from t. P extends
    to the right up to the next non-nested &quot;|&quot;, if any. &quot;. P&quot;
    can be omitted, meaning &quot;. -&quot;. 
    <DT>say t. P 
    <DD>this is an abbreviation/optimization for (say t | P); after the asynchronous
    output of t execution carries on with P using the same thread. 
    <DT>let x(x_1 ... x_k) = P; P'
    <DD>the definition of a parametric process P bound to x within P'. P' extends
    to the right up to the next non-nested &quot;|&quot;, if any. Here k&gt;=0,
    the parentheses must always be present. The paremeter may denote results,
    not processes. Nothing is evaluated until a let definition is instantiated.
    let declarations can be inserted into any ambient, and the scoping of their
    defined variables may extend inside ambient brackets. 
    <DT>x(t_1 ... t_k) 
    <DD>the instantiation of a parametric process. The t_i are evaluated to
    results and are passed to the the definition of x as arguments. The definition
    of x is then executed with the arguments replacing the parameters. 
  </DL>
</UL>

<H3>Term expressions</H3>

<P>A term expression t has the form: </P>

<UL>
  <DL>
    <DT>x
    <DD>identifier; name (new-bound) or variable (ask-bound) 
    <DT>&quot;...&quot; 
    <DD>character string 
    <DT>i.j 
    <DD>real number 
    <DT>in x 
    <DD>in capability 
    <DT>out x 
    <DD>out capability 
    <DT>open x 
    <DD>open capability 
    <DT>stay 
    <DD>empty route 
    <DT>t &amp; t 
    <DD>composite route (t) 
  </DL>
</UL>

<H3>Behaviors</H3>

<P>The execution of a process expression produces a behavior. Behavior are
not &quot;values&quot; and in general consist of the concurrent execution
of multiple threads. </P>

<H3>Values</H3>

<P>A &quot;value&quot; is what is produced by the evaluation of a term expression.
It is either: </P>

<UL>
  <LI>a name 
  <LI>a route (a list of capabilities) 
  <LI>a character string 
  <LI>a real number 
</UL>

<H3>Top-level and Focus (experimental)</H3>

<P>There is a top-level ambient called &quot;root&quot;, where evaluations
happens by default. We say that initiall the focus of evaluation is at root.
The focus is &quot;the ambient we are in&quot; when we evaluate.</P>

<P>The focus can be changed by executing: </P>

<BLOCKQUOTE>
  <P>at n </P>
</BLOCKQUOTE>

<P>where n is either &quot;root&quot; or the name of a previously marked
ambient. </P>

<P>To mark an ambient, just place an &quot;@&quot; sign in front of it.
E.g.: </P>

<BLOCKQUOTE>
  <P>new n. @n[] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;creates
  a marked n[] inside root<BR>
  at n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shifts
  the focus from root to n<BR>
  new m. m[] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;creates
  m[] inside n. </P>
</BLOCKQUOTE>

<P>Note that when the focus is moved to an inner ambient, its local environment
is accessible. E.g.: </P>

<P>new n. ask x. @n[] | say n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the
ambient n[] is in the scope of x<BR>
at n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shifts
the focus from root to n <BR>
x[] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x
is visible here (it is bound to n) <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;creates
another n[] within the original n[]</P>

<H3>Resources (Not yet implemented) </H3>

<UL>
  <DL>
    <DT>resource n_1 = R_1 ... n_k = R_k 
  </DL>
</UL>

<P>Each ambient can contain a collection of named resources. Examples of
resources are ordinary functions (over term) and data (terms). C.n This
is a resource identifier. It consists of a route C to get to the ambient
that contains the resource, followed by the name of the resource. If the
resource is a function then C.n(t) would be an asyncronous function invocation.
In continuation passing style, one of the parameters could be C-inverse,
indicating where the result should be delivered. </P>

<H3>State (Not yet implemented) </H3>

<P>Stateful entities cannot be results, otherwise they could escape their
ambient and duplicate state. Therefore, all stateful entities will be ambient-like.
These will include arrays and records. The names of these entities can be
passed around (outside their ambient) and they can be referred to as resources.
</BODY>
</HTML>
