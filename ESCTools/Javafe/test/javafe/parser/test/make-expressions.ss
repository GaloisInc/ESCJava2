; make-expression
; generates expression from grammar derivation,
; and also prints fully parenthesised form.

; bugs found
; = needs to be right-assoc
; >>>= a token
; keywords != IDENT
; need hierarchy in test generator
; Need PrimaryNoNewArray

(define test-file-name "compare-exprs-big")

(define (mk-exprs)
  (when (file-exists? test-file-name) (delete-file test-file-name))
  (with-output-to-file test-file-name
    (lambda ()
      (printf "// Test file automagically generated by make-expressions.ss~n~n")
      (let loop ([i 0])                 
        (unless (= i 13)
          (set! max-depth i)
          (exprs 40)
          (loop (add1 i))))
      (printf "~n~nall_done, all_done~n~n"))))

(define (exprs n)
  (unless (zero? n)
    (let ([e (expr)])
      ;; print with braces -> parens
      (for-each
        (lambda (c)
          (printf "~a"
            (cond 
              [(eq? c #\{) #\(]
              [(eq? c #\}) #\)]
              [else c])))
        (string->list e))
      (printf ",~n   ")
      ;; print without braces
      (for-each
        (lambda (c)
          (unless (memq c '( #\{ #\} ))
            (printf "~a" c)))
        (string->list e))

      (printf ",~n")
      (exprs (sub1 n)))))

(define depth 0)
(define max-depth 0)

(define compose 
  (lambda args
    (set! depth (add1 depth))
    ;(printf "Depth: ~s~n" depth)
    (let ([r (apply
               string-append
               (map
                 (lambda (e) (if (string? e) e (e)))
                 args))])
      (set! depth (sub1 depth))
      ;(printf "Depth: ~s~n" depth)
      r)))

(define choose
  (lambda args
    ;; each arg is a thunk or string
    (let ([ndx (if (>= depth max-depth) 0 (random (length args)))])
      (let ([e (list-ref args ndx)])
        (if (string? e)
          e
          (e))))))

(define choose-string
  (lambda args
    ;; each arg is a string
    (list-ref args (random (length args)))))

;; ----------------------------------------------------------------------

(define (expr) (choose CondExpr Ass))


;; LHS is PostFixExp, somewhat looser than JLS ch 19. grammar,
;; but ok for parser
(define (Ass) (compose "{" Postfix AssOp expr "}"))

(define (AssOp) 
  (choose "=" "*=" "/=" "%=" "+=" "-=" "<<=" ">>=" ">>>=" "&=" "^=" "|="))
(define (CondExpr) 
  (choose
    CondOr
    (lambda () (compose "{" CondOr "?" expr ":" CondExpr "}"))))

(define (left-assoc ops lower)
  (let ([ops (if (list? ops) ops (list ops))])
    (letrec ( [self
                (lambda ()
                  (choose
                    lower
                    (lambda () 
                      ;(printf "self=~s~n" self)
                      (compose "{"
                        (lambda () 
                          ;(printf "calling self=~s~n" self)
                          (self))
                        (apply choose ops) lower "}"))))])
      self)))

(define EquExpr (left-assoc '("==" "!=") (lambda () (Relational))))
(define AndExpr (left-assoc "&" EquExpr))
(define ExOr    (left-assoc "^" AndExpr))
(define IncOr   (left-assoc "|" ExOr))
(define CondAnd (left-assoc "&&" IncOr))
(define CondOr  (left-assoc "||" CondAnd))

(define (Relational)
  (choose
    Shift
    (lambda () (compose "{" Relational (choose "<" ">" "<=" ">=") Shift "}"))
    (lambda () (compose "{" Relational " instanceof " RefType "}"))))

(define MultExpr(left-assoc '("*" "/" "%") (lambda () (Unary))))
(define AddExpr (left-assoc '(" + " " - ") MultExpr))
(define Shift   (left-assoc '("<<" ">>" ">>>") AddExpr))

(define (Unary)
  (choose
    UnaryNotPlusMinus
    (lambda () (compose "{" (choose " + " " - " "++" "--") Unary "}"))))

(define (UnaryNotPlusMinus)
  (choose
    Postfix
    Cast
    (lambda () (compose "{" (choose "~" "~") Unary "}"))))

(define (Cast)
  (choose
    (lambda () (compose "{" "(" PrimitiveType Dimsopt ")" Unary "}" ))
    (lambda () (compose "{" "(" Name Dimsopt ")" UnaryNotPlusMinus "}"))))

(define (Postfix)
  (choose
    Primary
    Name
    (lambda () (compose "{" Postfix "++" "}"))
    (lambda () (compose "{" Postfix "--" "}"))))

(define (Name)
  (compose "x" (choose "" (lambda () (compose "." Name)))))

(define (Primary)
  (choose
    PrimaryNoNewArray
    (lambda () (compose "{" " new " PrimitiveType DimExprs Dimsopt "}"))
    (lambda () (compose "{" " new " Name DimExprs Dimsopt "}"))))

(define (PrimaryNoNewArray)
  (choose
    "1 "
    " true "
    " false "
    " 1.2 "
    "'a'"
    " this "
    (lambda () (compose "{" "(" expr ")" "}"))
    (lambda () (compose "{" " new " Name "(" ArgListopt ")"  "}"))
    (lambda () (compose "{" Primary "." "x"  "}"))
    (lambda () (compose "{" " super " "." "x"  "}"))
    (lambda () (compose "{" Name "(" ArgListopt ")"  "}"))
    (lambda () (compose "{" Primary "." "x" "(" ArgListopt ")"  "}"))
    (lambda () (compose "{" " super " "." "x" "(" ArgListopt ")"  "}"))
    (lambda () (compose "{" Name "(" ArgListopt ")"  "}"))
    (lambda () (compose "{" Name "[" expr "]" "}"))
    (lambda () (compose "{" PrimaryNoNewArray "[" expr "]" "}"))))

(define (ArgListopt) (choose "" ArgList))
(define (ArgList) (choose expr (lambda () (compose ArgList "," expr))))

(define (Dimsopt) (choose "" Dims))
(define (Dims) (choose "[]" (lambda () (compose Dims "[]")))    )
(define (DimExprs) (choose DimExpr (lambda () (compose DimExprs DimExpr))))
(define (DimExpr) (compose "[" expr "]"))
    
(define (RefType) 
  (choose 
    Name
    (lambda () (compose PrimitiveType "[]"))
    (lambda () (compose RefType "[]"))))

(define (PrimitiveType)
  (choose "int"))
