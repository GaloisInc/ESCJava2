<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Tue Nov 27 10:53:32 PST 2001 -->
<TITLE>
: Class  TypeCheck
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT ID="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT ID="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT ID="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT ID="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT ID="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT ID="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javafe/tc/TagConstants.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../javafe/tc/TypePrint.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="TypeCheck.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javafe.tc</FONT>
<BR>
Class  TypeCheck</H2>
<PRE>
java.lang.Object
  |
  +--<B>javafe.tc.TypeCheck</B>
</PRE>
<HR>
<DL>
<DT>public class <B>TypeCheck</B><DT>extends java.lang.Object</DL>

<P>
<P> The <CODE>TypeCheck</CODE> class contains methods to
disambiguates, resolves and checks type declarations.  (Before methods
in this class can be called, the <a href="javafe.tc.TypeSig.html">
<code>TypeSig</code> </a> class must be initialized.)


<H3> Overview of checking, resolution, and disambiguation </H3>

<P> Checking involves performing the static checks specified by the
Java language specification.

<P> Resolution involves connecting symbolic references in the parse
tree to objects representing declarations of the referred-to entities.
The parser generates a number of nodes -- instances of
<CODE>IdnExpr</CODE>, <CODE>FieldAccess</CODE>, and
<CODE>MethodAccess</CODE> -- containing identifiers found in the input
plus a <CODE>decl</CODE> field which is initially <CODE>null</CODE>.
Resolution sets these <CODE>decl</CODE> fields to point to the
declaration referred to by the identifiers.  Similarly,
<CODE>TypeName</CODE> nodes have a <CODE>sig</CODE> field which is
initially <CODE>null</CODE> and which must be resolved to an instance
of <CODE>TypeSig</CODE>.  For example, the name
<CODE>java.lang.String</CODE> appearing in a type constext would be
parsed to a <CODE>TypeName</CODE>; resolution of this node would point
its <CODE>sig</CODE> field to the <CODE>TypeSig</CODE> object
representing Java's standard <CODE>String</CODE> type.

<P> Disambiguation deals with "ambiguous names" in Java (see Section
Six of the Java language specification, or <A
href="http://src-www.pa.dec.com/~stata/ESCJava/naming.html">this
document</A>).  These are qualified names of the form
<CODE>I1.I2...In</CODE> that appear in an expression context.  For
such a name, <CODE>I1</CODE> could be a local variable or a field of
<CODE>this</CODE>, or some prefix of the name could be the
fully-qualified name of a type, as in
<CODE>java.lang.String.concat</CODE>.

<P> When it encounters an ambiguous name, the parser generates either
an <CODE>ExprName</CODE> or <CODE>MethodName</CODE> node depending on
the context.  These are leaf nodes.  In these cases, disambiguation
involves replacing these nodes with appropriate
<CODE>FieldAccess</CODE> or <CODE>MethodAccess</CODE> nodes; these are
non-leaf nodes, and in general the replacement might be fairly deep.

<P> As an example of disambiguation, assume the name <CODE>x.y</CODE>
is parsed as an <CODE>ExprName</CODE>.  Assume further that no local
named <CODE>x</CODE> is in scope, the current scope is in an instance
method for a class that has a field named <CODE>x</CODE>.  In this
case, disambiguation would replace this <CODE>ExprName</CODE> with:

<BLOCKQUOTE>
<CODE>(ExprFieldAccess (ExprFieldAccess this x) y)</CODE>
</BLOCKQUOTE>

that is, an instance of <CODE>ExprFieldAccess</CODE> whose
<CODE>id</CODE> field was <CODE>y</CODE> and whose <CODE>expr</CODE>
field was another <CODE>ExprFieldAccess</CODE> whose <CODE>id</CODE>
field was <CODE>x</CODE> and whose <CODE>expr</CODE> field was an
instance of <CODE>ThisExpr</CODE>.

<P> An alternative design for disambiguation and resolution was
considered.  In this design, the <CODE>Name</CODE> class, the three
subclasses of <CODE>FieldAccess</CODE>, and the three subclasses of
<CODE>MethodAccess</CODE> would be replaced with a new expression
class that looked something like:

<BLOCKQUOTE>
<PRE>
class DotExpr extends Expr {
int tag; // Indicates the kind of dot
Expr expr;
Identifier id;
}
</PRE>
</BLOCKQUOTE>

When confronted with phrases of the form <CODE>I1.I2...In</CODE>, the
parser would generate trees of <CODE>DotExpr</CODE> nodes all with the
same tag, this tag indicating that the meaning of the dot was
ambiguous.  Disambiguation would involve replacing this ambiguous tag
with a tag whose meaning was clear (e.g., a tag that meant "select a
type from a package").  Resolution would involve using our generic
decoration mechanism to link certain of these nodes with the
declarations to which they refer.

<P> The advantages of this approach over the one we selected is that
it is more conventional (it's been used, for example, in compilers for
the Modula family of languages), it has a simpler class hierarchy, and
it does not involve mutating the structure of the parse tree.  The
primary advantage of our approach is that we capture many more
invariants in the type system, leaving less to go wrong at run-time.
It is mostly for this reason that we selected it.  In addition, our
approach takes less space to represent type names, avoids downcasting
(which can be costly time-wise), and is more friendly to the "visitor"
pattern.


<H3> Staging the processing of type declarations </H3>

<P> Resolving and checking a type declaration usually involves looking
at other declarations to which it refers.  Finding, reading, and
processing referred-to types makes resolution and checking fairly
complicated.  As a result, we have decomposed it up into smaller
steps.  Type declarations move through a number of states as the
resolution and checking process procedes.  In addition to making the
overall processing of type declarations conceptually more manageable,
this decomposition has two other benefits:

<UL>

<LI> <I> Handling cycles. </I> As mentioned above, processing one type
may involve processing types to which it refers.  However, two types
may refer to each other, making it impossible to process any one of
them "first."  Decomposing the processing into stages helps us handle
such cycles.

<P> <LI> <I> Improving performance. </I> Processing one type
declaration does not always involve fully processing the declarations
to which it refers.  How much processing is required of a referred-to
type depends on the manner in which it is referred (e.g., in a method
signature versus as a superclass).  Decomposing processing into stages
allows us to be lazy in processing referred-to types, that is,
allowing us to process them only to the extent that is necessary and
no further.

</UL>

<P> To support the lazy handling of type declarations, type
declarations are represented using two objects: <CODE>TypeDecl</CODE>s
and <CODE>TypeSig</CODE>s.  <CODE>TypeDecl</CODE> objects represents
the actual parse tree of a declaration.  <CODE>TypeSig</CODE> objects
refer to <CODE>TypeDecl</CODE> objects.  Rather than point directly to
<CODE>TypeDecl</CODE>, most references to type declarations point to
<CODE>TypeSig</CODE> objects instead.  This extra level of indirection
allows us to defer parsing of type declarations until the parse tree
is really needed.

<P> Details of the states of type declarations are found with
documentation of the <A href="javafe.tc.TypeSig.html">
<CODE>TypeSig</CODE> </A> class.
<P>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../javafe/tc/TypeSig.html"><CODE>TypeSig</CODE></A>, 
<CODE>BaseEnv</CODE>, 
<A HREF="../../javafe/ast/TypeDecl.html"><CODE>TypeDecl</CODE></A>, 
<A HREF="../../javafe/ast/TypeName.html"><CODE>TypeName</CODE></A>, 
<CODE>ExprName</CODE>, 
<CODE>MethodName</CODE>, 
<CODE>IdnExpr</CODE>, 
<A HREF="../../javafe/ast/FieldAccess.html"><CODE>FieldAccess</CODE></A>, 
<CODE>MethodAccess</CODE></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../javafe/tc/TypeCheck.html">TypeCheck</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#inst">inst</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A (possibly extended) instance of TypeCheck.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#TypeCheck()">TypeCheck</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a instance of TypeCheck, and sets the <code>inst</code>
 field to this instance.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#canAccess(javafe.tc.TypeSig, javafe.tc.TypeSig, int, javafe.ast.ModifierPragmaVec)">canAccess</A></B>(<A HREF="../../javafe/tc/TypeSig.html">TypeSig</A>&nbsp;from,
          <A HREF="../../javafe/tc/TypeSig.html">TypeSig</A>&nbsp;target,
          int&nbsp;modifiers,
          <A HREF="../../javafe/ast/ModifierPragmaVec.html">ModifierPragmaVec</A>&nbsp;pmodifiers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can a member of type target with modifiers
 modifiers/pmodifiers be accessed by code located in from? </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#checkTypeDecl(javafe.ast.TypeDecl)">checkTypeDecl</A></B>(<A HREF="../../javafe/ast/TypeDecl.html">TypeDecl</A>&nbsp;td)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves <code>td</code> into the checked state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#checkTypeSig(javafe.tc.TypeSig)">checkTypeSig</A></B>(<A HREF="../../javafe/tc/TypeSig.html">TypeSig</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves <code>s</code> into the checked state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/util/Set.html">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#getAllImplementsSet(javafe.ast.MethodDecl)">getAllImplementsSet</A></B>(<A HREF="../../javafe/ast/MethodDecl.html">MethodDecl</A>&nbsp;md)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the set of interface <code>MethodDecl</code>s that a
 given class <code>MethodDecl</code> implements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/util/Set.html">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#getAllOverrides(javafe.ast.MethodDecl)">getAllOverrides</A></B>(<A HREF="../../javafe/ast/MethodDecl.html">MethodDecl</A>&nbsp;md)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the set of <code>MethodDecl</code>s that a given
 <code>MethodDecl</code> overrides or hides.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/ast/Stmt.html">Stmt</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#getBranchLabel(javafe.ast.BranchStmt)">getBranchLabel</A></B>(<A HREF="../../javafe/ast/BranchStmt.html">BranchStmt</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the <code>Stmt</code> target of a
 <code>BranchStmt</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/util/Set.html">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#getImplementsSet(javafe.ast.ClassDecl, javafe.ast.MethodDecl)">getImplementsSet</A></B>(<A HREF="../../javafe/ast/ClassDecl.html">ClassDecl</A>&nbsp;cd,
                 <A HREF="../../javafe/ast/MethodDecl.html">MethodDecl</A>&nbsp;md)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the set of interface <code>MethodDecl</code>s that a
 given class <code>MethodDecl</code> implements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/util/Set.html">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#getImplementsSet(javafe.ast.MethodDecl)">getImplementsSet</A></B>(<A HREF="../../javafe/ast/MethodDecl.html">MethodDecl</A>&nbsp;md)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the set of interface <code>MethodDecl</code>s that a
 given interface <code>MethodDecl</code> implements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#getName(javafe.ast.RoutineDecl)">getName</A></B>(<A HREF="../../javafe/ast/RoutineDecl.html">RoutineDecl</A>&nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the user-readable name for a <code>RoutineDecl</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/ast/MethodDecl.html">MethodDecl</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#getOverrides(javafe.ast.MethodDecl)">getOverrides</A></B>(<A HREF="../../javafe/ast/MethodDecl.html">MethodDecl</A>&nbsp;md)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the class <code>MethodDecl</code> that a given class
 <code>MethodDecl</code> overrides.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/tc/TypeSig.html">TypeSig</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#getRawSig(javafe.ast.TypeName)">getRawSig</A></B>(<A HREF="../../javafe/ast/TypeName.html">TypeName</A>&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#getRoutineName(javafe.ast.RoutineDecl)">getRoutineName</A></B>(<A HREF="../../javafe/ast/RoutineDecl.html">RoutineDecl</A>&nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the user-readable simple name for a <code>RoutineDecl</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/tc/TypeSig.html">TypeSig</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#getSig(javafe.ast.TypeDecl)">getSig</A></B>(<A HREF="../../javafe/ast/TypeDecl.html">TypeDecl</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the <code>TypeSig</code> associated with a particular
 <code>TypeDecl</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/tc/TypeSig.html">TypeSig</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#getSig(javafe.ast.TypeName)">getSig</A></B>(<A HREF="../../javafe/ast/TypeName.html">TypeName</A>&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the <code>TypeSig</code> associated with a particular
 <code>TypeName</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#getSignature(javafe.ast.RoutineDecl)">getSignature</A></B>(<A HREF="../../javafe/ast/RoutineDecl.html">RoutineDecl</A>&nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct a <code>String</code> listing the signature of a
 <code>RoutineDecl</code>, omitting the return type and throws
 causes if any.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/ast/Type.html">Type</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#getType(javafe.ast.VarInit)">getType</A></B>(<A HREF="../../javafe/ast/VarInit.html">VarInit</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the <code>Type</code> of a <code>VarInit</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/tc/FlowInsensitiveChecks.html">FlowInsensitiveChecks</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/tc/TypeCheck.html#makeFlowInsensitiveChecks()">makeFlowInsensitiveChecks</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Called to obtain the algorithm for performing name resolution
 and type checking.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, 
equals, 
finalize, 
getClass, 
hashCode, 
notify, 
notifyAll, 
toString, 
wait, 
wait, 
wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="inst"><!-- --></A><H3>
inst</H3>
<PRE>
public static <A HREF="../../javafe/tc/TypeCheck.html">TypeCheck</A> <B>inst</B></PRE>
<DL>
<DD>A (possibly extended) instance of TypeCheck.</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="TypeCheck()"><!-- --></A><H3>
TypeCheck</H3>
<PRE>
public <B>TypeCheck</B>()</PRE>
<DL>
<DD>Creates a instance of TypeCheck, and sets the <code>inst</code>
 field to this instance. Only one instance should be created. 
 Also initializes PrepTypeDeclaration.</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="makeFlowInsensitiveChecks()"><!-- --></A><H3>
makeFlowInsensitiveChecks</H3>
<PRE>
public <A HREF="../../javafe/tc/FlowInsensitiveChecks.html">FlowInsensitiveChecks</A> <B>makeFlowInsensitiveChecks</B>()</PRE>
<DL>
<DD>Called to obtain the algorithm for performing name resolution
 and type checking.  By default, returns an instance of
 <code>javafe.tc.FlowInsensitiveChecks</code>.</DL>
<HR>

<A NAME="checkTypeSig(javafe.tc.TypeSig)"><!-- --></A><H3>
checkTypeSig</H3>
<PRE>
public void <B>checkTypeSig</B>(<A HREF="../../javafe/tc/TypeSig.html">TypeSig</A>&nbsp;s)</PRE>
<DL>
<DD>Moves <code>s</code> into the checked state.  If any of the
supertypes of <CODE>s</CODE> are not prepped, they are prepped
first.</DL>
<HR>

<A NAME="checkTypeDecl(javafe.ast.TypeDecl)"><!-- --></A><H3>
checkTypeDecl</H3>
<PRE>
public void <B>checkTypeDecl</B>(<A HREF="../../javafe/ast/TypeDecl.html">TypeDecl</A>&nbsp;td)</PRE>
<DL>
<DD>Moves <code>td</code> into the checked state.  If any of the
supertypes of <CODE>s</CODE> are not prepped, they are prepped
first.</DL>
<HR>

<A NAME="getType(javafe.ast.VarInit)"><!-- --></A><H3>
getType</H3>
<PRE>
public <A HREF="../../javafe/ast/Type.html">Type</A> <B>getType</B>(<A HREF="../../javafe/ast/VarInit.html">VarInit</A>&nbsp;e)</PRE>
<DL>
<DD>Retrieves the <code>Type</code> of a <code>VarInit</code>.  This
 type is associated with an expression by the typechecking
 pass. If the expression does not have an associated type, then
 <code>Assert.fail</code> is called.</DL>
<HR>

<A NAME="getBranchLabel(javafe.ast.BranchStmt)"><!-- --></A><H3>
getBranchLabel</H3>
<PRE>
public <A HREF="../../javafe/ast/Stmt.html">Stmt</A> <B>getBranchLabel</B>(<A HREF="../../javafe/ast/BranchStmt.html">BranchStmt</A>&nbsp;s)</PRE>
<DL>
<DD>Retrieves the <code>Stmt</code> target of a
 <code>BranchStmt</code>.  This <code>Stmt</code> may be mentioned
 either explicitly (as in <code>break label;</code>), or
 implicitly (as in <code>break;</code>) by the
 <code>BranchStmt</code>.  The correct <code>Stmt</code> target is
 associated with the <code>BranchStmt</code> by the typechecking
 pass. This type is associated with an expression by the
 typechecking pass. If the <code>BranchStmt</code> does not have
 an associated <code>Stmt</code> target, then
 <code>Assert.fail</code> is called.</DL>
<HR>

<A NAME="getSig(javafe.ast.TypeDecl)"><!-- --></A><H3>
getSig</H3>
<PRE>
public <A HREF="../../javafe/tc/TypeSig.html">TypeSig</A> <B>getSig</B>(<A HREF="../../javafe/ast/TypeDecl.html">TypeDecl</A>&nbsp;d)</PRE>
<DL>
<DD>Retrieves the <code>TypeSig</code> associated with a particular
 <code>TypeDecl</code>.</DL>
<HR>

<A NAME="getSig(javafe.ast.TypeName)"><!-- --></A><H3>
getSig</H3>
<PRE>
public <A HREF="../../javafe/tc/TypeSig.html">TypeSig</A> <B>getSig</B>(<A HREF="../../javafe/ast/TypeName.html">TypeName</A>&nbsp;n)</PRE>
<DL>
<DD>Retrieves the <code>TypeSig</code> associated with a particular
 <code>TypeName</code>. 

 Precondition: n has been resolved.</DL>
<HR>

<A NAME="getRawSig(javafe.ast.TypeName)"><!-- --></A><H3>
getRawSig</H3>
<PRE>
public <A HREF="../../javafe/tc/TypeSig.html">TypeSig</A> <B>getRawSig</B>(<A HREF="../../javafe/ast/TypeName.html">TypeName</A>&nbsp;n)</PRE>
<DL>
</DL>
<HR>

<A NAME="getSignature(javafe.ast.RoutineDecl)"><!-- --></A><H3>
getSignature</H3>
<PRE>
public static java.lang.String <B>getSignature</B>(<A HREF="../../javafe/ast/RoutineDecl.html">RoutineDecl</A>&nbsp;r)</PRE>
<DL>
<DD>Construct a <code>String</code> listing the signature of a
 <code>RoutineDecl</code>, omitting the return type and throws
 causes if any. <p>

 All types are fully qualified if <code>r</code> has
 been name resolved.<p>

 Sample output: "(int, javafe.tc.TypeSig, char[])" <p>

 Precondition: PrettyPrint.inst, and r non-null.<p></DL>
<HR>

<A NAME="getName(javafe.ast.RoutineDecl)"><!-- --></A><H3>
getName</H3>
<PRE>
public java.lang.String <B>getName</B>(<A HREF="../../javafe/ast/RoutineDecl.html">RoutineDecl</A>&nbsp;r)</PRE>
<DL>
<DD>Returns the user-readable name for a <code>RoutineDecl</code>. <p>

 Either of the form "method <name>(<argument types>)" or the form
 "constructor <classname>(<argument types>)".<p>

 All argument types are fully qualified if
 <code>r</code> has been name resolved.  The method/constructor
 name is not qualified.<p>

 Precondition: PrettyPrint.inst, and r non-null.<p></DL>
<HR>

<A NAME="getRoutineName(javafe.ast.RoutineDecl)"><!-- --></A><H3>
getRoutineName</H3>
<PRE>
public java.lang.String <B>getRoutineName</B>(<A HREF="../../javafe/ast/RoutineDecl.html">RoutineDecl</A>&nbsp;r)</PRE>
<DL>
<DD>Returns the user-readable simple name for a <code>RoutineDecl</code>. <p>

 Precondition: r non-null.<p></DL>
<HR>

<A NAME="canAccess(javafe.tc.TypeSig, javafe.tc.TypeSig, int, javafe.ast.ModifierPragmaVec)"><!-- --></A><H3>
canAccess</H3>
<PRE>
public boolean <B>canAccess</B>(<A HREF="../../javafe/tc/TypeSig.html">TypeSig</A>&nbsp;from,
                         <A HREF="../../javafe/tc/TypeSig.html">TypeSig</A>&nbsp;target,
                         int&nbsp;modifiers,
                         <A HREF="../../javafe/ast/ModifierPragmaVec.html">ModifierPragmaVec</A>&nbsp;pmodifiers)</PRE>
<DL>
<DD>Can a member of type target with modifiers
 modifiers/pmodifiers be accessed by code located in from? <p>

 Note: pmodifiers may be null. <p></DL>
<HR>

<A NAME="getOverrides(javafe.ast.MethodDecl)"><!-- --></A><H3>
getOverrides</H3>
<PRE>
public <A HREF="../../javafe/ast/MethodDecl.html">MethodDecl</A> <B>getOverrides</B>(<A HREF="../../javafe/ast/MethodDecl.html">MethodDecl</A>&nbsp;md)</PRE>
<DL>
<DD>Retrieves the class <code>MethodDecl</code> that a given class
 <code>MethodDecl</code> overrides.  If there is no overridden
 <code>MethodDecl</code> in a superclass, then return
 <code>null</code>. The returned <code>MethodDecl</code> may be
 abstract. If multiple class <code>MethodDecl</code>'s are
 overridden, it returns the one lowest in the class hierarchy
 (furthest away from java.lang.Object). This information is
 generated by the 'Prep' pass.</DL>
<HR>

<A NAME="getImplementsSet(javafe.ast.ClassDecl, javafe.ast.MethodDecl)"><!-- --></A><H3>
getImplementsSet</H3>
<PRE>
public <A HREF="../../javafe/util/Set.html">Set</A> <B>getImplementsSet</B>(<A HREF="../../javafe/ast/ClassDecl.html">ClassDecl</A>&nbsp;cd,
                            <A HREF="../../javafe/ast/MethodDecl.html">MethodDecl</A>&nbsp;md)</PRE>
<DL>
<DD>Retrieves the set of interface <code>MethodDecl</code>s that a
 given class <code>MethodDecl</code> implements.  This information
 is generated by the 'Prep' pass.</DL>
<HR>

<A NAME="getAllImplementsSet(javafe.ast.MethodDecl)"><!-- --></A><H3>
getAllImplementsSet</H3>
<PRE>
public <A HREF="../../javafe/util/Set.html">Set</A> <B>getAllImplementsSet</B>(<A HREF="../../javafe/ast/MethodDecl.html">MethodDecl</A>&nbsp;md)</PRE>
<DL>
<DD>Retrieves the set of interface <code>MethodDecl</code>s that a
 given class <code>MethodDecl</code> implements.  This information
 is generated by the 'Prep' pass.</DL>
<HR>

<A NAME="getImplementsSet(javafe.ast.MethodDecl)"><!-- --></A><H3>
getImplementsSet</H3>
<PRE>
public <A HREF="../../javafe/util/Set.html">Set</A> <B>getImplementsSet</B>(<A HREF="../../javafe/ast/MethodDecl.html">MethodDecl</A>&nbsp;md)</PRE>
<DL>
<DD>Retrieves the set of interface <code>MethodDecl</code>s that a
 given interface <code>MethodDecl</code> implements.  This
 information is generated by the 'Prep' pass.</DL>
<HR>

<A NAME="getAllOverrides(javafe.ast.MethodDecl)"><!-- --></A><H3>
getAllOverrides</H3>
<PRE>
public <A HREF="../../javafe/util/Set.html">Set</A> <B>getAllOverrides</B>(<A HREF="../../javafe/ast/MethodDecl.html">MethodDecl</A>&nbsp;md)</PRE>
<DL>
<DD>Retrieves the set of <code>MethodDecl</code>s that a given
 <code>MethodDecl</code> overrides or hides.  This information is
 generated by the 'Prep' pass.</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT ID="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT ID="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT ID="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT ID="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT ID="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT ID="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javafe/tc/TagConstants.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../javafe/tc/TypePrint.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="TypeCheck.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
