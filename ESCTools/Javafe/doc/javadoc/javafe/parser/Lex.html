<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Tue Nov 27 10:53:31 PST 2001 -->
<TITLE>
: Class  Lex
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT ID="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT ID="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT ID="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT ID="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT ID="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT ID="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../javafe/parser/Parse.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Lex.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javafe.parser</FONT>
<BR>
Class  Lex</H2>
<PRE>
java.lang.Object
  |
  +--<A HREF="../../javafe/parser/Token.html">javafe.parser.Token</A>
        |
        +--<B>javafe.parser.Lex</B>
</PRE>
<HR>
<DL>
<DT>public class <B>Lex</B><DT>extends <A HREF="../../javafe/parser/Token.html">Token</A></DL>

<P>
A <TT>Lex</TT> object generates a sequence of of Java "input elements"
(that is, tokens) by converting the sequence of input characters and
line terminators generated by an underlying
<code>CorrelatedReader</code>.

<p> The conversion of input characters occurs according to the lexical
rules in Chapter Three of the <cite>Java Language
Specification</cite>.  This specification describes three lexical
translation steps: the first two steps translate a raw Unicode input
stream into a "cooked" one in which Unicode escape characters from the
raw stream have been processed and in which line terminators have been
identified; the last step translates this cooked stream into a
sequence of Java "input elements" (comments, white space, identifiers,
tokens, literals, and punctuation).  <code>Lex</code> objects perform
the last of these translations steps; the first two are performed by
an underlying <code>CorrelatedReader</code> that is given to the
<code>Lex</code> object as the source of input characters.

<p> Before a newly-created <code>Lex</code> object can be used, its
<code>restart</code> method must be called giving a
<code>CorrelatedReader</code> to scan.  At any point, a
<code>Lex</code> can be restarted on a different underlying reader.

<p> The <TT>Lex</TT> class is thread safe, but instances of
<TT>Lex</TT> are not.  That is, two different threads may safely
access two different instances of <TT>Lex</TT> concurrently, but they
may not access the same instance of <TT>Lex</TT> concurrently.


<h3> Simple scanning </h3>

<p> The <code>getNextToken</code> method of <code>Lex</code> objects
returns the translated token sequence, one token at a time.  It
discards white space, and it processes comments as described below.
In addition, <code>getNextToken</code> fills in the <code>Token</code>
fields of <code>this</code> (<code>Lex</code> is a subclass of
<code>Token</code>); for example, <code>ttype</code> gets an integer
code defining the type of token returned and <code>startingLoc</code>
gives the location of the first character making up the token.  If the
token is an identifier, <code>identifierVal</code> indicates which
one; if the token is a literal, <code>auxVal</code> gives its value.

<p> <code>Lex</code> objects report errors by calling both the
<code>fatal</code> and <code>error</code> methods of
<code>ErrorSet</code>.  The fatal errors are unexpected characters,
unterminated comments and string and character literals, and IO errors
in the underlying input stream.  Recoverable errors are overflows in
literals (including overflows in octal escape sequences), non-octal
digits in integer literals, the string <code>0x</code> (interpreted as
a malformed integer literal), missing digits in a floating-point
exponent, bad escape sequences in character and string literals,
character literals containing no or multiple characters, and the
character literal <code>'''</code> (interpreted as <code>'\''</code>).


<h3> Lookahead </h3>

<code>Lex</code> objects allow their clients to peek ahead into the
token stream by calling <code>lookahead</code>.  This method returns
the token code for the future token, but it does not affect the
<code>Token</code> fields of <code>this</code>.

<p> If a call to <code>lookahead</code> needs to look past the set of
tokens already scanned, and those tokens have errors, then the errors
are reported immediately.


<h3> Extensibility: Keywords, punctuation </h3>

<p> A keyword is a Java identifier with a special token code.
Ordinarily, identifiers are associated with the code
<code>TagConstants.IDENT</code>.  Keywords, while matching the lexical
grammar of identifiers, are associated with different codes.  In fact,
each keyword is typically associated with its own code.

<p> The set of identifiers that a <code>Lex</code> object recognizes
as keywords is extensible.  A keyword is added to a <code>Lex</code>
object by calling the <code>addKeyword</code> method.  As a
convenience, a boolean given to the <code>Lex</code> constructor
indicates whether a newly-constructed <code>Lex</code> object should
automatically have all Java keywords added to it.

<p> A punctuation string is a string of punctuation characters
recognized by a <code>Lex</code> object to be a token.  (Punctuation
characters are non-alphanumeric ASCII characters whose ASCII codes are
between 33 ('!')  and 126 ('~') inclusive.)  As with keywords, the set
of punctuation strings recognized by a <code>Lex</code> object is
extensible.  A punctuation string is added to a <code>Lex</code>
object by calling the <code>addPunctuation</code> method.  A boolean
given to the <code>Lex</code> constructor indicates whether a
newly-constructed <code>Lex</code> object should automatically have
all Java punctuation strings added to it.


<h3> Extensibility: comments and pragmas </h3>

<p> The handling of comments is special in two ways: the punctuation
strings that start comments is extensible, the text of comments can be
parsed for pragmas.

<h5> Comment recognition </h5>

<p> Ordinarily, keywords and punctuation strings are mapped to token
codes that are returned by calls to <code>getNextToken</code>.
However, two token codes are treated specially:
<code>TagConstants.C_COMMENT</code> and <code>TagConstants.EOL_COMMENT</code>.
These codes are used to indicate the start of C-like comments
(<code>/*...*</code><code>/</code>) and end-of-line comments
(<code>//...</code>), respectively.  When a keyword or punctuation
string is mapped to these codes, it is handled like a comment
initiator rather than a regular token.

<p> For all newly-created <code>Lex</code> objects, <code>/*</code> is
mapped to <code>TagConstants.C_COMMENT</code> and <code>//</code> is mapped
to <code>TagConstants.EOL_COMMENT</code>.  Other punctuation strings can be
made comment initiators by mapping them to comment-initiating codes.
This is more useful for <code>TagConstants.EOL_COMMENT</code> than for
<code>TagConstants.C_COMMENT</code>, since the string
<code>*</code><code>/</code> is hard-wired as the terminator of C-like
comments.

<h5> Pragma parsing </h5>

<code>Lex</code> objects are designed to support annotation of Java
programs through pragmas.  A <a href = "../pragma-handling.html">
separate document </a> describes our overall aproach to pragmas.  In
brief, our front-end supports two kinds of pragmas: control pragmas
that can appear anywhere in an input file and are collected in a list
apart from the parse tree, and syntax pragmas that can only appear in
certain grammatical contexts and become part of the parse tree.
Pragmas always appear in Java comments, at most one pragma per
comment.  These comments must have one of the following forms:

<menu>
<li> <code>/*</code><i>tag</i> <i>white-space</i> <i>pragma-text</i><code>*</code><code>/</code>
<li> <code>//</code><i>tag</i> <i>white-space-minus-EOL</i> <i>pragma-text</i> <i>EOL</code>
</menu>

<p> When a <code>Lex</code> object is created, it can optionally be
associated with a <code>PragmaParser</code> object.  If a
<code>Lex</code> object has no <code>PragmaParser</code>, it discards
all comments.  Otherwise, the <code>Lex</code> object passes the first
character of the comment (or -1 if the comment is empty) to the
<code>checkTag</code> method of the <code>PragmaParser</code> object,
which returns <code>false</code> if the comment definitely does not contain
any pragmas.  If the comment may contain pragmas, the <code>Lex</code>
object bundles the text between the delimiters of a comment into a
<code>CorrelatedReader</code> which it passes to the <code>restart</code>
method of its <code>PragmaParser</code>.  (This text excludes both the
opening <code>/*</code> or <code>//</code> and the closing
<code>*</code><code>/</code> or line terminator.)

<p> The <code>Lex</code> object then calls <code>getNextPragma</code> to
read the pragmas out of the
comment one at a time.  The <code>Lex</code> object does this in a
lazy manner; that is, it reads a pragma, returns it to the parser, and
waits until the parser calls for the next token before it attempts to
read another pragma.  The <code>getNextPragma</code> method returns a
boolean, returning <code>false</code> if there are no more pragmas to
be parsed.  The <code>getNextPragma</code> method takes a
<code>Token</code> as an argument, storing information about the
pragma parsed into this argument.

<p> When <code>PragmaParser.getNextPragma</code> returns a
<code>LexicalPragma</code>, the <code>Lex</code> object puts it in an
internal list rather than returning it to the parser.  The list of
collected lexical pragmas can be retrieved by calling
<code>getLexicalPragmas</code>.
<P>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../javafe/util/CorrelatedReader.html"><CODE>CorrelatedReader</CODE></A>, 
<A HREF="../../javafe/parser/TagConstants.html"><CODE>TagConstants</CODE></A>, 
<A HREF="../../javafe/parser/Token.html"><CODE>Token</CODE></A>, 
<A HREF="../../javafe/parser/PragmaParser.html"><CODE>PragmaParser</CODE></A></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#inPragma">inPragma</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#javakeywords">javakeywords</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#keywords">keywords</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unenforceable invariant: all tokenTypes in this table do not
 require a non-null auxVal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javafe/ast/LexicalPragmaVec.html">LexicalPragmaVec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#lexicalPragmas">lexicalPragmas</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;javafe.parser.TokenQueue</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#lookaheadq">lookaheadq</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javafe/util/CorrelatedReader.html">CorrelatedReader</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#m_in">m_in</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Current state of input stream underlying the scanner minus the
 first character.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#m_nextchr">m_nextchr</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Each call to <code>getNextToken</code> reads ahead one character
and leaves the result in <code>m_nextchr</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#onlyjavakeywords">onlyjavakeywords</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javafe/parser/PragmaParser.html">PragmaParser</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#pragmaParser">pragmaParser</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javafe/parser/Token.html">Token</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#savedState">savedState</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#text">text</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The characters that constitute the current token.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#textlen">textlen</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of characters in the current token.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_javafe.parser.Token"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from class javafe.parser.<A HREF="../../javafe/parser/Token.html">Token</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../javafe/parser/Token.html#auxVal">auxVal</A>,  
<A HREF="../../javafe/parser/Token.html#CLEAR">CLEAR</A>,  
<A HREF="../../javafe/parser/Token.html#endingLoc">endingLoc</A>,  
<A HREF="../../javafe/parser/Token.html#identifierVal">identifierVal</A>,  
<A HREF="../../javafe/parser/Token.html#startingLoc">startingLoc</A>,  
<A HREF="../../javafe/parser/Token.html#ttype">ttype</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#Lex(javafe.parser.PragmaParser, boolean)">Lex</A></B>(<A HREF="../../javafe/parser/PragmaParser.html">PragmaParser</A>&nbsp;pragmaParser,
    boolean&nbsp;isJava)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a lexical analyzer that will tokenize the characters
read from an underlying <code>CorrelatedReader</code>.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#addJavaKeywords()">addJavaKeywords</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add all of Java's keywords to the scanner.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#addJavaPunctuation()">addJavaPunctuation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add all of Java's punctuation strings to the scanner.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#addKeyword(java.lang.String, int)">addKeyword</A></B>(java.lang.String&nbsp;newkeyword,
           int&nbsp;code)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a keyword to a <code>Lex</code> object with the given code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#addPunctuation(java.lang.String, int)">addPunctuation</A></B>(java.lang.String&nbsp;punctuation,
               int&nbsp;code)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a punctuation string to a scanner associated with a given
code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#append(int)">append</A></B>(int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Append 'c' to <CODE>text</CODE>, expanding if necessary.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#close()">close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Closes the <code>CorrelatedReader</code> underlying
<code>this</code>, clears the set of collected lexical pragmas,
and in other ways frees up resources associated with
<code>this</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/ast/LexicalPragmaVec.html">LexicalPragmaVec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#getLexicalPragmas()">getLexicalPragmas</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the set of lexical pragmas collected.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#getNextToken()">getNextToken</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scans next token from input stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#lookahead(int)">lookahead</A></B>(int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns token type of the <TT>k</TT>th future token, where k=0
is the current token.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/ast/LexicalPragma.html">LexicalPragma</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#popLexicalPragma()">popLexicalPragma</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove the first LexicalPragma from our set of lexical pragmas
 collected, returning it or null if our set is empty.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#restart(javafe.util.CorrelatedReader)">restart</A></B>(<A HREF="../../javafe/util/CorrelatedReader.html">CorrelatedReader</A>&nbsp;in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Start scaning a new <code>CorrelatedReader</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#scanJavaExtensions(int)">scanJavaExtensions</A></B>(int&nbsp;nextchr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scans a Java extension.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#zzz(java.lang.String)">zzz</A></B>(java.lang.String&nbsp;prefix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks invariants (assumes that <CODE>Token</CODE> fields
haven't been mucked with by outside code).</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javafe.parser.Token"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class javafe.parser.<A HREF="../../javafe/parser/Token.html">Token</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../javafe/parser/Token.html#clear()">clear</A>, 
<A HREF="../../javafe/parser/Token.html#copyInto(javafe.parser.Token)">copyInto</A>, 
<A HREF="../../javafe/parser/Token.html#ztoString()">ztoString</A>, 
<A HREF="../../javafe/parser/Token.html#zzz()">zzz</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, 
equals, 
finalize, 
getClass, 
hashCode, 
notify, 
notifyAll, 
toString, 
wait, 
wait, 
wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="m_in"><!-- --></A><H3>
m_in</H3>
<PRE>
protected <A HREF="../../javafe/util/CorrelatedReader.html">CorrelatedReader</A> <B>m_in</B></PRE>
<DL>
<DD>Current state of input stream underlying the scanner minus the
 first character.  See <code>m_nextchr</code>. <p>

 This is null iff we are closed.</DL>
<HR>

<A NAME="m_nextchr"><!-- --></A><H3>
m_nextchr</H3>
<PRE>
protected int <B>m_nextchr</B></PRE>
<DL>
<DD>Each call to <code>getNextToken</code> reads ahead one character
and leaves the result in <code>m_nextchr</code>.  In other words,
between calls to <code>getNextToken</code>, the stream of
characters yet-to-scanned consists of the character in
<code>m_nextchr</code> followed by the characters remaining in
<code>m_in</code>.</DL>
<HR>

<A NAME="text"><!-- --></A><H3>
text</H3>
<PRE>
protected char[] <B>text</B></PRE>
<DL>
<DD>The characters that constitute the current token.  Only the
first <TT>textlen</TT> characters are part of the current token;
the actual length of <TT>text</TT> may be bigger.  The lexer may
occasionally need to resize <TT>text</TT>, so the same array might
not be used throughout the lifetime of the lexer.</DL>
<HR>

<A NAME="textlen"><!-- --></A><H3>
textlen</H3>
<PRE>
protected int <B>textlen</B></PRE>
<DL>
<DD>The number of characters in the current token.  The "current
token" is the one parsed by the previous call to
<TT>getNextToken</TT> (there is no "current token" between
creation of a lexer and the first call to getNextToken).</DL>
<HR>

<A NAME="lookaheadq"><!-- --></A><H3>
lookaheadq</H3>
<PRE>
protected final javafe.parser.TokenQueue <B>lookaheadq</B></PRE>
<DL>
</DL>
<HR>

<A NAME="lexicalPragmas"><!-- --></A><H3>
lexicalPragmas</H3>
<PRE>
protected <A HREF="../../javafe/ast/LexicalPragmaVec.html">LexicalPragmaVec</A> <B>lexicalPragmas</B></PRE>
<DL>
</DL>
<HR>

<A NAME="pragmaParser"><!-- --></A><H3>
pragmaParser</H3>
<PRE>
protected <A HREF="../../javafe/parser/PragmaParser.html">PragmaParser</A> <B>pragmaParser</B></PRE>
<DL>
</DL>
<HR>

<A NAME="inPragma"><!-- --></A><H3>
inPragma</H3>
<PRE>
protected boolean <B>inPragma</B></PRE>
<DL>
</DL>
<HR>

<A NAME="savedState"><!-- --></A><H3>
savedState</H3>
<PRE>
protected <A HREF="../../javafe/parser/Token.html">Token</A> <B>savedState</B></PRE>
<DL>
</DL>
<HR>

<A NAME="keywords"><!-- --></A><H3>
keywords</H3>
<PRE>
protected java.util.Hashtable <B>keywords</B></PRE>
<DL>
<DD>Unenforceable invariant: all tokenTypes in this table do not
 require a non-null auxVal.  (cf. Token.auxVal).</DL>
<HR>

<A NAME="javakeywords"><!-- --></A><H3>
javakeywords</H3>
<PRE>
protected boolean <B>javakeywords</B></PRE>
<DL>
</DL>
<HR>

<A NAME="onlyjavakeywords"><!-- --></A><H3>
onlyjavakeywords</H3>
<PRE>
protected boolean <B>onlyjavakeywords</B></PRE>
<DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Lex(javafe.parser.PragmaParser, boolean)"><!-- --></A><H3>
Lex</H3>
<PRE>
public <B>Lex</B>(<A HREF="../../javafe/parser/PragmaParser.html">PragmaParser</A>&nbsp;pragmaParser,
           boolean&nbsp;isJava)</PRE>
<DL>
<DD>Creates a lexical analyzer that will tokenize the characters
read from an underlying <code>CorrelatedReader</code>.  Before the
newly-created scanner can be used, its <code>restart</code> method
must be called on a <code>CorrelatedReader</code>.  The
<code>pragmaParser</code> object is used to parse pragmas out of
comments; if it is <code>null</code>, all comments are discareded.
The <code>isJava</code> flag controls the initial set of keywords
and punctuation strings; if <code>true</code>, the new scanner
will recognize Java's keywords and punctuation strings, if
<code>false</code>, the new scanner will recognize <em>no</em>
keywords or punctuation strings.  If <code>isJava</code> is true,
the token codes used for the Java's keywords and punctuation
strings are those defined by the <code>TagConstants</code> class.</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="append(int)"><!-- --></A><H3>
append</H3>
<PRE>
protected void <B>append</B>(int&nbsp;c)</PRE>
<DL>
<DD>Append 'c' to <CODE>text</CODE>, expanding if necessary.</DL>
<HR>

<A NAME="restart(javafe.util.CorrelatedReader)"><!-- --></A><H3>
restart</H3>
<PRE>
public int <B>restart</B>(<A HREF="../../javafe/util/CorrelatedReader.html">CorrelatedReader</A>&nbsp;in)</PRE>
<DL>
<DD>Start scaning a new <code>CorrelatedReader</code>.  First closes
the old <code>CorrelatedReader</code> associated with
<code>this</code> (if there was one), and clears out the set of
collected lexical pragms.  In addition to (re)-seting the
underlying input stream, this method scans the first token,
returning the token kind of the result and setting the
<code>Token</code> fields of <code>this</code>.  If a
<code>CorrelatedReader</code> is already underlying
<code>this</code>, it is closed before the new reader is
installed.  Note: The argument <code>in</code> is "captured" in
the internal, private state of the resulting scanner and should
not be used by other parts of the program.</DL>
<HR>

<A NAME="close()"><!-- --></A><H3>
close</H3>
<PRE>
public void <B>close</B>()</PRE>
<DL>
<DD>Closes the <code>CorrelatedReader</code> underlying
<code>this</code>, clears the set of collected lexical pragmas,
and in other ways frees up resources associated with
<code>this</code>.  After being closed, a <code>Lex</code> object
can be restarted by calling <code>restart</code>.  (An IO
exception raised by closing the underlying input stream will be
converted into a <code>javafe.util.FatalError</code> runtime
exception.)</DL>
<HR>

<A NAME="getNextToken()"><!-- --></A><H3>
getNextToken</H3>
<PRE>
public int <B>getNextToken</B>()</PRE>
<DL>
<DD>Scans next token from input stream.  Returns the code of the
next token in the token stream and fills in the <code>Token</code>
fields of <CODE>this</CODE>.  Note that the
<code>startingLoc</code> and <code>endingLoc</code> fields of
<code>this</code> are not accurate for the end-of-file token.</DL>
<HR>

<A NAME="lookahead(int)"><!-- --></A><H3>
lookahead</H3>
<PRE>
public int <B>lookahead</B>(int&nbsp;k)</PRE>
<DL>
<DD>Returns token type of the <TT>k</TT>th future token, where k=0
is the current token.  If <code>k</code> is past the end of the
token stream, <code>TagConstants.EOF</code> is returned.</DL>
<HR>

<A NAME="getLexicalPragmas()"><!-- --></A><H3>
getLexicalPragmas</H3>
<PRE>
public <A HREF="../../javafe/ast/LexicalPragmaVec.html">LexicalPragmaVec</A> <B>getLexicalPragmas</B>()</PRE>
<DL>
<DD>Returns the set of lexical pragmas collected.  It also clears
the set of lexical pragmas so that the next call will not include
them.  (If this lexer has no <code>PragmaParser</code>, then an
empty vector is returned.)</DL>
<HR>

<A NAME="popLexicalPragma()"><!-- --></A><H3>
popLexicalPragma</H3>
<PRE>
public <A HREF="../../javafe/ast/LexicalPragma.html">LexicalPragma</A> <B>popLexicalPragma</B>()</PRE>
<DL>
<DD>Remove the first LexicalPragma from our set of lexical pragmas
 collected, returning it or null if our set is empty.</DL>
<HR>

<A NAME="scanJavaExtensions(int)"><!-- --></A><H3>
scanJavaExtensions</H3>
<PRE>
protected int <B>scanJavaExtensions</B>(int&nbsp;nextchr)</PRE>
<DL>
<DD>Scans a Java extension.  If input doesn't match any Java extension,
returns <code>TagConstants.NULL</code>.  Assumes <code>startingLoc</code>
already filled in, and assumes <code>textlen</code> is 0.

<p>The routine may change the mark arbitrarily.

<p> If a Java extension is matched, returns with <code>m_nextchr</code>
holding the character just after the token scanned and <code>m_in</code>
pointing to the character after that.</DL>
<HR>

<A NAME="addJavaKeywords()"><!-- --></A><H3>
addJavaKeywords</H3>
<PRE>
public void <B>addJavaKeywords</B>()</PRE>
<DL>
<DD>Add all of Java's keywords to the scanner.  The token codes used
for these keywords are those defined by the <code>TagConstants</code>
class.  Requires that none of these keywords have been added
already.</DL>
<HR>

<A NAME="addKeyword(java.lang.String, int)"><!-- --></A><H3>
addKeyword</H3>
<PRE>
public void <B>addKeyword</B>(java.lang.String&nbsp;newkeyword,
                       int&nbsp;code)</PRE>
<DL>
<DD>Add a keyword to a <code>Lex</code> object with the given code.
 Requires that <code>newkeyword</code> is a Java identifier and
 that <code>code</code> is not <code>TagConstants.NULL</code> or
 a tokenType that requires auxVal to be non-null
 (cf. Token.auxVal).

 Also requires that the keyword hasn't already been added.</DL>
<HR>

<A NAME="addJavaPunctuation()"><!-- --></A><H3>
addJavaPunctuation</H3>
<PRE>
public void <B>addJavaPunctuation</B>()</PRE>
<DL>
<DD>Add all of Java's punctuation strings to the scanner.  The codes
used for these punctuation strings are the found in the
<code>TagConstants</code> class.  Requires that none of these
punctuation strings have been added before.</DL>
<HR>

<A NAME="addPunctuation(java.lang.String, int)"><!-- --></A><H3>
addPunctuation</H3>
<PRE>
public void <B>addPunctuation</B>(java.lang.String&nbsp;punctuation,
                           int&nbsp;code)</PRE>
<DL>
<DD>Add a punctuation string to a scanner associated with a given
code.  Requires that the characters in the punctuation string are
all punctuation characters, that is, non-alphanumeric ASCII
characters whose codes are between 33 ('!')  and 126 ('~')
inclusive.  Also requires that the code is not
<code>TagConstants.NULL</code> and that the punctuation string
hasn't already been added.</DL>
<HR>

<A NAME="zzz(java.lang.String)"><!-- --></A><H3>
zzz</H3>
<PRE>
public void <B>zzz</B>(java.lang.String&nbsp;prefix)</PRE>
<DL>
<DD>Checks invariants (assumes that <CODE>Token</CODE> fields
haven't been mucked with by outside code).  <code>prefix</code> is
used to prefix error messages with context provided by the
caller.</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT ID="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT ID="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT ID="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT ID="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT ID="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT ID="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../javafe/parser/Parse.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Lex.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
