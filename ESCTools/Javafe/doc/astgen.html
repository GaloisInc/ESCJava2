<html>

<head>
<title>Astgen manual</title>
</head>

<body>

<h1> Astgen manual </h1>

<h6> Last modified: 24 January 2003 by Joe Kiniry </h6>

<hr />

<p> The <code>astgen</code> tool reads in a file containing annotated,
partial implementations of AST classes and writes full implementations
for those classes, putting each in its own source file.  It also
outputs two auxilliary classes.  Using the generator leads to a
description of AST classes that is more manageable than the full
implementation would be because it is in a single file and because it
is smaller by a factor an order of magnitude.  Also, the generator
allows one to easily change an AST hierarchy and the code found inside
of AST classes. </p>

<p> The input to <code>astgen</code> looks very much like a set of
Java class declarations.  These declarations are annotated with Java
comments containing pragmas understood by <code>astgen</code>.  The
input must use Java's lexical language and must follow the following
grammar:

<pre>
<i>PackageDeclaration_opt ImportDeclarations_opt EndHeader ClassDeclaration</i>*
</pre>

where the non-terminals other than <i>EndHeader</i> are defined in the
Java Language Specification.  The <i>EndHeader</i> is a Java
single-line comment starting with <code>//#</code> followed by some
space then followed by the keyword <code>EndHeader</code> (case is
significant to <code>astgen</code>).  If a <i>ClassDeclaration</i> in
an <code>astgen</code> input file has a superclass, the declaration of
that superclass must appear earlier in the input file. </p>

<p> Given such an input file, <code>astgen</code> does the following:

<ul>

  <li> All text (including comments and whitespace) before the
      <code>EndHeader</code> directive is read as the "generic header."  It
      is meant to include a package declaration and imports that apply to
      every AST class specified in the input file.
  </li>

  <li> For each <code>ClassDeclaration</code> named <code>C</code>,
      a file named <code>C.java</code> is created.  The generic header is
      written to this file.  Then, all text of <code>C</code>, including
      whitespace and comments, is copied into this file.  (This text
      includes everthing up to and including the closing brace
      (<code>}</code>) of <code>C</CODE>, plus any white space after that
      brace up to (and including) the first new line.)  Along the way,
      pragmas in <code>C</code> may be expanded, as described below.  Also,
      a number of "boilerplate" members are generated into <code>C</code>.
  </li>

  <li> After all class declarations are processed, some auxilliary
      files are generated, as described below.
  </li>

</ul>


<h3> Output </h3>

<p> The tool outputs one <code>.java</code> file for each
<code>ClassDeclaration</code> in the input file.  As discussed above,
these per-class <code>.java</code> files consist mostly of the generic
header appended to the text of the class declarations, plus some
boilerplate methods generated automatically.  "Child fields" of an AST
node are declared using pragmas (pragmas are described in the next
section).  Child fields are public fields pointing to what should be
the children of an AST node.  The child fields of a class declaration
play an important role in the generation of the boilerplate for the
declaration. </p>

<p> In addition to the per-class <code>.java</code> files, the tool
outputs a file called <code>TagConstants.java</code> and another
called <code>Visitor.java</code>.  These files support the boilerplate
code generated for the per-class <code>.java</code> files. </p>

<p> The bullet points below describe the boilerplate methods generated
plus the two support files for them. </p>

<ul>

  <li> <b> Object construction. </b> Classes generated by
      <code>astgen</code> are meant to be instantiated via static "maker"
      methods rather than through constructors.  This convention allows one
      to intern certain AST nodes, for example, the node representing the
      type <code>int</code>.  To keep clients from directly instantiating
      AST classes, <code>astgen</code> generates a protected constructor
      that takes no arguments for non-abstract classes. <br /><br />

      For each non-abstract class <code>C</code>, <code>astgen</code>
      generates a public, static method named <code>make</code>.  The
      default implementation of <code>make</code> returns a newly-allocated
      instance of <code>C</code>.  (This default can be overriden using
      pragmas.)  The <code>make</code> method takes an argument for each
      child field of <code>C</code>, including child fields inherited from
      the superclass of <code>C</code>.  The order of the argument list is
      as follows: superclass child fields come before subclass child fields;
      within a class, child-field arguments are ordered according by the
      order of the pragmas defining the child fields.
  </li>


  <li> <b> Tags. </b> To support the use of <code>switch</code>
      statements to distinguish different AST node types,
      <code>astgen</code> outputs an instance method <code>getTag</code> in
      each non-abstract class and also outputs a constant field declaration
      in <code>TagConstants</code>. <br /> <br />

      In non-abstract class <code>Name</code>, the
      automatically-generated <code>getTag</code> method returns the
      constant <code>TagConstants.NAME</code> (note the change to
      all-caps).  In <code>TagConstants</code>, a constant
      <code>int</code> field named <code>NAME</code> is also
      generated.  <!-- The intent is for the (user-written) type
      <code>TagConstants</code> to extend the automatically-generated
      interface <code>TagConstants</code>. --> <br /> <br />

      <!-- The <code>TagConstants</code> interface is not public (ie, it
      has "package" level protection). --> The generic header is also appended
      to the front of <code>TagConstants.java</code>, which will put it
      into the same package as the other classes generated for a given input
      file.
  </li>


  <li> <b> Visitors. </b> To support the use of visitors for
      traversing ASTs, the code generator outputs an instance method
      <code>accept</code> and also outputs an abstract class
      <code>Visitor</code> which is the superclass for all visitors. <br /> <br />
      
      The <code>accept</code> method for class <code>Name</code> looks
      like the following:

      <blockquote>
      <pre> public void accept(Visitor v) { v.visitName(this); } </pre>
      </blockquote>

      An <code>accept</code> method is generated only for non-abstract
      classes. <br /> <br />

      For every class <code>C</code> (abstract and non-abstract), a
      method named <code>visitC</code> is generated in the
      <code>Visitor</code> class.  This method takes an argument of type
      <code>C</code> and returns <code>void</code>.  If <code>C</code>
      has no explicitly declared superclass, then <code>visitC</code> is
      an abstract method.  If there is a superclass named
      <code>S</code>, then an implementation of <code>visitC</code> is
      generated which looks like

      <blockquote>
      <pre> public void visitC(C o) { visitS(o); } </pre>
      </blockquote>

      The <code>Visitor</code> class is public.  The generic header
      is also appended to the front of <code>Visitor.java</code>, which
      will put it into the same package as the other classes generated
      for a given input file.
  </li>


  <li> <b> Children. </b> To help in traversing an AST, two methods,
      <code>childCount</code> and <code>childAt</code>, are generated into
      non-abstract classes for counting and extracting the (direct) children
      of a node. <br /> <br />

      As in the case of the maker methods, "children" here includes
      children inherited from superclasses; also, the order of "children" is
      defined the same as for makers.  However, there are two twists.
      First, children that are primitive types such as <code>int</code> are
      not counted by <code>childCount</code> or returned by
      <code>childAt</code>.  Also, the pragmas defining child fields allow
      for the specification of child fields that are really sets of
      children; we call these "vector children."  The
      <code>childCount</code> method counts each member of a vector child as
      a separate child; similarly, the numbering of children for the purpose
      of defining indices given to <code>childAt</code> also counts each
      member of a vector child as a separate child.
  </li>

  <li> <b> Invariant checking. </b> For all classes (abstract and
      non-abstract), a method called <code>check</code> is generated for
      dynamically checking invariants of a node.  This method takes no
      arguments and returns <code>void</code>.  This method first calls
      <code>super.check</code>, then performs checks on each locally defined
      child field whose type is not a primitive type.  The default,
      per-field checks are (a) to ensure that the field is not null and (b)
      to call the <code>check</code> method on the object in the field.
      (These checks can be change via pragmas; see below.)  For vector
      children, the above checks are done on each member of the vector.
  </li>
      
  <li> <b> Debug presentation. </b> For non-abstract classes, a
      <code>toString</code> instance method is generated that returns a
      <code>String</code> representation suitable for debugging output.
  </li>
      
</ul>

<p> The discussion above suggest that many of the above methods are
generated only in non-abstract classes.  This is not exactly true.  As
mentioned earlier, if a <code>ClassDeclaration</code> in the input to
the tool has a superclass, the declaration of that superclass must
appear earlier in the input file.  This implies that every input file
declares a set of "root" classes that are superclasses of all the
other, non-root classes declared in the file.  If a class is both
abstract and one of these root classes, then the tool generates into
it abstract versions of the methods listed above (that is, versions
without implementations).  This means that the methods defined above
can be called on <em>all</em> AST nodes, not just concrete ones. </p>


<h3> Pragmas </h3>

<p> Inside a <code>ClassDeclaration</code>, between member
declarations, <code>astgen</code> recognizes a number of pragmas which
either generate member declarations or control the output of
boilerplate members. </p>

<p> The syntax of a pragma is a Java single-line comment on a line by
itself.  Pragma comments are distinguished by starting with
<code>//#</code>. </p>

<p> Inside class <code>C</code>, the following pragma defines the
child fields of <code>C</code>: </p>

<ul>

  <li> "<code>//#</code> <i>Type</i> [<code>*</code>] <i>Identifier</i>
      {<code>NullOk</code>|<code>NoCheck</code>}*". <br /> <br />

      If the <code>*</code> is present, the pragma defines a vector
      child; otherwise, it defines a regular child.  The following pragmas:

      <blockquote>
      <pre>
      //# Name1 id1
      //# Name2* id2
      </pre>
      </blockquote>

      would be translated into the following field declarations:

      <blockquote>
      <pre>
      public Name1 id1;
      public Name2Vec id2;
      </pre>
      </blockquote>

      It is up to the <code>astgen</code> user to provide definitions of
      <code>Name2Vec</code> and other <code>???Vec</code> types referenced
      by the output of <code>astgen</code>.

      The <code>NullOK</code> and <code>NoCheck</code> pragmas control
      the checking done for the field by the <code>check</code> method.  The
      first supresses the check that a child field is not <code>null</code>;
      the second supresses the call to the child's <code>check</code>
      method.
  </li>
      
</ul>

<p> The following pragmas apply to a class as a whole rather than to
individual fields.  They control non-field specific aspects of the
generation of boilerplate methods like <code>make</code> and
<code>check</code>.  The syntax of these pragma is again a single line
comment begining with <code>//#</code> and containing a single
keyword. </p>

<ul>
  <li> "<code>//#</code> <code>NoMaker</code></code>". <br /> <br />

      Inside class <code>C</code>, this declaration suppresses the
      generation of <code>C</code>'s <code>make</code> method, allowing a
      custom maker to be written instead (or none at all).
  </li>

  <li> "<code>//#</code> <code>ManualTag</code>". <br /> <br />

      Inside class <code>C</code>, this declaration suppresses the
      generation of <code>C</code>'s <code>getTag</code> method, allowing a
      custom one to be written instead.  In our Java front-end, we use this
      feature to allow us to return different tags for
      <code>BinaryExpr</code> depending on the expression's operation.
  </li>

  <li> "<code>//#</code> <code>PostMakeCall</code>". <br /> <br />

      Inside class <code>C</code>, this declaration adds the following
      line to the end of <code>C</code>'s automatically-generated
      <code>make</code> method:

      <blockquote> <pre> postMake(); </pre> </blockquote>

      No implementation of <code>postMake</code> is generated.  The intent
      is for the user to write <code>postMake</code> themselves, giving them
      a hook to customize the initialization of nodes after the child fields
      are filled in using the arguments to <code>make</code>.  In our Java
      front-end, we use this feature to allow us, in the maker for
      <code>CompilationUnit</code>, to set the parent pointer of the
      <code>TypeDecl</code> objects passed as arguments.
  </li>

  <li> "<code>//#</code> <code>PostCheckCall</code>". <br /> <br />

      Similar to <code>PostMakeCall</code>, this declaration adds the
      following line to the end of automatically-generated
      <code>check</code> methods:

      <blockquote> <pre> postCheck(); </pre> </blockquote>

      As with <code>postMake</code>, no implementation is generated for
      <code>postCheck</code>, allowing the user to provide their own
      checking code.  In our Java front-end, we use this feature to ensure
      that a <code>Name</code> has at least one identifier in it.
  </li>
      
</ul>

<p> In place of these class-wide pragmas, an alternative design would
have been for <code>astgen</code> to change the code it outputs based
on whether a <i>ClassDeclaration</i> contains certain methods.  For
example, instead of the <code>ManualTag</code> pragma,
<code>astgen</code> could generate a <code>getTag</code> method only
for classes that do not contain a manually-defined <code>getTag</code>
method.  In the future, we may change to this design, given such a
change would be backward compatible. </p>

</body>
</html>
