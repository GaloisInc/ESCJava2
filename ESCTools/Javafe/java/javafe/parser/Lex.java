/* Copyright 2000, 2001, Compaq Computer Corporation */

package javafe.parser;

import java.io.IOException;
import java.util.Hashtable;

import javafe.ast.Identifier;
import javafe.ast.PrettyPrint;
import javafe.ast.LexicalPragma;
import javafe.ast.LexicalPragmaVec;
import javafe.ast._SpecialParserInterface;

import javafe.util.Assert;
import javafe.util.ErrorSet;
import javafe.util.CorrelatedReader;
import javafe.util.Location;

/**

 A <TT>Lex</TT> object generates a sequence of Java "input elements"
 (that is, tokens) by converting the sequence of input characters and
 line terminators generated by an underlying
 <code>CorrelatedReader</code>.

 <p> The conversion of input characters occurs according to the lexical
 rules in Chapter Three of the <cite>Java Language
 Specification</cite>.  This specification describes three lexical
 translation steps: the first two steps translate a raw Unicode input
 stream into a "cooked" one in which Unicode escape characters from the
 raw stream have been processed and in which line terminators have been
 identified; the last step translates this cooked stream into a
 sequence of Java "input elements" (comments, white space, identifiers,
 tokens, literals, and punctuation).  <code>Lex</code> objects perform
 the last of these translations steps; the first two are performed by
 an underlying <code>CorrelatedReader</code> that is given to the
 <code>Lex</code> object as the source of input characters.

 <p> Before a newly-created <code>Lex</code> object can be used, its
 <code>restart</code> method must be called giving a
 <code>CorrelatedReader</code> to scan.  At any point, a
 <code>Lex</code> can be restarted on a different underlying reader.

 <p> The <TT>Lex</TT> class is thread safe, but instances of
 <TT>Lex</TT> are not.  That is, two different threads may safely
 access two different instances of <TT>Lex</TT> concurrently, but they
 may not access the same instance of <TT>Lex</TT> concurrently.


 <h3> Simple scanning </h3>

 <p> The <code>getNextToken</code> method of <code>Lex</code> objects
 returns the translated token sequence, one token at a time.  It
 discards white space, and it processes comments as described below.
 In addition, <code>getNextToken</code> fills in the <code>Token</code>
 fields of <code>this</code> (<code>Lex</code> is a subclass of
 <code>Token</code>); for example, <code>ttype</code> gets an integer
 code defining the type of token returned and <code>startingLoc</code>
 gives the location of the first character making up the token.  If the
 token is an identifier, <code>identifierVal</code> indicates which
 one; if the token is a literal, <code>auxVal</code> gives its value.

 <p> <code>Lex</code> objects report errors by calling both the
 <code>fatal</code> and <code>error</code> methods of
 <code>ErrorSet</code>.  The fatal errors are unexpected characters,
 unterminated comments and string and character literals, and IO errors
 in the underlying input stream.  Recoverable errors are overflows in
 literals (including overflows in octal escape sequences), non-octal
 digits in integer literals, the string <code>0x</code> (interpreted as
 a malformed integer literal), missing digits in a floating-point
 exponent, bad escape sequences in character and string literals,
 character literals containing no or multiple characters, and the
 character literal <code>'''</code> (interpreted as <code>'\''</code>).


 <h3> Lookahead </h3>

 <code>Lex</code> objects allow their clients to peek ahead into the
 token stream by calling <code>lookahead</code>.  This method returns
 the token code for the future token, but it does not affect the
 <code>Token</code> fields of <code>this</code>.

 <p> If a call to <code>lookahead</code> needs to look past the set of
 tokens already scanned, and those tokens have errors, then the errors
 are reported immediately.


 <h3> Extensibility: Keywords, punctuation </h3>

 <p> A keyword is a Java identifier with a special token code.
 Ordinarily, identifiers are associated with the code
 <code>TagConstants.IDENT</code>.  Keywords, while matching the lexical
 grammar of identifiers, are associated with different codes.  In fact,
 each keyword is typically associated with its own code.

 <p> The set of identifiers that a <code>Lex</code> object recognizes
 as keywords is extensible.  A keyword is added to a <code>Lex</code>
 object by calling the <code>addKeyword</code> method.  As a
 convenience, a boolean given to the <code>Lex</code> constructor
 indicates whether a newly-constructed <code>Lex</code> object should
 automatically have all Java keywords added to it.

 <p> A punctuation string is a string of punctuation characters
 recognized by a <code>Lex</code> object to be a token.  (Punctuation
 characters are non-alphanumeric ASCII characters whose ASCII codes are
 between 33 ('!')  and 126 ('~') inclusive.)  As with keywords, the set
 of punctuation strings recognized by a <code>Lex</code> object is
 extensible.  A punctuation string is added to a <code>Lex</code>
 object by calling the <code>addPunctuation</code> method.  A boolean
 given to the <code>Lex</code> constructor indicates whether a
 newly-constructed <code>Lex</code> object should automatically have
 all Java punctuation strings added to it.


 <h3> Extensibility: comments and pragmas </h3>

 <p> The handling of comments is special in two ways: the punctuation
 strings that start comments is extensible, the text of comments can be
 parsed for pragmas.

 <h5> Comment recognition </h5>

 <p> Ordinarily, keywords and punctuation strings are mapped to token
 codes that are returned by calls to <code>getNextToken</code>.
 However, two token codes are treated specially:
 <code>TagConstants.C_COMMENT</code> and <code>TagConstants.EOL_COMMENT</code>.
 These codes are used to indicate the start of C-like comments
 (<code>/*...*</code><code>/</code>) and end-of-line comments
 (<code>//...</code>), respectively.  When a keyword or punctuation
 string is mapped to these codes, it is handled like a comment
 initiator rather than a regular token.

 <p> For all newly-created <code>Lex</code> objects, <code>/*</code> is
 mapped to <code>TagConstants.C_COMMENT</code> and <code>//</code> is mapped
 to <code>TagConstants.EOL_COMMENT</code>.  Other punctuation strings can be
 made comment initiators by mapping them to comment-initiating codes.
 This is more useful for <code>TagConstants.EOL_COMMENT</code> than for
 <code>TagConstants.C_COMMENT</code>, since the string
 <code>*</code><code>/</code> is hard-wired as the terminator of C-like
 comments.

 <h5> Pragma parsing </h5>

 <code>Lex</code> objects are designed to support annotation of Java
 programs through pragmas.  A <a href = "../pragma-handling.html">
 separate document </a> describes our overall aproach to pragmas.  In
 brief, our front-end supports two kinds of pragmas: control pragmas
 that can appear anywhere in an input file and are collected in a list
 apart from the parse tree, and syntax pragmas that can only appear in
 certain grammatical contexts and become part of the parse tree.
 Pragmas always appear in Java comments, at most one pragma per
 comment.  These comments must have one of the following forms:

 <menu>
 <li> <code>/*</code><i>tag</i> <i>white-space</i> <i>pragma-text</i><code>*</code><code>/</code>
 <li> <code>//</code><i>tag</i> <i>white-space-minus-EOL</i> <i>pragma-text</i> <i>EOL</code>
 </menu>

 <p> When a <code>Lex</code> object is created, it can optionally be
 associated with a <code>PragmaParser</code> object.  If a
 <code>Lex</code> object has no <code>PragmaParser</code>, it discards
 all comments.  Otherwise, the <code>Lex</code> object passes the first
 character of the comment (or -1 if the comment is empty) to the
 <code>checkTag</code> method of the <code>PragmaParser</code> object,
 which returns <code>false</code> if the comment definitely does not
 contain any pragmas.  If the comment may contain pragmas, the
 <code>Lex</code> object bundles the text between the delimiters of a
 comment into a <code>CorrelatedReader</code> which it passes to the
 <code>restart</code> method of its <code>PragmaParser</code>.  (This
 text excludes both the opening <code>/*</code> or <code>//</code> and
 the closing <code>*</code><code>/</code> or line terminator.)

 <p> The <code>Lex</code> object then calls <code>getNextPragma</code>
 to read the pragmas out of the comment one at a time.  The
 <code>Lex</code> object does this in a lazy manner; that is, it reads
 a pragma, returns it to the parser, and waits until the parser calls
 for the next token before it attempts to read another pragma.  The
 <code>getNextPragma</code> method returns a boolean, returning
 <code>false</code> if there are no more pragmas to be parsed.  The
 <code>getNextPragma</code> method takes a <code>Token</code> as an
 argument, storing information about the pragma parsed into this
 argument.

 <p> When <code>PragmaParser.getNextPragma</code> returns a
 <code>LexicalPragma</code>, the <code>Lex</code> object puts it in an
 internal list rather than returning it to the parser.  The list of
 collected lexical pragmas can be retrieved by calling
 <code>getLexicalPragmas</code>.

 @see javafe.util.CorrelatedReader
 @see javafe.parser.TagConstants
 @see javafe.parser.Token
 @see javafe.parser.PragmaParser

 */

public class Lex extends Token
{
    //// Underlying input stream

    /**
     * Current state of input stream underlying the scanner minus the
     * first character.  See <code>m_nextchr</code>. <p>
     *
     * This is null iff we are closed.
     */

    /*@ spec_public @*/ protected CorrelatedReader m_in = null;

    /** Each call to <code>getNextToken</code> reads ahead one character
     and leaves the result in <code>m_nextchr</code>.  In other words,
     between calls to <code>getNextToken</code>, the stream of
     characters yet-to-scanned consists of the character in
     <code>m_nextchr</code> followed by the characters remaining in
     <code>m_in</code>. */

    protected int m_nextchr;


    //// Buffer used to hold the actual char's making up a token.

    // The exact characters making up a token are copied into this array
    // for all tokens.  Although in some cases this isn't needed (e.g.,
    // for string literals), we do it anyway in case someday we want to
    // export that ability of getting a token's exact text rather than
    // its interpretation, esp. in the case of literals.

    /** The characters that constitute the current token.  Only the
     first <TT>textlen</TT> characters are part of the current token;
     the actual length of <TT>text</TT> may be bigger.  The lexer may
     occasionally need to resize <TT>text</TT>, so the same array might
     not be used throughout the lifetime of the lexer.  */

    //@ invariant text != null;
    //@ invariant text.length > 4;
    protected char[] text = new char[64]; // Invariant: text.length > 4
    // 64 should be large enough that overflows won't happen for most inputs

    /** The number of characters in the current token.  The "current
     token" is the one parsed by the previous call to
     <TT>getNextToken</TT> (there is no "current token" between
     creation of a lexer and the first call to getNextToken).  */

    //@ invariant 0 <= textlen &&  textlen <= text.length;
    protected int textlen = 0;

    /** Append 'c' to <CODE>text</CODE>, expanding if necessary. */
    //@ modifies text, textlen;
    //@ ensures textlen == \old(textlen)+1;
    protected void append(int c) {
        try {
            text[textlen] = (char)c;		//@ nowarn IndexTooBig;  // caught
        } catch (ArrayIndexOutOfBoundsException e) {
            //@ assume textlen>=text.length;
            char[] newtext = new char[textlen + 128];
            System.arraycopy(text, 0, newtext, 0, textlen);
            text = newtext;
            text[textlen] = (char)c;
        }
        textlen++;
    }


    //// Instance variables for token queue and pragma parsing

    protected final TokenQueue lookaheadq = new TokenQueue();

    public /*@ non_null @*/ LexicalPragmaVec lexicalPragmas;

    //@ invariant inPragma ==> pragmaParser != null;
    protected PragmaParser pragmaParser;
    protected boolean inPragma;


    //// Constructors

    /**
     * Creates a lexical analyzer that will tokenize the characters
     * read from an underlying <code>CorrelatedReader</code>.  Before
     * the newly-created scanner can be used, its <code>restart</code>
     * method must be called on a <code>CorrelatedReader</code>.  The
     * <code>pragmaParser</code> object is used to parse pragmas out
     * of comments; if it is <code>null</code>, all comments are
     * discarded.  The <code>isJava</code> flag controls the initial
     * set of keywords and punctuation strings; if <code>true</code>,
     * the new scanner will recognize Java's keywords and punctuation
     * strings, if <code>false</code>, the new scanner will recognize
     * <em>no</em> keywords or punctuation strings.  If
     * <code>isJava</code> is true, the token codes used for the
     * Java's keywords and punctuation strings are those defined by
     * the <code>TagConstants</code> class. 
     */

    //@ ensures m_in==null;
    public Lex(PragmaParser pragmaParser, boolean isJava) {
	this.pragmaParser = pragmaParser;
	lexicalPragmas = LexicalPragmaVec.make();
	
	inPragma = false;
	if (isJava) {
	    addJavaKeywords();
	    addJavaPunctuation();
	} else {
	    addPunctuation("/*", TagConstants.C_COMMENT);
	    addPunctuation("//", TagConstants.EOL_COMMENT);
	}
    }


    /** Start scaning a new <code>CorrelatedReader</code>.  First closes
     the old <code>CorrelatedReader</code> associated with
     <code>this</code> (if there was one), and clears out the set of
     collected lexical pragms.  In addition to (re)-seting the
     underlying input stream, this method scans the first token,
     returning the token kind of the result and setting the
     <code>Token</code> fields of <code>this</code>.  If a
     <code>CorrelatedReader</code> is already underlying
     <code>this</code>, it is closed before the new reader is
     installed.  Note: The argument <code>in</code> is "captured" in
     the internal, private state of the resulting scanner and should
     not be used by other parts of the program. */
    //@ public normal_behavior
    //@ modifies m_in, ttype, auxVal, identifierVal, lexicalPragmas;
    //@ ensures m_in != null;
    //@ also
    //@ protected normal_behavior
    //@ modifies m_nextchr;
    public int restart(/*@ non_null @*/ CorrelatedReader in) {
	close();
	try {
	    m_in = in;
	    m_nextchr = m_in.read();
	} catch (IOException e) {
	    ErrorSet.fatal(m_in.getLocation(), e.toString());
	    return TagConstants.NULL; // Dummy
	}
	return getNextToken();
    }


    /** Closes the <code>CorrelatedReader</code> underlying
     <code>this</code>, clears the set of collected lexical pragmas,
     and in other ways frees up resources associated with
     <code>this</code>.  After being closed, a <code>Lex</code> object
     can be restarted by calling <code>restart</code>.  (An IO
     exception raised by closing the underlying input stream will be
     converted into a <code>javafe.util.FatalError</code> runtime
     exception.) */
    //@ public normal_behavior
    //@ modifies m_in, lexicalPragmas;
    //@ ensures m_in==null;
    //@ also 
    //@ protected normal_behavior
    //@ modifies inPragma;
    public void close() {
        if (m_in != null) {
	    m_in.close();
	}
	m_in = null;
	lookaheadq.clear();
	if (pragmaParser != null) {
	    pragmaParser.close();
	    lexicalPragmas = LexicalPragmaVec.make();
	}
	inPragma = false;
    }



    //// Public members for scanning

    public void replaceLookaheadToken(int k, Token t) {
	lookaheadq.setElementAt(k,t);
    }

    /** Scans next token from input stream.  Returns the code of the
     next token in the token stream and fills in the <code>Token</code>
     fields of <CODE>this</CODE>.  Note that the
     <code>startingLoc</code> and <code>endingLoc</code> fields of
     <code>this</code> are not accurate for the end-of-file token. */

    //@ public normal_behavior
    //@ requires m_in != null;
    //@ modifies ttype, auxVal, identifierVal;
    //@ also 
    //@ protected normal_behavior
    //@ modifies inPragma, m_nextchr;
    public int getNextToken() {
        if (lookaheadq.notempty) {
            lookaheadq.dequeue(this);
            return ttype;
        }

        for(;;) {
            if (inPragma)
                if (! pragmaParser.getNextPragma(this)) {
                    inPragma = false;
                } else if (ttype != TagConstants.LEXICALPRAGMA) {
                    return ttype;
                } else {
                    lexicalPragmas.addElement((LexicalPragma)this.auxVal);
                    continue;
                }

            int t = scanToken();
            if (t != TagConstants.C_COMMENT &&
                t != TagConstants.EOL_COMMENT) {
                return t;
            }
            else { 
		scanComment(t);
	    }
        }
    }

    /** Returns token type of the <TT>k</TT>th future token, where k=0
     is the current token.  If <code>k</code> is past the end of the
     token stream, <code>TagConstants.EOF</code> is returned. */

    //@ requires k>=0;
    //@ requires m_in != null;
    public int lookahead(int k) {
        if (k == 0) return ttype;
        int lookahead_count = lookaheadq.size();

        if (lookahead_count < k) { // Need to add more tokens in lookahead buffer
            this.copyInto(savedState);
            try {
                for(int deficit = k - lookahead_count; 0 < deficit; deficit--) {
                    for(;;) {
                        if (inPragma)
                            if (! pragmaParser.getNextPragma(this))
                                inPragma = false;
                            else if (ttype != TagConstants.LEXICALPRAGMA)
                                break;
                            else {
                                lexicalPragmas.addElement((LexicalPragma)this.auxVal);
                                continue;
                            }

                        int t = scanToken();
                        if (t != TagConstants.C_COMMENT
                            && t != TagConstants.EOL_COMMENT)
                            break;
                        else scanComment(t);
                    }
                    lookaheadq.enqueue(this);
                }
            } finally { 
                savedState.copyInto(this);
                savedState.clear();
            }
        }
        return lookaheadq.elementAt(k-1).ttype;
    }
    //@ invariant savedState != null;
    protected Token savedState = new Token();

    public Token lookaheadToken(int k) {
	if (k==0) return this;
	lookahead(k);
	return lookaheadq.elementAt(k-1);
    }

    /** Returns the set of lexical pragmas collected.  It also clears
     the set of lexical pragmas so that the next call will not include
     them.  (If this lexer has no <code>PragmaParser</code>, then an
     empty vector is returned.) */

    //@ ensures \result != null;
    public LexicalPragmaVec getLexicalPragmas() {
        return lexicalPragmas.copy();
    }

    /**
     * Remove the first LexicalPragma from our set of lexical pragmas
     * collected, returning it or null if our set is empty.
     */
    public LexicalPragma popLexicalPragma() {
	if (lexicalPragmas.size()>0)
	    return lexicalPragmas.pop();

	return null;
    }


    //// Internal scanning routines

    /** Returns the code of the next token in the token stream, updating
     the <code>Token</code> fields of <code>this</code> along the way.
     Advances underlying stream to the character just past the last
     character of the token returned, and changes the internal buffer
     used by <code>getTokenText</code> to contain the text of this
     token.

     <p> In most cases, this method leaves <code>m_nextchr</code>
     holding the character just after the token scanned and
     <code>m_in</code> pointing to the character after that.  However,
     if <code>TagConstants.C_COMMENT</code> or
     <code>TagConstants.EOL_COMMENT</code> is returned, it leaves
     <code>m_in</code> pointing to the character just after the token
     scanned and <code>m_nextchr</code> undefined.  This aids in pragma
     processing. */

    //@ requires m_in != null;
    private int scanToken() {
        // The following "assert" is obvious from the program text, because
        // the two arrays are non-null and their types do not coincide in any
        // other way.  ESC/Java can figure this out, too, so therefore the
        // following "assert" produces no warning.  This property is also
        // cruicial to figuring out that the updates to "text[...]" in this
        // body do not destroy the invariants declared in TagConstants about
        // "punctuationCodes[...]".  However, oddly enough, without being
        // prompted to first prove this property, ESC/Java isn't able to
        // prove the necessary thing about the updates to "text[...]".
        //@ assert (Object)text != (Object)TagConstants.punctuationCodes;

        try {
            int nextchr = m_nextchr;
            textlen = 0;

            while (Character.isWhitespace((char)nextchr)) {
                m_in.mark();
                nextchr = m_in.read();
            }
            startingLoc = m_in.getLocation();

            // Inline the identifier-handling code because it's the common case
            if (Character.isJavaIdentifierStart((char)nextchr)) { 
                int h = 0;
                do {
                    try {
                        text[textlen] = (char)nextchr;
                        textlen++;
                    } catch (ArrayIndexOutOfBoundsException e) { this.append(nextchr);}
                    h = _SpecialParserInterface.HC*h + nextchr;
                    nextchr = m_in.read();
                } while (Character.isJavaIdentifierPart((char)nextchr));
                m_nextchr = nextchr;
                auxVal = null;
                identifierVal = _SpecialParserInterface.intern(text, textlen, h);
                if (onlyjavakeywords) {
                    ttype = _SpecialParserInterface.getTokenType(identifierVal);
                } else if (keywords != null) {
                    Object val = keywords.get(identifierVal);
                    if (val != null) {
                        ttype = ((Integer)val).intValue();
                        // From the Unenforceable invariant on keyword:
                        /*@ assume ttype != TagConstants.BOOLEANLIT &&
                         ttype != TagConstants.INTLIT &&
                         ttype != TagConstants.LONGLIT &&
                         ttype != TagConstants.FLOATLIT &&
                         ttype != TagConstants.DOUBLELIT &&
                         ttype != TagConstants.STRINGLIT &&
                         ttype != TagConstants.CHARLIT &&
                         ttype != TagConstants.LEXICALPRAGMA &&
                         ttype != TagConstants.MODIFIERPRAGMA &&
                         ttype != TagConstants.STMTPRAGMA &&
                         ttype != TagConstants.TYPEDECLELEMPRAGMA &&
                         ttype != TagConstants.TYPEMODIFIERPRAGMA;  */
                    } else if (javakeywords)
                        ttype = _SpecialParserInterface.getTokenType(identifierVal);
                    else ttype = TagConstants.IDENT;
                } else ttype = TagConstants.IDENT;
                return ttype;
            }
            ttype = Token.CLEAR;      // keep Token invariants happy
            identifierVal = null;

            if (Character.isDigit((char)nextchr))
                return scanNumber(nextchr);
            if (nextchr == '\'' || nextchr == '\"')
                return scanCharOrString(nextchr);

            scanJavaExtensions(nextchr);
            if (ttype != TagConstants.NULL) return ttype;

            scanPunctuation(nextchr);
            if (ttype != TagConstants.NULL) return ttype;

            if (nextchr == -1) {
                m_nextchr = nextchr;
                return ttype = TagConstants.EOF;
            }

            String s = PrettyPrint.toCanonicalString(TagConstants.CHARLIT, 
                                                     new Integer(nextchr));
            ErrorSet.fatal(m_in.getLocation(), "Unexpected character " + s);

            //@ unreachable;
            return ttype;

        } catch (IOException e) {
            ErrorSet.fatal(m_in.getLocation(), e.toString());
            return TagConstants.NULL; // Dummy
        }
    }


    /** Handle a comment.  m_in points to the character just after the
     "//" or "/*".  The mark is set at the last character read.  */

    //@ requires m_in != null;
    //@ requires !inPragma;
    //@ modifies inPragma, m_nextchr;
    private void scanComment(int commentKind) {
	try {
	    m_in.mark();
	    int firstchr = m_in.read();
	    // System.out.println("scanComment: firstchr = '"+(char)firstchr+"'");

	    /* Decide if this comment contains a pragma. */

	    if (pragmaParser != null) {
		if (pragmaParser.checkTag(firstchr)) {
		    Assert.notFalse(! inPragma);
		    inPragma = true;
		}
	    }

	    // Scan the comment
	    boolean nonEmptyComment = false; // For empty multi-line comment
      
	    int locStartComment = m_in.getLocation();
	    int nextchr = firstchr;
	    if (commentKind == TagConstants.EOL_COMMENT) {
		nonEmptyComment = true;
		while (nextchr != -1 && nextchr != '\n')
		    nextchr = m_in.read();
	    } else {
		for(;;) {
		    if (nextchr == -1) {
			ErrorSet.fatal(
			   startingLoc,
			   "Unterminated or improperly nested comment or pragma");
		    }
		    int oldchr = nextchr;
		    nextchr = m_in.read();
		    if (oldchr == '*' && nextchr == '/') break;
		    nonEmptyComment = true;
		}
	    }

	    // If the comment contains a pragma, set up the pragma parser
	    if (inPragma) {
		if(nonEmptyComment) {
                    boolean eolComment = commentKind == TagConstants.EOL_COMMENT;
                    int discard = !eolComment ? 2 :
                        nextchr == '\n' ? 1 : 0;
                    CorrelatedReader nu = m_in.createReaderFromMark(discard);
                    pragmaParser.restart(nu, eolComment);
		} else {
		    // Is an empty multi-line comment
		    inPragma = false;
		}
	    }
	    if (!inPragma) {
                m_in.clearMark();
	    }

	    // Clean up and return
	    m_nextchr = m_in.read();
	} catch (IOException e) {
	    m_in.clearMark();
	    ErrorSet.fatal(m_in.getLocation(), "IO error");
	}
    }	//@ nowarn Exception;	// ignore Index... from createReaderFromMark


    // Notes.  The routines below all assume that the input stream to be
    // scanned consist of their input parameter nextchr plus the characters
    // in m_in; that is, the nextchr argument is playing the role that
    // m_nextchr plays between calls to getNextToken.  These routines also
    // assume that textlen = 0 and startingLoc has already been filled in
    // with the location of the character in nextchr.
    // Unless otherwise noted, the routines below fill in all fields except
    // startingLoc, that is, they fill in m_nextchr, text & textlen,
    // plus the Token fields ttype, endingLoc, and auxVal.
    // Errors are handled internally by these routines.  Either the
    // error is fatal, or the error is recoverable and recovery is done
    // by the routines.

    /** Scan a character or string constant. */

    //@ requires m_in != null;
    private int scanCharOrString(int nextchr) {
        try {
            int endquote = nextchr;
            this.append(endquote);
            boolean chr = (endquote == '\'');
            nextchr = m_in.read();
            stringLitLen = 0;
            for(;;) {
                if (nextchr != '\\' && nextchr != '\n' && nextchr != -1) {
                    // Normal case
                    this.append(nextchr);
                    if (nextchr == endquote) { nextchr = m_in.read(); break; }
                    this.stringLitAppend(nextchr);
                    nextchr = m_in.read();
                    continue;
                }

                if (nextchr == -1 || nextchr == '\n') {
                    if (chr) ErrorSet.fatal(startingLoc,
                                            "Unterminated character literal");
                    else ErrorSet.fatal(startingLoc, "Unterminated string literal");
                    break;
                }

                // At this point, we know we're at the start of an escape sequence
                this.append(nextchr);
                nextchr = m_in.read();
                if ('0' <= nextchr && nextchr <= '7') { // Octal sequence
                    int firstdigit = nextchr - '0';
                    int result = firstdigit;
                    this.append(nextchr);
                    nextchr = m_in.read();
                    if ('0' <= nextchr && nextchr <= '7') {
                        this.append(nextchr); result = 8*result + (nextchr - '0');
                        nextchr = m_in.read();
                        if (0 <= firstdigit && firstdigit <= 3
                            && '0' <= nextchr && nextchr <= '7') {
                            this.append(nextchr); result = 8*result + (nextchr - '0');
                            nextchr = m_in.read();
                        }
                    }
                    if (255 < result) {
                        ErrorSet.error(m_in.getLocation(),
                                       "Octal escape sequence overflow");
                        this.stringLitAppend('\0');
                    } else this.stringLitAppend(result);
                } else {
                    if (nextchr == 'b') this.stringLitAppend('\b');
                    else if (nextchr == 't')  this.stringLitAppend('\t');
                    else if (nextchr == 'n')  this.stringLitAppend('\n');
                    else if (nextchr == 'f')  this.stringLitAppend('\f');
                    else if (nextchr == 'r')  this.stringLitAppend('\r');
                    else if (nextchr == '\"') this.stringLitAppend('\"');
                    else if (nextchr == '\'') this.stringLitAppend('\'');
                    else if (nextchr == '\\') this.stringLitAppend('\\');
                    else {
                        ErrorSet.error(startingLoc, "Bad escape sequence");
                        continue;
                    }
                    this.append(nextchr);
                    nextchr = m_in.read();
                }
            }

            if (chr) {
                if (1 < stringLitLen)
                    ErrorSet.error(startingLoc,
                                   "Character literal with multiple characters.");
                else if (stringLitLen == 0)
                    if (nextchr == '\'') {
                        this.append(nextchr);
                        nextchr = m_in.read();
                        stringLit[0] = '\'';
                        ErrorSet.error(startingLoc, "Unquoted \' in character literal.");
                    } else {
                        stringLit[0] = '\0';
                        ErrorSet.error(startingLoc, "Empty character literal.");
                    }
                ttype = TagConstants.CHARLIT;
                auxVal = new Integer(stringLit[0]);  // CF
            } else {
                ttype = TagConstants.STRINGLIT;
                auxVal = String.valueOf(stringLit, 0, stringLitLen);
            }
            m_nextchr = nextchr;
            endingLoc = m_in.getLocation();
            return ttype;
        } catch (IOException e) {
            ErrorSet.fatal(m_in.getLocation(), e.toString());
            return TagConstants.NULL; // Dummy
        }
    }


    /** Scans a numeric literal.  Requires <code>nextchr</code> is a
     decimal digit.  Reads a numeric literal into <code>text</code>.
     Depending on the kind of literal found, will return one of
     <code>TagConstants.INTLIT</code>,
     <code>TagConstants.LONGLIT</code>,
     <code>TagConstants.FLOATLIT</code> or
     <code>TagConstants.DOUBLELIT</code>.  If an error is detected, a
     message is sent to <code>ErrorSet</code>, <code>m_in</code> is
     advanced to what appears to be the end of the erroneous token, and
     a legal literal is left in <code>text</code>. */

    //@ requires m_in != null;
    //@ modifies endingLoc, ttype, auxVal, m_nextchr, text, textlen;
    //@ ensures \result==ttype;
    /*@ ensures \result==TagConstants.INTLIT || \result==TagConstants.LONGLIT ||
     \result==TagConstants.FLOATLIT || \result==TagConstants.DOUBLELIT ||
     \result==TagConstants.MAX_INT_PLUS_ONE ||
     \result==TagConstants.MAX_LONG_PLUS_ONE ; */
    private int scanNumber(int nextchr) {
        try {
            // Get the first chunk of digits
            int tentativeResult = 0;
            while (Character.isDigit((char)nextchr)) {
                this.append(nextchr);
                tentativeResult = 10*tentativeResult + (nextchr - '0');
                nextchr = m_in.read();
            }
            //@ assume textlen>0; // because know nextchar was initially a digit...

            // Handle floating point literals in another subtroutine
            if (nextchr == '.') {
		m_in.mark();
		int nextnextchr = m_in.read();
		if (nextnextchr == '.') {
		    // Two . in a row - cannot be a double so
		    // back up 
		    m_in.reset();
		    // fall through and let the text so far be handled as
		    // a integer literal
		} else {
		    this.append(nextchr);
		    return finishFloatingPointLiteral(nextnextchr);
		}
            } else if (nextchr == 'e' || nextchr == 'E'
                       || nextchr == 'F' || nextchr == 'f'
                       || nextchr == 'd' || nextchr == 'D')
                return finishFloatingPointLiteral(nextchr);

            long result = 0;
            if (text[0] != '0' || (textlen == 1 && nextchr != 'x' && nextchr != 'X'))
                // Handle base-ten literal
                if (textlen <= 9) result = tentativeResult;
                else {
                    // Parse as negative value to avoid problems w/ -Long.MIN_VALUE
                    long mullimit = Long.MIN_VALUE / 10;
                    for(int i = 0; i < textlen; i++) {
                        int d = text[i] - '0';
                        long r2 = 10*result;
                        if (result < mullimit || r2 < Long.MIN_VALUE + d) {
                            ErrorSet.error(startingLoc, "Integer literal overflow");
                            result = 0;
                            break;
                        } else result = r2 - d;
                    }
                    if (nextchr == 'L' || nextchr == 'l') {
                        if (result == Long.MIN_VALUE) {
                            this.append(nextchr);
                            m_nextchr = m_in.read();
                            endingLoc = m_in.getLocation();
                            auxVal = null;
                            return ttype = TagConstants.MAX_LONG_PLUS_ONE;
                        }
                    } else if (result == Integer.MIN_VALUE) {
                        m_nextchr = nextchr;
                        endingLoc = m_in.getLocation();
                        auxVal = null;
                        return ttype = TagConstants.MAX_INT_PLUS_ONE;
                    }
                    result = -result;
                }

            else if (nextchr != 'x' && nextchr != 'X') {
                // Handle octal literal
                for(int i = 1; i < textlen; i++) {
                    int d = text[i] - '0';
                    if (0 <= d && d <= 7) {
                        if ((result >>> 61) != 0) {
                            ErrorSet.error(startingLoc, "Integer literal overflow");
                            result = 0;
                            break;
                        }
                        result = (result << 3) + d;
                    } else {
                        ErrorSet.error(startingLoc,
                                       "Non-octal digit found in octal literal.");
                        result = 0;
                        break;
                    }
                }

            } else {
                // Handle hex literal
                this.append(nextchr);
                boolean overflow = false;
                for(nextchr = m_in.read(); ; nextchr = m_in.read()) {
                    int d = Character.digit((char)nextchr, 16);
                    if (d == -1) break;
                    this.append(nextchr);
                    if (! overflow)
                        if ((result >>> 60) != 0) overflow = true;
                        else result = (result << 4) + d;
                }
                if (textlen <= 2)
                    ErrorSet.error(startingLoc, "Too few digits in a hex literal.");
                else if (overflow) {
                    ErrorSet.error(startingLoc, "Integer literal overflow");
                    result = 0;
                }
            }

            if (nextchr == 'L' || nextchr == 'l') {
                this.append(nextchr);
                m_nextchr = m_in.read();
                endingLoc = m_in.getLocation();
                auxVal = new Long(result);
                return ttype = TagConstants.LONGLIT;
            }
            if ((result & 0xffffffff00000000L) != 0) {
                ErrorSet.error(startingLoc, "Integer literal overflow");
                result = 0;
            }
            m_nextchr = nextchr;
            endingLoc = m_in.getLocation();
            auxVal = new Integer((int)result);
            return ttype = TagConstants.INTLIT;
        } catch (IOException e) {
            ErrorSet.fatal(m_in.getLocation(), e.toString());
            return TagConstants.NULL; // Dummy
        }
    }

    /** Finishes scanning a floating-point literal.

     <p> Requires: <code>text</code> contains a possibly empty sequence
     of decimal digits followed by an optional <code>'.'</code>; also,
     <code>text</code> cannot be empty.  Further, let <i>s</i> be the
     sequence of characters consisting of the characters in
     <code>text</code> followed by <code>nextchr</code> followed by the
     characters in <code>m_in</code>.  This routine requires that a
     prefix of <i>s</i> match the syntax of floating-point literals as
     defined by the Java language specification.

     <p> Ensures: Scans the floating-point literal in <i>s</i>.
     Depending on the type of the literal, returns
     <code>TagConstants.FLOATLIT</code> or
     <code>TagConstants.DOUBLELIT</code> and sets sets
     <code>auxVal</code> to either a <code>Float</code> or
     <code>Double</code>.  If an error is encountered, a message is
     sent to <code>ErorrSet</code> and recovery is performed. */

    //@ requires m_in != null;
    //@ requires textlen>0;
    //@ modifies ttype, auxVal, m_nextchr, endingLoc, text, textlen;
    //@ ensures \result==ttype;
    //@ ensures \result==TagConstants.FLOATLIT || \result==TagConstants.DOUBLELIT;
    private int finishFloatingPointLiteral(int nextchr) {
        try {
            boolean error = false;
            boolean zeroMantissa = true; // Used for underflow detection

            // First, see if there are any non-zero digits in the non-fractional
            // part of the mantissa
            for(int i = 0, len = textlen - (text[textlen-1] == '.' ? 1 : 0);
                i < len; i++)
                if (text[i] != '0') { zeroMantissa = false; break; }

            // If there's a fractional part, scan it in
            while (Character.isDigit((char)nextchr)) {
                if (nextchr != '0') zeroMantissa = false;
                this.append(nextchr);
                nextchr = m_in.read();		// throws IOException
            }

            // If there's an exponent, scan it in
            if (nextchr == 'e' || nextchr == 'E') {
                this.append(nextchr);
                nextchr = m_in.read();
                if (nextchr == '+' || nextchr == '-') {
                    this.append(nextchr);
                    nextchr = m_in.read();
                }
                while (Character.isDigit((char)nextchr)) {
                    this.append(nextchr);
                    nextchr = m_in.read();
                }
                if (! Character.isDigit(text[textlen-1])) {
                    ErrorSet.error(startingLoc, ("Digits required in exponent part"
                                                 + " of floating-point literal."));
                    error = true;
                }
            }

            String s = (error ? "1.0" : String.valueOf(this.text, 0, textlen));

            // Assert: s has one of the following forms:
            //   [0-9]+ (. [0-9]*)? (e [+-] [0-9]+)?
            //   . [0-9]+ (e [+-] [0-9]+)?
            // Also, zeroMantissa is true iff all digits in the mantissa are zero
            // (Todo: examine code more closely to see if this is really true.)

            boolean f = (nextchr == 'F' || nextchr == 'f');
            if (f || nextchr == 'D' || nextchr == 'd') {
                this.append(nextchr);
                m_nextchr = m_in.read();
            } else m_nextchr = nextchr;
            endingLoc = m_in.getLocation();

            if (f) {
                Float result = Float.valueOf(s);  // !throw NumberFormatException
                auxVal = result;
                if (result.isInfinite())
                    ErrorSet.error(startingLoc, "Floating-point literal overflow");
                else if (! zeroMantissa && result.floatValue() == 0.0)
                    ErrorSet.error(startingLoc, "Floating-point literal underflow");
            } else {
                Double result = Double.valueOf(s);  // !throw NumberFormatException
                auxVal = result;
                if (result.isInfinite())
                    ErrorSet.error(startingLoc, "Floating-point literal overflow");
                else if (! zeroMantissa && result.doubleValue() == 0.0D)
                    ErrorSet.error(startingLoc, "Floating-point literal underflow");
            }	
            return ttype = (f ? TagConstants.FLOATLIT : TagConstants.DOUBLELIT);
        } catch (IOException e) {
            ErrorSet.fatal(m_in.getLocation(), e.toString());
            return TagConstants.NULL; // Dummy
        }
    }   //@ nowarn Exception;	// NumberFormatException won't be thrown

    /** Scans a punctuation string <em>or</em> a floating-point
     number.  If input doesn't match either a floating-point number or
     any punctuation, returns <code>TagConstants.NULL</code>.  Assumes
     <code>startingLoc</code> already filled in.

     <p>The routine may change the mark arbitrarily.

     <p> This method leaves <code>m_in</code> in a different state than
     the previous ones do.  Ordinarily, <code>scanXXX</code> routines
     return with <code>m_nextchr</code> holding the character just
     after the token scanned and <code>m_in</code> pointing to the
     character after that.  <code>scanPunctuation</code> does too, but
     only when the value returned is <em>not</em>
     <code>TagConstants.C_COMMENT</code> or
     <code>TagConstants.EOL_COMMENT</code>; in those two cases, it
     returns with <code>m_in</code> pointing to the character just
     after the token scanned and <code>m_nextchr</code> undefined.
     This aids in pragma processing.  Also, if <code>TagConstants.NULL</code>
     is returned, then <code>m_nextchr</code> is undefined and
     <code>m_in</code> is where it was on entry.
     */

    //@ requires m_in != null;
    //@ modifies ttype, auxVal, m_nextchr, textlen, endingLoc, text;
    //@ modifies m_in.marked;
    //@ ensures \result==ttype;
    private int scanPunctuation(int nextchr) {
        try {
            boolean possibleFloatingPointNumber = (nextchr == '.');
            text[0] = (char)nextchr;
            textlen = 1;
            PunctuationPrefixTree prefix = punctuationTable;
            PunctuationPrefixTree lastPunctuation = prefix;
            int lastPunctuationLength = 0;
            m_in.mark();

            // The following loop, which has been unrolled once so the
            // first iteration can be handled specially, has the invariant:
            //   prefix == null || depth(prefix) == textlen-1
            //   nextchr == text[textlen-1]
            //   (nextchr_0 + m_in_0) == (text[0,textlen) + m_in)
            //   lastPunctuation != null && lastPunctuation is last valid punct seen
            //   lastPunctuationLength == depth(lastPunctuation)
            //   (nextchr_0+m_in_0)==(text[0,lastPunctuationLength]+m_in.resetedtext)
            // Stating part of this invariant graphically:
            //               l      t       l = lastPunctuationLength; t = textlen
            //    text:   abcdefghij
            // nextchr_0+
            //    m_in_0: abcdefghijklmnop
            //               r     nm       r = resetted text, n = nextchr, m = m_in

            int index = nextchr - '!';
            if (index < 0 || PunctuationPrefixTree.CHILDLEN <= index)
                prefix = null;
            else
                prefix = prefix.children[nextchr - '!'];
            if (prefix != null && prefix.code != TagConstants.NULL) {
                lastPunctuation = prefix;
                lastPunctuationLength = textlen;
                m_in.mark();
            }
            nextchr = m_in.read();
            if (possibleFloatingPointNumber && Character.isDigit((char)nextchr)) {
                // Deal with special case of floating-point numbers
                m_in.clearMark();
                return finishFloatingPointLiteral(nextchr);
            }
            this.append(nextchr);
            while (prefix != null) {
                index = nextchr - '!';
                if (index < 0 || PunctuationPrefixTree.CHILDLEN <= index)
                    prefix = null;
                else
                    prefix = prefix.children[nextchr - '!'];
                if (prefix != null && prefix.code != TagConstants.NULL) {
                    lastPunctuation = prefix;
                    lastPunctuationLength = textlen;
                    m_in.mark();
                }
                nextchr = m_in.read();
                this.append(nextchr);
            }
            // End of unrolled loop

            m_in.reset();
            textlen = lastPunctuationLength;
            endingLoc = m_in.getLocation();
            ttype = lastPunctuation.code;
            if (ttype != TagConstants.C_COMMENT &&
                ttype != TagConstants.EOL_COMMENT &&
                ttype != TagConstants.NULL) {
                m_nextchr = m_in.read();
            }
            return ttype;
        } catch (IOException e) {
            ErrorSet.fatal(m_in.getLocation(), e.toString());
            return TagConstants.NULL; // Dummy
        }
    }

    /** Scans a Java extension.  If input doesn't match any Java extension,
     returns <code>TagConstants.NULL</code>.  Assumes <code>startingLoc</code>
     already filled in, and assumes <code>textlen</code> is 0.

     <p>The routine may change the mark arbitrarily.

     <p> If a Java extension is matched, returns with <code>m_nextchr</code>
     holding the character just after the token scanned and <code>m_in</code>
     pointing to the character after that.
     */
    //@ requires m_in != null;
    //@ requires textlen == 0;
    //@ modifies ttype, auxVal, m_nextchr;
    //@ modifies m_in.marked;
    //@ ensures \result==ttype;
    protected int scanJavaExtensions(int nextchr) {
        ttype = TagConstants.NULL;
        return ttype;
    }

    //// Internal char buffer used by string scanner.

    // Having this separate from text allows us to accumulate both the
    // original input in text and the escape-converted input in stringLit

    //@ private invariant stringLit != null;
    //@ private invariant stringLit.length>=64;
    private char[] stringLit = new char[64];

    //@ private invariant stringLitLen>=0;
    private int stringLitLen = 0;

    private void stringLitAppend(int c) {
        try {
            stringLit[stringLitLen] = (char)c;    //@ nowarn IndexTooBig; // caught
        } catch (ArrayIndexOutOfBoundsException e) {
            char[] newstringLit = new char[stringLitLen + 128];
            System.arraycopy(stringLit, 0, newstringLit, 0, stringLitLen);
            stringLit = newstringLit;
            stringLit[stringLitLen] = (char)c;
        }
        stringLitLen++;
    }


    //// The keyword and punctuation tables, plus methods for changing them

    //@ private invariant punctuationTable != null;
    private PunctuationPrefixTree punctuationTable = new PunctuationPrefixTree();

    /**
     * Unenforceable invariant: all tokenTypes in this table do not
     * require a non-null auxVal.  (cf. Token.auxVal).
     */
    //  Old specs from original full JML spec files.  Must be
    //  rewritten for current java.util.Hashtable specs.
    /*  invariant (keywords != null) ==> (keywords.keyType == \type(Identifier) &&
                  keywords.elementType == \type(Integer)); */
    protected Hashtable keywords = null;

    protected boolean javakeywords = false, onlyjavakeywords = false;
    //@ invariant onlyjavakeywords == (javakeywords && keywords == null);

    static {
        // When class initializes, change the <CODE>tokenType</CODE> field
        // of <CODE>Identifier</CODE> instances associated with keywords.
        for(int code = TagConstants.FIRST_KEYWORD;
            code <= TagConstants.LAST_KEYWORD;
            code++) {
            Identifier idn = Identifier.intern(TagConstants.toString(code));
            _SpecialParserInterface.setTokenType(idn, code);
        }
    } 

    /** Add all of Java's keywords to the scanner.  The token codes used
     for these keywords are those defined by the <code>TagConstants</code>
     class.  Requires that none of these keywords have been added
     already. */

    public void addJavaKeywords() {
        javakeywords = true;
        if (keywords != null)
            // New values override existing ones...
            for(int i = TagConstants.FIRST_KEYWORD;
                i <= TagConstants.LAST_KEYWORD;
                i++)
                keywords.remove(Identifier.intern(TagConstants.toString(i)));
        else onlyjavakeywords = true;
    }


    /**
     * Add a keyword to a <code>Lex</code> object with the given code.
     * Requires that <code>newkeyword</code> is a Java identifier and
     * that <code>code</code> is not <code>TagConstants.NULL</code> or
     * a tokenType that requires auxVal to be non-null;
     * (cf. Token.auxVal).
     *
     * Also requires that the keyword hasn't already been added.
     */
    //@ requires code != TagConstants.NULL;
    //@ requires code != TagConstants.BOOLEANLIT;
    //@ requires code != TagConstants.INTLIT;
    //@ requires code != TagConstants.LONGLIT;
    //@ requires code != TagConstants.DOUBLELIT;
    //@ requires code != TagConstants.STRINGLIT;
    //@ requires code != TagConstants.CHARLIT;
    //@ requires code != TagConstants.LEXICALPRAGMA;
    //@ requires code != TagConstants.MODIFIERPRAGMA;
    //@ requires code != TagConstants.STMTPRAGMA;
    //@ requires code != TagConstants.TYPEDECLELEMPRAGMA;
    //@ requires code != TagConstants.TYPEMODIFIERPRAGMA;
    public void addKeyword(/*@ non_null @*/ String newkeyword, int code) {
	Assert.precondition(code != TagConstants.NULL);
	if (keywords == null) {
	    keywords = new Hashtable();
            //  Old specs from original full JML spec files.  Must be
            //  rewritten for current java.util.Hashtable specs.
	    //  set keywords.keyType = \type(Identifier);
	    //  set keywords.elementType = \type(Integer);
	}
	keywords.put(Identifier.intern(newkeyword), new Integer(code));
	onlyjavakeywords = false;
    }



    /** Add all of Java's punctuation strings to the scanner.  The codes
     used for these punctuation strings are the found in the
     <code>TagConstants</code> class.  Requires that none of these
     punctuation strings have been added before. */

    public void addJavaPunctuation() {
        Assert.notFalse(TagConstants.punctuationStrings.length ==
                        TagConstants.punctuationCodes.length);
        for(int i = 0; i < TagConstants.punctuationStrings.length; i++)
            addPunctuation(TagConstants.punctuationStrings[i],
                           TagConstants.punctuationCodes[i]);
    }

    /** Add a punctuation string to a scanner associated with a given
     code.  Requires that the characters in the punctuation string are
     all punctuation characters, that is, non-alphanumeric ASCII
     characters whose codes are between 33 ('!')  and 126 ('~')
     inclusive.  Also requires that the code is not
     <code>TagConstants.NULL</code> and that the punctuation string
     hasn't already been added. */
    //@ requires punctuation != null;
    //@ requires code != TagConstants.NULL;
    //@ requires code != TagConstants.IDENT;
    //@ requires code != TagConstants.BOOLEANLIT;
    //@ requires code != TagConstants.INTLIT;
    //@ requires code != TagConstants.LONGLIT;
    //@ requires code != TagConstants.FLOATLIT;
    //@ requires code != TagConstants.DOUBLELIT;
    //@ requires code != TagConstants.STRINGLIT;
    //@ requires code != TagConstants.CHARLIT;
    //@ requires code != TagConstants.LEXICALPRAGMA;
    //@ requires code != TagConstants.MODIFIERPRAGMA;
    //@ requires code != TagConstants.STMTPRAGMA;
    //@ requires code != TagConstants.TYPEDECLELEMPRAGMA;
    //@ requires code != TagConstants.TYPEMODIFIERPRAGMA;
    public void addPunctuation(String punctuation, int code) {
        Assert.precondition(code != TagConstants.NULL);
        PunctuationPrefixTree prefix = punctuationTable;
        for(int j = 0; j < punctuation.length(); j++) {
            int c = punctuation.charAt(j);
            Assert.precondition(	//@ nowarn Pre;
                                ('!' <= c && c <= '/') || (':' <= c && c <= '@')
                                || ('[' <= c && c <= '`') || ('{' <= c && c <= '~'));
            int index = c - '!';
            PunctuationPrefixTree child = prefix.children[index];
            if (child == null)
                child = prefix.children[index] = new PunctuationPrefixTree();
            prefix = child;
        }
        prefix.code = code;
    }


    //// Diagnostic routines

    /** Checks invariants (assumes that <CODE>Token</CODE> fields
     haven't been mucked with by outside code).  <code>prefix</code> is
     used to prefix error messages with context provided by the
     caller. */

    public void zzz(String prefix) {
        super.zzz();
        lookaheadq.zzz("Near character "
                       + Location.toOffset(startingLoc)
                       + ": " + prefix);
    }
}

class PunctuationPrefixTree {
    public static final int CHILDLEN = 1 + '~' - '!';

    /*@ invariant code != TagConstants.IDENT &&
     code != TagConstants.BOOLEANLIT &&
     code != TagConstants.INTLIT &&
     code != TagConstants.LONGLIT &&
     code != TagConstants.FLOATLIT &&
     code != TagConstants.DOUBLELIT &&
     code != TagConstants.STRINGLIT &&
     code != TagConstants.CHARLIT &&
     code != TagConstants.LEXICALPRAGMA &&
     code != TagConstants.MODIFIERPRAGMA &&
     code != TagConstants.STMTPRAGMA &&
     code != TagConstants.TYPEDECLELEMPRAGMA &&
     code != TagConstants.TYPEMODIFIERPRAGMA; */
    public int code = TagConstants.NULL; // ! NULL ==> a punctuation string

    //@ invariant children != null;
    //@ invariant children.length == CHILDLEN;
    //@ invariant \typeof(children) == \type(PunctuationPrefixTree[]);
    public PunctuationPrefixTree[] children
            = new PunctuationPrefixTree[CHILDLEN];
}
